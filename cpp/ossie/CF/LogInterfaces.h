// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __LogInterfaces_hh__
#define __LogInterfaces_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
#endif



#ifndef __DataType_hh_EXTERNAL_GUARD__
#define __DataType_hh_EXTERNAL_GUARD__
#include <ossie/CF/DataType.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CF

_CORBA_MODULE_BEG

  class UnknownIdentifier : public ::CORBA::UserException {
  public:
    
    

    inline UnknownIdentifier() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnknownIdentifier(const UnknownIdentifier&);
    
    UnknownIdentifier& operator=(const UnknownIdentifier&);
    virtual ~UnknownIdentifier();
    virtual void _raise() const;
    static UnknownIdentifier* _downcast(::CORBA::Exception*);
    static const UnknownIdentifier* _downcast(const ::CORBA::Exception*);
    static inline UnknownIdentifier* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownIdentifier;

#ifndef __CF_mSysLogLevels__
#define __CF_mSysLogLevels__
  class SysLogLevels;
  class _objref_SysLogLevels;
  class _impl_SysLogLevels;
  
  typedef _objref_SysLogLevels* SysLogLevels_ptr;
  typedef SysLogLevels_ptr SysLogLevelsRef;

  class SysLogLevels_Helper {
  public:
    typedef SysLogLevels_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SysLogLevels, SysLogLevels_Helper> SysLogLevels_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SysLogLevels,SysLogLevels_Helper > SysLogLevels_out;

#endif

  // interface SysLogLevels
  class SysLogLevels {
  public:
    // Declarations for this interface type.
    typedef SysLogLevels_ptr _ptr_type;
    typedef SysLogLevels_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _core_attr const ::CORBA::Long SECURITY_ALARM _init_in_cldecl_( = 1 );

    static _core_attr const ::CORBA::Long FAILURE_ALARM _init_in_cldecl_( = 2 );

    static _core_attr const ::CORBA::Long DEGRADED_ALARM _init_in_cldecl_( = 3 );

    static _core_attr const ::CORBA::Long EXCEPTION_ERROR _init_in_cldecl_( = 4 );

    static _core_attr const ::CORBA::Long FLOW_CONTROL_ERROR _init_in_cldecl_( = 5 );

    static _core_attr const ::CORBA::Long RANGE_ERROR _init_in_cldecl_( = 6 );

    static _core_attr const ::CORBA::Long USAGE_ERROR _init_in_cldecl_( = 7 );

    static _core_attr const ::CORBA::Long ADMINISTRATIVE_EVENT _init_in_cldecl_( = 8 );

    static _core_attr const ::CORBA::Long STATISTIC_REPORT _init_in_cldecl_( = 9 );

  
  };

  class _objref_SysLogLevels :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    

    // Constructors
    inline _objref_SysLogLevels()  { _PR_setobj(0); }  // nil
    _objref_SysLogLevels(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SysLogLevels();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SysLogLevels(const _objref_SysLogLevels&);
    _objref_SysLogLevels& operator = (const _objref_SysLogLevels&);
    // not implemented

    friend class SysLogLevels;
  };

  class _pof_SysLogLevels : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SysLogLevels() : _OMNI_NS(proxyObjectFactory)(SysLogLevels::_PD_repoId) {}
    virtual ~_pof_SysLogLevels();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SysLogLevels :
    public virtual omniServant
  {
  public:
    virtual ~_impl_SysLogLevels();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SysLogLevels;

#ifndef __CF_mLogLevels__
#define __CF_mLogLevels__
  class LogLevels;
  class _objref_LogLevels;
  class _impl_LogLevels;
  
  typedef _objref_LogLevels* LogLevels_ptr;
  typedef LogLevels_ptr LogLevelsRef;

  class LogLevels_Helper {
  public:
    typedef LogLevels_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LogLevels, LogLevels_Helper> LogLevels_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LogLevels,LogLevels_Helper > LogLevels_out;

#endif

  // interface LogLevels
  class LogLevels {
  public:
    // Declarations for this interface type.
    typedef LogLevels_ptr _ptr_type;
    typedef LogLevels_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _core_attr const ::CORBA::Long OFF _init_in_cldecl_( = 60000 );

    static _core_attr const ::CORBA::Long FATAL _init_in_cldecl_( = 50000 );

    static _core_attr const ::CORBA::Long ERROR _init_in_cldecl_( = 40000 );

    static _core_attr const ::CORBA::Long WARN _init_in_cldecl_( = 30000 );

    static _core_attr const ::CORBA::Long INFO _init_in_cldecl_( = 20000 );

    static _core_attr const ::CORBA::Long DEBUG _init_in_cldecl_( = 10000 );

    static _core_attr const ::CORBA::Long TRACE _init_in_cldecl_( = 5000 );

    static _core_attr const ::CORBA::Long ALL _init_in_cldecl_( = 0 );

  
  };

  class _objref_LogLevels :
    public virtual _objref_SysLogLevels
  {
  public:
    // IDL operations
    

    // Constructors
    inline _objref_LogLevels()  { _PR_setobj(0); }  // nil
    _objref_LogLevels(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LogLevels();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LogLevels(const _objref_LogLevels&);
    _objref_LogLevels& operator = (const _objref_LogLevels&);
    // not implemented

    friend class LogLevels;
  };

  class _pof_LogLevels : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LogLevels() : _OMNI_NS(proxyObjectFactory)(LogLevels::_PD_repoId) {}
    virtual ~_pof_LogLevels();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LogLevels :
    public virtual _impl_SysLogLevels
  {
  public:
    virtual ~_impl_LogLevels();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogLevels;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogLevel;

  typedef ::CORBA::Long LogLevel;
  typedef ::CORBA::Long_out LogLevel_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RecordId;

  typedef ::CORBA::ULongLong RecordId;
  typedef ::CORBA::ULongLong_out RecordId_out;

  enum LogOperationalState { LOG_DISABLED, LOG_ENABLED /*, __max_LogOperationalState=0xffffffff */ };
  typedef LogOperationalState& LogOperationalState_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogOperationalState;

  enum LogAdministrativeState { LOG_LOCKED, LOG_UNLOCKED /*, __max_LogAdministrativeState=0xffffffff */ };
  typedef LogAdministrativeState& LogAdministrativeState_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogAdministrativeState;

  enum LogFullAction { WRAP, HALT /*, __max_LogFullAction=0xffffffff */ };
  typedef LogFullAction& LogFullAction_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogFullAction;

  struct LogTime {
    typedef _CORBA_ConstrType_Fix_Var<LogTime> _var_type;

    
    ::CORBA::Long seconds;

    ::CORBA::Long nanoseconds;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LogTime::_var_type LogTime_var;

  typedef LogTime& LogTime_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogTime;

  struct LogAvailabilityStatus {
    typedef _CORBA_ConstrType_Fix_Var<LogAvailabilityStatus> _var_type;

    
    ::CORBA::Boolean off_duty;

    ::CORBA::Boolean log_full;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LogAvailabilityStatus::_var_type LogAvailabilityStatus_var;

  typedef LogAvailabilityStatus& LogAvailabilityStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogAvailabilityStatus;

  struct LogEvent {
    typedef _CORBA_ConstrType_Variable_Var<LogEvent> _var_type;

    
    ::CORBA::String_member producerId;

    ::CORBA::String_member producerName;

    ::CORBA::String_member producerName_fqn;

    ::CORBA::ULongLong timeStamp;

    LogLevel level;

    ::CORBA::String_member msg;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LogEvent::_var_type LogEvent_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< LogEvent,LogEvent_var > LogEvent_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogEvent;

  struct LogRecord {
    typedef _CORBA_ConstrType_Variable_Var<LogRecord> _var_type;

    
    RecordId id;

    LogTime time;

    LogEvent info;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LogRecord::_var_type LogRecord_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< LogRecord,LogRecord_var > LogRecord_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogRecord;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogRecordSequence;

  class LogRecordSequence_var;

  class LogRecordSequence : public _CORBA_Unbounded_Sequence< LogRecord >  {
  public:
    typedef LogRecordSequence_var _var_type;
    inline LogRecordSequence() {}
    inline LogRecordSequence(const LogRecordSequence& _s)
      : _CORBA_Unbounded_Sequence< LogRecord > (_s) {}

    inline LogRecordSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LogRecord > (_max) {}
    inline LogRecordSequence(_CORBA_ULong _max, _CORBA_ULong _len, LogRecord* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LogRecord > (_max, _len, _val, _rel) {}

  

    inline LogRecordSequence& operator = (const LogRecordSequence& _s) {
      _CORBA_Unbounded_Sequence< LogRecord > ::operator=(_s);
      return *this;
    }
  };

  class LogRecordSequence_out;

  class LogRecordSequence_var {
  public:
    inline LogRecordSequence_var() : _pd_seq(0) {}
    inline LogRecordSequence_var(LogRecordSequence* _s) : _pd_seq(_s) {}
    inline LogRecordSequence_var(const LogRecordSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new LogRecordSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~LogRecordSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline LogRecordSequence_var& operator = (LogRecordSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LogRecordSequence_var& operator = (const LogRecordSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new LogRecordSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline LogRecord& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LogRecordSequence* operator -> () { return _pd_seq; }
    inline const LogRecordSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LogRecordSequence& () const { return *_pd_seq; }
#else
    inline operator const LogRecordSequence& () const { return *_pd_seq; }
    inline operator LogRecordSequence& () { return *_pd_seq; }
#endif
      
    inline const LogRecordSequence& in() const { return *_pd_seq; }
    inline LogRecordSequence&       inout()    { return *_pd_seq; }
    inline LogRecordSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LogRecordSequence* _retn() { LogRecordSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LogRecordSequence_out;
    
  private:
    LogRecordSequence* _pd_seq;
  };

  class LogRecordSequence_out {
  public:
    inline LogRecordSequence_out(LogRecordSequence*& _s) : _data(_s) { _data = 0; }
    inline LogRecordSequence_out(LogRecordSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LogRecordSequence*) 0; }
    inline LogRecordSequence_out(const LogRecordSequence_out& _s) : _data(_s._data) {}
    inline LogRecordSequence_out& operator = (const LogRecordSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LogRecordSequence_out& operator = (LogRecordSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LogRecordSequence*&()  { return _data; }
    inline LogRecordSequence*& ptr()       { return _data; }
    inline LogRecordSequence* operator->() { return _data; }

    inline LogRecord& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LogRecordSequence*& _data;

  private:
    LogRecordSequence_out();
    LogRecordSequence_out& operator=(const LogRecordSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogEventSequence;

  class LogEventSequence_var;

  class LogEventSequence : public _CORBA_Unbounded_Sequence< LogEvent >  {
  public:
    typedef LogEventSequence_var _var_type;
    inline LogEventSequence() {}
    inline LogEventSequence(const LogEventSequence& _s)
      : _CORBA_Unbounded_Sequence< LogEvent > (_s) {}

    inline LogEventSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LogEvent > (_max) {}
    inline LogEventSequence(_CORBA_ULong _max, _CORBA_ULong _len, LogEvent* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LogEvent > (_max, _len, _val, _rel) {}

  

    inline LogEventSequence& operator = (const LogEventSequence& _s) {
      _CORBA_Unbounded_Sequence< LogEvent > ::operator=(_s);
      return *this;
    }
  };

  class LogEventSequence_out;

  class LogEventSequence_var {
  public:
    inline LogEventSequence_var() : _pd_seq(0) {}
    inline LogEventSequence_var(LogEventSequence* _s) : _pd_seq(_s) {}
    inline LogEventSequence_var(const LogEventSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new LogEventSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~LogEventSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline LogEventSequence_var& operator = (LogEventSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LogEventSequence_var& operator = (const LogEventSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new LogEventSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline LogEvent& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LogEventSequence* operator -> () { return _pd_seq; }
    inline const LogEventSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LogEventSequence& () const { return *_pd_seq; }
#else
    inline operator const LogEventSequence& () const { return *_pd_seq; }
    inline operator LogEventSequence& () { return *_pd_seq; }
#endif
      
    inline const LogEventSequence& in() const { return *_pd_seq; }
    inline LogEventSequence&       inout()    { return *_pd_seq; }
    inline LogEventSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LogEventSequence* _retn() { LogEventSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LogEventSequence_out;
    
  private:
    LogEventSequence* _pd_seq;
  };

  class LogEventSequence_out {
  public:
    inline LogEventSequence_out(LogEventSequence*& _s) : _data(_s) { _data = 0; }
    inline LogEventSequence_out(LogEventSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LogEventSequence*) 0; }
    inline LogEventSequence_out(const LogEventSequence_out& _s) : _data(_s._data) {}
    inline LogEventSequence_out& operator = (const LogEventSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LogEventSequence_out& operator = (LogEventSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LogEventSequence*&()  { return _data; }
    inline LogEventSequence*& ptr()       { return _data; }
    inline LogEventSequence* operator->() { return _data; }

    inline LogEvent& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LogEventSequence*& _data;

  private:
    LogEventSequence_out();
    LogEventSequence_out& operator=(const LogEventSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogLevelSequence;

  class LogLevelSequence_var;

  class LogLevelSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< LogLevel, 4, 4 >  {
  public:
    typedef LogLevelSequence_var _var_type;
    inline LogLevelSequence() {}
    inline LogLevelSequence(const LogLevelSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< LogLevel, 4, 4 > (_s) {}

    inline LogLevelSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< LogLevel, 4, 4 > (_max) {}
    inline LogLevelSequence(_CORBA_ULong _max, _CORBA_ULong _len, LogLevel* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< LogLevel, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline LogLevelSequence& operator = (const LogLevelSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< LogLevel, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class LogLevelSequence_out;

  class LogLevelSequence_var {
  public:
    inline LogLevelSequence_var() : _pd_seq(0) {}
    inline LogLevelSequence_var(LogLevelSequence* _s) : _pd_seq(_s) {}
    inline LogLevelSequence_var(const LogLevelSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new LogLevelSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~LogLevelSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline LogLevelSequence_var& operator = (LogLevelSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LogLevelSequence_var& operator = (const LogLevelSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new LogLevelSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline LogLevel& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LogLevelSequence* operator -> () { return _pd_seq; }
    inline const LogLevelSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LogLevelSequence& () const { return *_pd_seq; }
#else
    inline operator const LogLevelSequence& () const { return *_pd_seq; }
    inline operator LogLevelSequence& () { return *_pd_seq; }
#endif
      
    inline const LogLevelSequence& in() const { return *_pd_seq; }
    inline LogLevelSequence&       inout()    { return *_pd_seq; }
    inline LogLevelSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LogLevelSequence* _retn() { LogLevelSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LogLevelSequence_out;
    
  private:
    LogLevelSequence* _pd_seq;
  };

  class LogLevelSequence_out {
  public:
    inline LogLevelSequence_out(LogLevelSequence*& _s) : _data(_s) { _data = 0; }
    inline LogLevelSequence_out(LogLevelSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LogLevelSequence*) 0; }
    inline LogLevelSequence_out(const LogLevelSequence_out& _s) : _data(_s._data) {}
    inline LogLevelSequence_out& operator = (const LogLevelSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LogLevelSequence_out& operator = (LogLevelSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LogLevelSequence*&()  { return _data; }
    inline LogLevelSequence*& ptr()       { return _data; }
    inline LogLevelSequence* operator->() { return _data; }

    inline LogLevel& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LogLevelSequence*& _data;

  private:
    LogLevelSequence_out();
    LogLevelSequence_out& operator=(const LogLevelSequence_var&);
  };

#ifndef __CF_mLogStatus__
#define __CF_mLogStatus__
  class LogStatus;
  class _objref_LogStatus;
  class _impl_LogStatus;
  
  typedef _objref_LogStatus* LogStatus_ptr;
  typedef LogStatus_ptr LogStatusRef;

  class LogStatus_Helper {
  public:
    typedef LogStatus_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LogStatus, LogStatus_Helper> LogStatus_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LogStatus,LogStatus_Helper > LogStatus_out;

#endif

  // interface LogStatus
  class LogStatus {
  public:
    // Declarations for this interface type.
    typedef LogStatus_ptr _ptr_type;
    typedef LogStatus_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_LogStatus :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::ULongLong get_max_size();
    ::CORBA::ULongLong get_current_size();
    ::CORBA::ULongLong get_n_records();
    LogFullAction get_log_full_action();
    LogAdministrativeState get_administrative_state();
    LogOperationalState get_operational_state();
    LogAvailabilityStatus get_availability_status();

    // Constructors
    inline _objref_LogStatus()  { _PR_setobj(0); }  // nil
    _objref_LogStatus(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LogStatus();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LogStatus(const _objref_LogStatus&);
    _objref_LogStatus& operator = (const _objref_LogStatus&);
    // not implemented

    friend class LogStatus;
  };

  class _pof_LogStatus : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LogStatus() : _OMNI_NS(proxyObjectFactory)(LogStatus::_PD_repoId) {}
    virtual ~_pof_LogStatus();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LogStatus :
    public virtual omniServant
  {
  public:
    virtual ~_impl_LogStatus();

    virtual ::CORBA::ULongLong get_max_size() = 0;
    virtual ::CORBA::ULongLong get_current_size() = 0;
    virtual ::CORBA::ULongLong get_n_records() = 0;
    virtual LogFullAction get_log_full_action() = 0;
    virtual LogAdministrativeState get_administrative_state() = 0;
    virtual LogOperationalState get_operational_state() = 0;
    virtual LogAvailabilityStatus get_availability_status() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogStatus;

#ifndef __CF_mLogAdministrator__
#define __CF_mLogAdministrator__
  class LogAdministrator;
  class _objref_LogAdministrator;
  class _impl_LogAdministrator;
  
  typedef _objref_LogAdministrator* LogAdministrator_ptr;
  typedef LogAdministrator_ptr LogAdministratorRef;

  class LogAdministrator_Helper {
  public:
    typedef LogAdministrator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LogAdministrator, LogAdministrator_Helper> LogAdministrator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LogAdministrator,LogAdministrator_Helper > LogAdministrator_out;

#endif

  // interface LogAdministrator
  class LogAdministrator {
  public:
    // Declarations for this interface type.
    typedef LogAdministrator_ptr _ptr_type;
    typedef LogAdministrator_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_LogAdministrator :
    public virtual _objref_LogStatus
  {
  public:
    // IDL operations
    void set_max_size(::CORBA::ULongLong size);
    void set_log_full_action(::CF::LogFullAction action);
    void set_administrative_state(::CF::LogAdministrativeState state);
    void clear_log();
    void destroy();

    // Constructors
    inline _objref_LogAdministrator()  { _PR_setobj(0); }  // nil
    _objref_LogAdministrator(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LogAdministrator();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LogAdministrator(const _objref_LogAdministrator&);
    _objref_LogAdministrator& operator = (const _objref_LogAdministrator&);
    // not implemented

    friend class LogAdministrator;
  };

  class _pof_LogAdministrator : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LogAdministrator() : _OMNI_NS(proxyObjectFactory)(LogAdministrator::_PD_repoId) {}
    virtual ~_pof_LogAdministrator();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LogAdministrator :
    public virtual _impl_LogStatus
  {
  public:
    virtual ~_impl_LogAdministrator();

    virtual void set_max_size(::CORBA::ULongLong size) = 0;
    virtual void set_log_full_action(::CF::LogFullAction action) = 0;
    virtual void set_administrative_state(::CF::LogAdministrativeState state) = 0;
    virtual void clear_log() = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogAdministrator;

#ifndef __CF_mLogProducer__
#define __CF_mLogProducer__
  class LogProducer;
  class _objref_LogProducer;
  class _impl_LogProducer;
  
  typedef _objref_LogProducer* LogProducer_ptr;
  typedef LogProducer_ptr LogProducerRef;

  class LogProducer_Helper {
  public:
    typedef LogProducer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LogProducer, LogProducer_Helper> LogProducer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LogProducer,LogProducer_Helper > LogProducer_out;

#endif

  // interface LogProducer
  class LogProducer {
  public:
    // Declarations for this interface type.
    typedef LogProducer_ptr _ptr_type;
    typedef LogProducer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_LogProducer :
    public virtual _objref_LogStatus
  {
  public:
    // IDL operations
    void write_records(const ::CF::LogEventSequence& records);
    void write_record(const ::CF::LogEventSequence& record);

    // Constructors
    inline _objref_LogProducer()  { _PR_setobj(0); }  // nil
    _objref_LogProducer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LogProducer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LogProducer(const _objref_LogProducer&);
    _objref_LogProducer& operator = (const _objref_LogProducer&);
    // not implemented

    friend class LogProducer;
  };

  class _pof_LogProducer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LogProducer() : _OMNI_NS(proxyObjectFactory)(LogProducer::_PD_repoId) {}
    virtual ~_pof_LogProducer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LogProducer :
    public virtual _impl_LogStatus
  {
  public:
    virtual ~_impl_LogProducer();

    virtual void write_records(const ::CF::LogEventSequence& records) = 0;
    virtual void write_record(const ::CF::LogEventSequence& record) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogProducer;

#ifndef __CF_mLogEventConsumer__
#define __CF_mLogEventConsumer__
  class LogEventConsumer;
  class _objref_LogEventConsumer;
  class _impl_LogEventConsumer;
  
  typedef _objref_LogEventConsumer* LogEventConsumer_ptr;
  typedef LogEventConsumer_ptr LogEventConsumerRef;

  class LogEventConsumer_Helper {
  public:
    typedef LogEventConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LogEventConsumer, LogEventConsumer_Helper> LogEventConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LogEventConsumer,LogEventConsumer_Helper > LogEventConsumer_out;

#endif

  // interface LogEventConsumer
  class LogEventConsumer {
  public:
    // Declarations for this interface type.
    typedef LogEventConsumer_ptr _ptr_type;
    typedef LogEventConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_LogEventConsumer :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    LogEventSequence* retrieve_records(::CORBA::ULong& howMany, ::CORBA::ULong startingRecord);
    LogEventSequence* retrieve_records_by_date(::CORBA::ULong& howMany, ::CORBA::ULongLong to_timeStamp);
    LogEventSequence* retrieve_records_from_date(::CORBA::ULong& howMany, ::CORBA::ULongLong from_timeStamp);

    // Constructors
    inline _objref_LogEventConsumer()  { _PR_setobj(0); }  // nil
    _objref_LogEventConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LogEventConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LogEventConsumer(const _objref_LogEventConsumer&);
    _objref_LogEventConsumer& operator = (const _objref_LogEventConsumer&);
    // not implemented

    friend class LogEventConsumer;
  };

  class _pof_LogEventConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LogEventConsumer() : _OMNI_NS(proxyObjectFactory)(LogEventConsumer::_PD_repoId) {}
    virtual ~_pof_LogEventConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LogEventConsumer :
    public virtual omniServant
  {
  public:
    virtual ~_impl_LogEventConsumer();

    virtual LogEventSequence* retrieve_records(::CORBA::ULong& howMany, ::CORBA::ULong startingRecord) = 0;
    virtual LogEventSequence* retrieve_records_by_date(::CORBA::ULong& howMany, ::CORBA::ULongLong to_timeStamp) = 0;
    virtual LogEventSequence* retrieve_records_from_date(::CORBA::ULong& howMany, ::CORBA::ULongLong from_timeStamp) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogEventConsumer;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogConfigID;

  typedef char* LogConfigID;
  typedef ::CORBA::String_var LogConfigID_var;
  typedef ::CORBA::String_out LogConfigID_out;

#ifndef __CF_mLogConfigurator__
#define __CF_mLogConfigurator__
  class LogConfigurator;
  class _objref_LogConfigurator;
  class _impl_LogConfigurator;
  
  typedef _objref_LogConfigurator* LogConfigurator_ptr;
  typedef LogConfigurator_ptr LogConfiguratorRef;

  class LogConfigurator_Helper {
  public:
    typedef LogConfigurator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LogConfigurator, LogConfigurator_Helper> LogConfigurator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LogConfigurator,LogConfigurator_Helper > LogConfigurator_out;

#endif

  // interface LogConfigurator
  class LogConfigurator {
  public:
    // Declarations for this interface type.
    typedef LogConfigurator_ptr _ptr_type;
    typedef LogConfigurator_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_LogConfigurator :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    LogLevel getLogLevel(const char* config_id);
    char* getLogConfig(const char* config_id);

    // Constructors
    inline _objref_LogConfigurator()  { _PR_setobj(0); }  // nil
    _objref_LogConfigurator(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LogConfigurator();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LogConfigurator(const _objref_LogConfigurator&);
    _objref_LogConfigurator& operator = (const _objref_LogConfigurator&);
    // not implemented

    friend class LogConfigurator;
  };

  class _pof_LogConfigurator : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LogConfigurator() : _OMNI_NS(proxyObjectFactory)(LogConfigurator::_PD_repoId) {}
    virtual ~_pof_LogConfigurator();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LogConfigurator :
    public virtual omniServant
  {
  public:
    virtual ~_impl_LogConfigurator();

    virtual LogLevel getLogLevel(const char* config_id) = 0;
    virtual char* getLogConfig(const char* config_id) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogConfigurator;

#ifndef __CF_mLogConfiguration__
#define __CF_mLogConfiguration__
  class LogConfiguration;
  class _objref_LogConfiguration;
  class _impl_LogConfiguration;
  
  typedef _objref_LogConfiguration* LogConfiguration_ptr;
  typedef LogConfiguration_ptr LogConfigurationRef;

  class LogConfiguration_Helper {
  public:
    typedef LogConfiguration_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LogConfiguration, LogConfiguration_Helper> LogConfiguration_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LogConfiguration,LogConfiguration_Helper > LogConfiguration_out;

#endif

  // interface LogConfiguration
  class LogConfiguration {
  public:
    // Declarations for this interface type.
    typedef LogConfiguration_ptr _ptr_type;
    typedef LogConfiguration_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_LogConfiguration :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    LogLevel log_level();
    void log_level(::CF::LogLevel _v);
    LogLevel getLogLevel(const char* logger_id);
    void setLogLevel(const char* logger_id, ::CF::LogLevel newLevel);
    StringSequence* getNamedLoggers();
    void resetLog();
    char* getLogConfig();
    void setLogConfig(const char* config_contents);
    void setLogConfigURL(const char* config_url);

    // Constructors
    inline _objref_LogConfiguration()  { _PR_setobj(0); }  // nil
    _objref_LogConfiguration(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LogConfiguration();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LogConfiguration(const _objref_LogConfiguration&);
    _objref_LogConfiguration& operator = (const _objref_LogConfiguration&);
    // not implemented

    friend class LogConfiguration;
  };

  class _pof_LogConfiguration : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LogConfiguration() : _OMNI_NS(proxyObjectFactory)(LogConfiguration::_PD_repoId) {}
    virtual ~_pof_LogConfiguration();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LogConfiguration :
    public virtual omniServant
  {
  public:
    virtual ~_impl_LogConfiguration();

    virtual LogLevel log_level() = 0;
    virtual void log_level(::CF::LogLevel _v) = 0;
    virtual LogLevel getLogLevel(const char* logger_id) = 0;
    virtual void setLogLevel(const char* logger_id, ::CF::LogLevel newLevel) = 0;
    virtual StringSequence* getNamedLoggers() = 0;
    virtual void resetLog() = 0;
    virtual char* getLogConfig() = 0;
    virtual void setLogConfig(const char* config_contents) = 0;
    virtual void setLogConfigURL(const char* config_url) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogConfiguration;

#ifndef __CF_mLogging__
#define __CF_mLogging__
  class Logging;
  class _objref_Logging;
  class _impl_Logging;
  
  typedef _objref_Logging* Logging_ptr;
  typedef Logging_ptr LoggingRef;

  class Logging_Helper {
  public:
    typedef Logging_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Logging, Logging_Helper> Logging_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Logging,Logging_Helper > Logging_out;

#endif

  // interface Logging
  class Logging {
  public:
    // Declarations for this interface type.
    typedef Logging_ptr _ptr_type;
    typedef Logging_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Logging :
    public virtual _objref_LogEventConsumer,
    public virtual _objref_LogConfiguration
  {
  public:
    // IDL operations
    

    // Constructors
    inline _objref_Logging()  { _PR_setobj(0); }  // nil
    _objref_Logging(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Logging();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Logging(const _objref_Logging&);
    _objref_Logging& operator = (const _objref_Logging&);
    // not implemented

    friend class Logging;
  };

  class _pof_Logging : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Logging() : _OMNI_NS(proxyObjectFactory)(Logging::_PD_repoId) {}
    virtual ~_pof_Logging();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Logging :
    public virtual _impl_LogEventConsumer,
    public virtual _impl_LogConfiguration
  {
  public:
    virtual ~_impl_Logging();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Logging;

_CORBA_MODULE_END



_CORBA_MODULE POA_CF
_CORBA_MODULE_BEG

  class SysLogLevels :
    public virtual CF::_impl_SysLogLevels,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~SysLogLevels();

    inline ::CF::SysLogLevels_ptr _this() {
      return (::CF::SysLogLevels_ptr) _do_this(::CF::SysLogLevels::_PD_repoId);
    }
  };

  class LogLevels :
    public virtual CF::_impl_LogLevels,
    public virtual SysLogLevels
  {
  public:
    virtual ~LogLevels();

    inline ::CF::LogLevels_ptr _this() {
      return (::CF::LogLevels_ptr) _do_this(::CF::LogLevels::_PD_repoId);
    }
  };

  class LogStatus :
    public virtual CF::_impl_LogStatus,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~LogStatus();

    inline ::CF::LogStatus_ptr _this() {
      return (::CF::LogStatus_ptr) _do_this(::CF::LogStatus::_PD_repoId);
    }
  };

  class LogAdministrator :
    public virtual CF::_impl_LogAdministrator,
    public virtual LogStatus
  {
  public:
    virtual ~LogAdministrator();

    inline ::CF::LogAdministrator_ptr _this() {
      return (::CF::LogAdministrator_ptr) _do_this(::CF::LogAdministrator::_PD_repoId);
    }
  };

  class LogProducer :
    public virtual CF::_impl_LogProducer,
    public virtual LogStatus
  {
  public:
    virtual ~LogProducer();

    inline ::CF::LogProducer_ptr _this() {
      return (::CF::LogProducer_ptr) _do_this(::CF::LogProducer::_PD_repoId);
    }
  };

  class LogEventConsumer :
    public virtual CF::_impl_LogEventConsumer,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~LogEventConsumer();

    inline ::CF::LogEventConsumer_ptr _this() {
      return (::CF::LogEventConsumer_ptr) _do_this(::CF::LogEventConsumer::_PD_repoId);
    }
  };

  class LogConfigurator :
    public virtual CF::_impl_LogConfigurator,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~LogConfigurator();

    inline ::CF::LogConfigurator_ptr _this() {
      return (::CF::LogConfigurator_ptr) _do_this(::CF::LogConfigurator::_PD_repoId);
    }
  };

  class LogConfiguration :
    public virtual CF::_impl_LogConfiguration,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~LogConfiguration();

    inline ::CF::LogConfiguration_ptr _this() {
      return (::CF::LogConfiguration_ptr) _do_this(::CF::LogConfiguration::_PD_repoId);
    }
  };

  class Logging :
    public virtual CF::_impl_Logging,
    public virtual LogEventConsumer,
      public virtual LogConfiguration
  {
  public:
    virtual ~Logging();

    inline ::CF::Logging_ptr _this() {
      return (::CF::Logging_ptr) _do_this(::CF::Logging::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const CF::UnknownIdentifier& _s);
void operator<<=(::CORBA::Any& _a, const CF::UnknownIdentifier* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::UnknownIdentifier*& _sp);

void operator<<=(::CORBA::Any& _a, CF::SysLogLevels_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::SysLogLevels_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::SysLogLevels_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::LogLevels_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LogLevels_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogLevels_ptr& _s);

inline void operator >>=(CF::LogOperationalState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::LogOperationalState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::LOG_ENABLED) {
    _e = (CF::LogOperationalState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::LogOperationalState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogOperationalState& _s);

inline void operator >>=(CF::LogAdministrativeState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::LogAdministrativeState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::LOG_UNLOCKED) {
    _e = (CF::LogAdministrativeState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::LogAdministrativeState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogAdministrativeState& _s);

inline void operator >>=(CF::LogFullAction _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::LogFullAction& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::HALT) {
    _e = (CF::LogFullAction) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::LogFullAction _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogFullAction& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::LogTime& _s);
extern void operator<<=(::CORBA::Any& _a, CF::LogTime* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogTime*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LogTime*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::LogAvailabilityStatus& _s);
extern void operator<<=(::CORBA::Any& _a, CF::LogAvailabilityStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogAvailabilityStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LogAvailabilityStatus*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::LogEvent& _s);
extern void operator<<=(::CORBA::Any& _a, CF::LogEvent* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogEvent*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LogEvent*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::LogRecord& _s);
extern void operator<<=(::CORBA::Any& _a, CF::LogRecord* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogRecord*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LogRecord*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::LogRecordSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::LogRecordSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogRecordSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LogRecordSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::LogEventSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::LogEventSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogEventSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LogEventSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::LogLevelSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::LogLevelSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogLevelSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LogLevelSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::LogStatus_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LogStatus_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogStatus_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::LogAdministrator_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LogAdministrator_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogAdministrator_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::LogProducer_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LogProducer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogProducer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::LogEventConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LogEventConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogEventConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::LogConfigurator_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LogConfigurator_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogConfigurator_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::LogConfiguration_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LogConfiguration_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LogConfiguration_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::Logging_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Logging_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Logging_ptr& _s);



inline void
CF::SysLogLevels::_marshalObjRef(::CF::SysLogLevels_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LogLevels::_marshalObjRef(::CF::LogLevels_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LogStatus::_marshalObjRef(::CF::LogStatus_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LogAdministrator::_marshalObjRef(::CF::LogAdministrator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LogProducer::_marshalObjRef(::CF::LogProducer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LogEventConsumer::_marshalObjRef(::CF::LogEventConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LogConfigurator::_marshalObjRef(::CF::LogConfigurator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LogConfiguration::_marshalObjRef(::CF::LogConfiguration_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Logging::_marshalObjRef(::CF::Logging_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_LogInterfaces
#endif

#endif  // __LogInterfaces_hh__


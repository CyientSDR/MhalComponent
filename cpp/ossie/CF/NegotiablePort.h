// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __NegotiablePort_hh__
#define __NegotiablePort_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
#endif



#ifndef __DataType_hh_EXTERNAL_GUARD__
#define __DataType_hh_EXTERNAL_GUARD__
#include <ossie/CF/DataType.h>
#endif
#ifndef __Port_hh_EXTERNAL_GUARD__
#define __Port_hh_EXTERNAL_GUARD__
#include <ossie/CF/Port.h>
#endif
#ifndef __QueryablePort_hh_EXTERNAL_GUARD__
#define __QueryablePort_hh_EXTERNAL_GUARD__
#include <ossie/CF/QueryablePort.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE ExtendedCF

_CORBA_MODULE_BEG

  class NegotiationError : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member msg;

  

    inline NegotiationError() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    NegotiationError(const NegotiationError&);
    NegotiationError(const char* i_msg);
    NegotiationError& operator=(const NegotiationError&);
    virtual ~NegotiationError();
    virtual void _raise() const;
    static NegotiationError* _downcast(::CORBA::Exception*);
    static const NegotiationError* _downcast(const ::CORBA::Exception*);
    static inline NegotiationError* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NegotiationError;

  struct TransportInfo {
    typedef _CORBA_ConstrType_Variable_Var<TransportInfo> _var_type;

    
    ::CORBA::String_member transportType;

    CF::Properties transportProperties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TransportInfo::_var_type TransportInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TransportInfo,TransportInfo_var > TransportInfo_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransportInfo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TransportInfoSequence;

  class TransportInfoSequence_var;

  class TransportInfoSequence : public _CORBA_Unbounded_Sequence< TransportInfo >  {
  public:
    typedef TransportInfoSequence_var _var_type;
    inline TransportInfoSequence() {}
    inline TransportInfoSequence(const TransportInfoSequence& _s)
      : _CORBA_Unbounded_Sequence< TransportInfo > (_s) {}

    inline TransportInfoSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TransportInfo > (_max) {}
    inline TransportInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, TransportInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TransportInfo > (_max, _len, _val, _rel) {}

  

    inline TransportInfoSequence& operator = (const TransportInfoSequence& _s) {
      _CORBA_Unbounded_Sequence< TransportInfo > ::operator=(_s);
      return *this;
    }
  };

  class TransportInfoSequence_out;

  class TransportInfoSequence_var {
  public:
    inline TransportInfoSequence_var() : _pd_seq(0) {}
    inline TransportInfoSequence_var(TransportInfoSequence* _s) : _pd_seq(_s) {}
    inline TransportInfoSequence_var(const TransportInfoSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new TransportInfoSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~TransportInfoSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline TransportInfoSequence_var& operator = (TransportInfoSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TransportInfoSequence_var& operator = (const TransportInfoSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new TransportInfoSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline TransportInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TransportInfoSequence* operator -> () { return _pd_seq; }
    inline const TransportInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TransportInfoSequence& () const { return *_pd_seq; }
#else
    inline operator const TransportInfoSequence& () const { return *_pd_seq; }
    inline operator TransportInfoSequence& () { return *_pd_seq; }
#endif
      
    inline const TransportInfoSequence& in() const { return *_pd_seq; }
    inline TransportInfoSequence&       inout()    { return *_pd_seq; }
    inline TransportInfoSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TransportInfoSequence* _retn() { TransportInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TransportInfoSequence_out;
    
  private:
    TransportInfoSequence* _pd_seq;
  };

  class TransportInfoSequence_out {
  public:
    inline TransportInfoSequence_out(TransportInfoSequence*& _s) : _data(_s) { _data = 0; }
    inline TransportInfoSequence_out(TransportInfoSequence_var& _s)
      : _data(_s._pd_seq) { _s = (TransportInfoSequence*) 0; }
    inline TransportInfoSequence_out(const TransportInfoSequence_out& _s) : _data(_s._data) {}
    inline TransportInfoSequence_out& operator = (const TransportInfoSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TransportInfoSequence_out& operator = (TransportInfoSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator TransportInfoSequence*&()  { return _data; }
    inline TransportInfoSequence*& ptr()       { return _data; }
    inline TransportInfoSequence* operator->() { return _data; }

    inline TransportInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TransportInfoSequence*& _data;

  private:
    TransportInfoSequence_out();
    TransportInfoSequence_out& operator=(const TransportInfoSequence_var&);
  };

#ifndef __ExtendedCF_mNegotiablePort__
#define __ExtendedCF_mNegotiablePort__
  class NegotiablePort;
  class _objref_NegotiablePort;
  class _impl_NegotiablePort;
  
  typedef _objref_NegotiablePort* NegotiablePort_ptr;
  typedef NegotiablePort_ptr NegotiablePortRef;

  class NegotiablePort_Helper {
  public:
    typedef NegotiablePort_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_NegotiablePort, NegotiablePort_Helper> NegotiablePort_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_NegotiablePort,NegotiablePort_Helper > NegotiablePort_out;

#endif

  // interface NegotiablePort
  class NegotiablePort {
  public:
    // Declarations for this interface type.
    typedef NegotiablePort_ptr _ptr_type;
    typedef NegotiablePort_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_NegotiablePort :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    TransportInfoSequence* supportedTransports();

    // Constructors
    inline _objref_NegotiablePort()  { _PR_setobj(0); }  // nil
    _objref_NegotiablePort(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_NegotiablePort();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_NegotiablePort(const _objref_NegotiablePort&);
    _objref_NegotiablePort& operator = (const _objref_NegotiablePort&);
    // not implemented

    friend class NegotiablePort;
  };

  class _pof_NegotiablePort : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_NegotiablePort() : _OMNI_NS(proxyObjectFactory)(NegotiablePort::_PD_repoId) {}
    virtual ~_pof_NegotiablePort();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_NegotiablePort :
    public virtual omniServant
  {
  public:
    virtual ~_impl_NegotiablePort();

    virtual TransportInfoSequence* supportedTransports() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NegotiablePort;

  struct ConnectionStatus {
    typedef _CORBA_ConstrType_Variable_Var<ConnectionStatus> _var_type;

    
    ::CORBA::String_member connectionId;

    ::CORBA::Object_Member port;

    ::CORBA::Boolean alive;

    ::CORBA::String_member transportType;

    CF::Properties transportInfo;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ConnectionStatus::_var_type ConnectionStatus_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ConnectionStatus,ConnectionStatus_var > ConnectionStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionStatus;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionStatusSequence;

  class ConnectionStatusSequence_var;

  class ConnectionStatusSequence : public _CORBA_Unbounded_Sequence< ConnectionStatus >  {
  public:
    typedef ConnectionStatusSequence_var _var_type;
    inline ConnectionStatusSequence() {}
    inline ConnectionStatusSequence(const ConnectionStatusSequence& _s)
      : _CORBA_Unbounded_Sequence< ConnectionStatus > (_s) {}

    inline ConnectionStatusSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ConnectionStatus > (_max) {}
    inline ConnectionStatusSequence(_CORBA_ULong _max, _CORBA_ULong _len, ConnectionStatus* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ConnectionStatus > (_max, _len, _val, _rel) {}

  

    inline ConnectionStatusSequence& operator = (const ConnectionStatusSequence& _s) {
      _CORBA_Unbounded_Sequence< ConnectionStatus > ::operator=(_s);
      return *this;
    }
  };

  class ConnectionStatusSequence_out;

  class ConnectionStatusSequence_var {
  public:
    inline ConnectionStatusSequence_var() : _pd_seq(0) {}
    inline ConnectionStatusSequence_var(ConnectionStatusSequence* _s) : _pd_seq(_s) {}
    inline ConnectionStatusSequence_var(const ConnectionStatusSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ConnectionStatusSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ConnectionStatusSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ConnectionStatusSequence_var& operator = (ConnectionStatusSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ConnectionStatusSequence_var& operator = (const ConnectionStatusSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new ConnectionStatusSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ConnectionStatus& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ConnectionStatusSequence* operator -> () { return _pd_seq; }
    inline const ConnectionStatusSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ConnectionStatusSequence& () const { return *_pd_seq; }
#else
    inline operator const ConnectionStatusSequence& () const { return *_pd_seq; }
    inline operator ConnectionStatusSequence& () { return *_pd_seq; }
#endif
      
    inline const ConnectionStatusSequence& in() const { return *_pd_seq; }
    inline ConnectionStatusSequence&       inout()    { return *_pd_seq; }
    inline ConnectionStatusSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ConnectionStatusSequence* _retn() { ConnectionStatusSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ConnectionStatusSequence_out;
    
  private:
    ConnectionStatusSequence* _pd_seq;
  };

  class ConnectionStatusSequence_out {
  public:
    inline ConnectionStatusSequence_out(ConnectionStatusSequence*& _s) : _data(_s) { _data = 0; }
    inline ConnectionStatusSequence_out(ConnectionStatusSequence_var& _s)
      : _data(_s._pd_seq) { _s = (ConnectionStatusSequence*) 0; }
    inline ConnectionStatusSequence_out(const ConnectionStatusSequence_out& _s) : _data(_s._data) {}
    inline ConnectionStatusSequence_out& operator = (const ConnectionStatusSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ConnectionStatusSequence_out& operator = (ConnectionStatusSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator ConnectionStatusSequence*&()  { return _data; }
    inline ConnectionStatusSequence*& ptr()       { return _data; }
    inline ConnectionStatusSequence* operator->() { return _data; }

    inline ConnectionStatus& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ConnectionStatusSequence*& _data;

  private:
    ConnectionStatusSequence_out();
    ConnectionStatusSequence_out& operator=(const ConnectionStatusSequence_var&);
  };

#ifndef __ExtendedCF_mNegotiableUsesPort__
#define __ExtendedCF_mNegotiableUsesPort__
  class NegotiableUsesPort;
  class _objref_NegotiableUsesPort;
  class _impl_NegotiableUsesPort;
  
  typedef _objref_NegotiableUsesPort* NegotiableUsesPort_ptr;
  typedef NegotiableUsesPort_ptr NegotiableUsesPortRef;

  class NegotiableUsesPort_Helper {
  public:
    typedef NegotiableUsesPort_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_NegotiableUsesPort, NegotiableUsesPort_Helper> NegotiableUsesPort_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_NegotiableUsesPort,NegotiableUsesPort_Helper > NegotiableUsesPort_out;

#endif

  // interface NegotiableUsesPort
  class NegotiableUsesPort {
  public:
    // Declarations for this interface type.
    typedef NegotiableUsesPort_ptr _ptr_type;
    typedef NegotiableUsesPort_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_NegotiableUsesPort :
    public virtual _objref_QueryablePort,
    public virtual _objref_NegotiablePort
  {
  public:
    // IDL operations
    ConnectionStatusSequence* connectionStatus();

    // Constructors
    inline _objref_NegotiableUsesPort()  { _PR_setobj(0); }  // nil
    _objref_NegotiableUsesPort(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_NegotiableUsesPort();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_NegotiableUsesPort(const _objref_NegotiableUsesPort&);
    _objref_NegotiableUsesPort& operator = (const _objref_NegotiableUsesPort&);
    // not implemented

    friend class NegotiableUsesPort;
  };

  class _pof_NegotiableUsesPort : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_NegotiableUsesPort() : _OMNI_NS(proxyObjectFactory)(NegotiableUsesPort::_PD_repoId) {}
    virtual ~_pof_NegotiableUsesPort();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_NegotiableUsesPort :
    public virtual _impl_QueryablePort,
    public virtual _impl_NegotiablePort
  {
  public:
    virtual ~_impl_NegotiableUsesPort();

    virtual ConnectionStatusSequence* connectionStatus() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NegotiableUsesPort;

  struct NegotiationResult {
    typedef _CORBA_ConstrType_Variable_Var<NegotiationResult> _var_type;

    
    ::CORBA::String_member transportId;

    CF::Properties properties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef NegotiationResult::_var_type NegotiationResult_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< NegotiationResult,NegotiationResult_var > NegotiationResult_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NegotiationResult;

#ifndef __ExtendedCF_mNegotiableProvidesPort__
#define __ExtendedCF_mNegotiableProvidesPort__
  class NegotiableProvidesPort;
  class _objref_NegotiableProvidesPort;
  class _impl_NegotiableProvidesPort;
  
  typedef _objref_NegotiableProvidesPort* NegotiableProvidesPort_ptr;
  typedef NegotiableProvidesPort_ptr NegotiableProvidesPortRef;

  class NegotiableProvidesPort_Helper {
  public:
    typedef NegotiableProvidesPort_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_NegotiableProvidesPort, NegotiableProvidesPort_Helper> NegotiableProvidesPort_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_NegotiableProvidesPort,NegotiableProvidesPort_Helper > NegotiableProvidesPort_out;

#endif

  // interface NegotiableProvidesPort
  class NegotiableProvidesPort {
  public:
    // Declarations for this interface type.
    typedef NegotiableProvidesPort_ptr _ptr_type;
    typedef NegotiableProvidesPort_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_NegotiableProvidesPort :
    public virtual _objref_NegotiablePort
  {
  public:
    // IDL operations
    NegotiationResult* negotiateTransport(const char* transportType, const ::CF::Properties& transportProperties);
    void disconnectTransport(const char* transportId);

    // Constructors
    inline _objref_NegotiableProvidesPort()  { _PR_setobj(0); }  // nil
    _objref_NegotiableProvidesPort(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_NegotiableProvidesPort();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_NegotiableProvidesPort(const _objref_NegotiableProvidesPort&);
    _objref_NegotiableProvidesPort& operator = (const _objref_NegotiableProvidesPort&);
    // not implemented

    friend class NegotiableProvidesPort;
  };

  class _pof_NegotiableProvidesPort : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_NegotiableProvidesPort() : _OMNI_NS(proxyObjectFactory)(NegotiableProvidesPort::_PD_repoId) {}
    virtual ~_pof_NegotiableProvidesPort();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_NegotiableProvidesPort :
    public virtual _impl_NegotiablePort
  {
  public:
    virtual ~_impl_NegotiableProvidesPort();

    virtual NegotiationResult* negotiateTransport(const char* transportType, const ::CF::Properties& transportProperties) = 0;
    virtual void disconnectTransport(const char* transportId) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NegotiableProvidesPort;

_CORBA_MODULE_END



_CORBA_MODULE POA_ExtendedCF
_CORBA_MODULE_BEG

  class NegotiablePort :
    public virtual ExtendedCF::_impl_NegotiablePort,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~NegotiablePort();

    inline ::ExtendedCF::NegotiablePort_ptr _this() {
      return (::ExtendedCF::NegotiablePort_ptr) _do_this(::ExtendedCF::NegotiablePort::_PD_repoId);
    }
  };

  class NegotiableUsesPort :
    public virtual ExtendedCF::_impl_NegotiableUsesPort,
    public virtual QueryablePort,
      public virtual NegotiablePort
  {
  public:
    virtual ~NegotiableUsesPort();

    inline ::ExtendedCF::NegotiableUsesPort_ptr _this() {
      return (::ExtendedCF::NegotiableUsesPort_ptr) _do_this(::ExtendedCF::NegotiableUsesPort::_PD_repoId);
    }
  };

  class NegotiableProvidesPort :
    public virtual ExtendedCF::_impl_NegotiableProvidesPort,
    public virtual NegotiablePort
  {
  public:
    virtual ~NegotiableProvidesPort();

    inline ::ExtendedCF::NegotiableProvidesPort_ptr _this() {
      return (::ExtendedCF::NegotiableProvidesPort_ptr) _do_this(::ExtendedCF::NegotiableProvidesPort::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_ExtendedCF
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const ExtendedCF::NegotiationError& _s);
void operator<<=(::CORBA::Any& _a, const ExtendedCF::NegotiationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ExtendedCF::NegotiationError*& _sp);

extern void operator<<=(::CORBA::Any& _a, const ExtendedCF::TransportInfo& _s);
extern void operator<<=(::CORBA::Any& _a, ExtendedCF::TransportInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::TransportInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ExtendedCF::TransportInfo*& _sp);

void operator<<=(::CORBA::Any& _a, const ExtendedCF::TransportInfoSequence& _s);
void operator<<=(::CORBA::Any& _a, ExtendedCF::TransportInfoSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::TransportInfoSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ExtendedCF::TransportInfoSequence*& _sp);

void operator<<=(::CORBA::Any& _a, ExtendedCF::NegotiablePort_ptr _s);
void operator<<=(::CORBA::Any& _a, ExtendedCF::NegotiablePort_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::NegotiablePort_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const ExtendedCF::ConnectionStatus& _s);
extern void operator<<=(::CORBA::Any& _a, ExtendedCF::ConnectionStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::ConnectionStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ExtendedCF::ConnectionStatus*& _sp);

void operator<<=(::CORBA::Any& _a, const ExtendedCF::ConnectionStatusSequence& _s);
void operator<<=(::CORBA::Any& _a, ExtendedCF::ConnectionStatusSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::ConnectionStatusSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ExtendedCF::ConnectionStatusSequence*& _sp);

void operator<<=(::CORBA::Any& _a, ExtendedCF::NegotiableUsesPort_ptr _s);
void operator<<=(::CORBA::Any& _a, ExtendedCF::NegotiableUsesPort_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::NegotiableUsesPort_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const ExtendedCF::NegotiationResult& _s);
extern void operator<<=(::CORBA::Any& _a, ExtendedCF::NegotiationResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::NegotiationResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ExtendedCF::NegotiationResult*& _sp);

void operator<<=(::CORBA::Any& _a, ExtendedCF::NegotiableProvidesPort_ptr _s);
void operator<<=(::CORBA::Any& _a, ExtendedCF::NegotiableProvidesPort_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ExtendedCF::NegotiableProvidesPort_ptr& _s);



inline void
ExtendedCF::NegotiablePort::_marshalObjRef(::ExtendedCF::NegotiablePort_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
ExtendedCF::NegotiableUsesPort::_marshalObjRef(::ExtendedCF::NegotiableUsesPort_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
ExtendedCF::NegotiableProvidesPort::_marshalObjRef(::ExtendedCF::NegotiableProvidesPort_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_NegotiablePort
#endif

#endif  // __NegotiablePort_hh__


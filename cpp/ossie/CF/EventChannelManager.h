// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __EventChannelManager_hh__
#define __EventChannelManager_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
#endif



#ifndef __CosEventComm_hh_EXTERNAL_GUARD__
#define __CosEventComm_hh_EXTERNAL_GUARD__
#include <COS/CosEventComm.hh>
#endif
#ifndef __CosEventChannelAdmin_hh_EXTERNAL_GUARD__
#define __CosEventChannelAdmin_hh_EXTERNAL_GUARD__
#include <COS/CosEventChannelAdmin.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CF

_CORBA_MODULE_BEG

#ifndef __CF_mEventChannelInfoIterator__
#define __CF_mEventChannelInfoIterator__
  class EventChannelInfoIterator;
  class _objref_EventChannelInfoIterator;
  class _impl_EventChannelInfoIterator;
  
  typedef _objref_EventChannelInfoIterator* EventChannelInfoIterator_ptr;
  typedef EventChannelInfoIterator_ptr EventChannelInfoIteratorRef;

  class EventChannelInfoIterator_Helper {
  public:
    typedef EventChannelInfoIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannelInfoIterator, EventChannelInfoIterator_Helper> EventChannelInfoIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannelInfoIterator,EventChannelInfoIterator_Helper > EventChannelInfoIterator_out;

#endif

#ifndef __CF_mEventRegistrantIterator__
#define __CF_mEventRegistrantIterator__
  class EventRegistrantIterator;
  class _objref_EventRegistrantIterator;
  class _impl_EventRegistrantIterator;
  
  typedef _objref_EventRegistrantIterator* EventRegistrantIterator_ptr;
  typedef EventRegistrantIterator_ptr EventRegistrantIteratorRef;

  class EventRegistrantIterator_Helper {
  public:
    typedef EventRegistrantIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventRegistrantIterator, EventRegistrantIterator_Helper> EventRegistrantIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventRegistrantIterator,EventRegistrantIterator_Helper > EventRegistrantIterator_out;

#endif

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannel;

  typedef CosEventChannelAdmin::EventChannel EventChannel;
  typedef CosEventChannelAdmin::EventChannel_ptr EventChannel_ptr;
  typedef CosEventChannelAdmin::EventChannelRef EventChannelRef;
  typedef CosEventChannelAdmin::_impl_EventChannel _impl_EventChannel;
  typedef CosEventChannelAdmin::EventChannel_Helper EventChannel_Helper;
  typedef CosEventChannelAdmin::_objref_EventChannel _objref_EventChannel;
  typedef CosEventChannelAdmin::EventChannel_var EventChannel_var;
  typedef CosEventChannelAdmin::EventChannel_out EventChannel_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventPublisher;

  typedef CosEventChannelAdmin::ProxyPushConsumer EventPublisher;
  typedef CosEventChannelAdmin::ProxyPushConsumer_ptr EventPublisher_ptr;
  typedef CosEventChannelAdmin::ProxyPushConsumerRef EventPublisherRef;
  typedef CosEventChannelAdmin::_impl_ProxyPushConsumer _impl_EventPublisher;
  typedef CosEventChannelAdmin::ProxyPushConsumer_Helper EventPublisher_Helper;
  typedef CosEventChannelAdmin::_objref_ProxyPushConsumer _objref_EventPublisher;
  typedef CosEventChannelAdmin::ProxyPushConsumer_var EventPublisher_var;
  typedef CosEventChannelAdmin::ProxyPushConsumer_out EventPublisher_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventSubscriber;

  typedef CosEventChannelAdmin::ProxyPushSupplier EventSubscriber;
  typedef CosEventChannelAdmin::ProxyPushSupplier_ptr EventSubscriber_ptr;
  typedef CosEventChannelAdmin::ProxyPushSupplierRef EventSubscriberRef;
  typedef CosEventChannelAdmin::_impl_ProxyPushSupplier _impl_EventSubscriber;
  typedef CosEventChannelAdmin::ProxyPushSupplier_Helper EventSubscriber_Helper;
  typedef CosEventChannelAdmin::_objref_ProxyPushSupplier _objref_EventSubscriber;
  typedef CosEventChannelAdmin::ProxyPushSupplier_var EventSubscriber_var;
  typedef CosEventChannelAdmin::ProxyPushSupplier_out EventSubscriber_out;

#ifndef __CF_mEventChannelManager__
#define __CF_mEventChannelManager__
  class EventChannelManager;
  class _objref_EventChannelManager;
  class _impl_EventChannelManager;
  
  typedef _objref_EventChannelManager* EventChannelManager_ptr;
  typedef EventChannelManager_ptr EventChannelManagerRef;

  class EventChannelManager_Helper {
  public:
    typedef EventChannelManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannelManager, EventChannelManager_Helper> EventChannelManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannelManager,EventChannelManager_Helper > EventChannelManager_out;

#endif

  // interface EventChannelManager
  class EventChannelManager {
  public:
    // Declarations for this interface type.
    typedef EventChannelManager_ptr _ptr_type;
    typedef EventChannelManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct EventChannelInfo {
      typedef _CORBA_ConstrType_Variable_Var<EventChannelInfo> _var_type;

      
      ::CORBA::String_member channel_name;

      ::CORBA::Long reg_count;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef EventChannelInfo::_var_type EventChannelInfo_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< EventChannelInfo,EventChannelInfo_var > EventChannelInfo_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannelInfo;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannelInfoList;

    class EventChannelInfoList_var;

    class EventChannelInfoList : public _CORBA_Unbounded_Sequence< EventChannelInfo >  {
    public:
      typedef EventChannelInfoList_var _var_type;
      inline EventChannelInfoList() {}
      inline EventChannelInfoList(const EventChannelInfoList& _s)
        : _CORBA_Unbounded_Sequence< EventChannelInfo > (_s) {}

      inline EventChannelInfoList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< EventChannelInfo > (_max) {}
      inline EventChannelInfoList(_CORBA_ULong _max, _CORBA_ULong _len, EventChannelInfo* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< EventChannelInfo > (_max, _len, _val, _rel) {}

    

      inline EventChannelInfoList& operator = (const EventChannelInfoList& _s) {
        _CORBA_Unbounded_Sequence< EventChannelInfo > ::operator=(_s);
        return *this;
      }
    };

    class EventChannelInfoList_out;

    class EventChannelInfoList_var {
    public:
      inline EventChannelInfoList_var() : _pd_seq(0) {}
      inline EventChannelInfoList_var(EventChannelInfoList* _s) : _pd_seq(_s) {}
      inline EventChannelInfoList_var(const EventChannelInfoList_var& _s) {
        if (_s._pd_seq)  _pd_seq = new EventChannelInfoList(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~EventChannelInfoList_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline EventChannelInfoList_var& operator = (EventChannelInfoList* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline EventChannelInfoList_var& operator = (const EventChannelInfoList_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new EventChannelInfoList;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline EventChannelInfo& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline EventChannelInfoList* operator -> () { return _pd_seq; }
      inline const EventChannelInfoList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator EventChannelInfoList& () const { return *_pd_seq; }
#else
      inline operator const EventChannelInfoList& () const { return *_pd_seq; }
      inline operator EventChannelInfoList& () { return *_pd_seq; }
#endif
        
      inline const EventChannelInfoList& in() const { return *_pd_seq; }
      inline EventChannelInfoList&       inout()    { return *_pd_seq; }
      inline EventChannelInfoList*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline EventChannelInfoList* _retn() { EventChannelInfoList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class EventChannelInfoList_out;
      
    private:
      EventChannelInfoList* _pd_seq;
    };

    class EventChannelInfoList_out {
    public:
      inline EventChannelInfoList_out(EventChannelInfoList*& _s) : _data(_s) { _data = 0; }
      inline EventChannelInfoList_out(EventChannelInfoList_var& _s)
        : _data(_s._pd_seq) { _s = (EventChannelInfoList*) 0; }
      inline EventChannelInfoList_out(const EventChannelInfoList_out& _s) : _data(_s._data) {}
      inline EventChannelInfoList_out& operator = (const EventChannelInfoList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline EventChannelInfoList_out& operator = (EventChannelInfoList* _s) {
        _data = _s;
        return *this;
      }
      inline operator EventChannelInfoList*&()  { return _data; }
      inline EventChannelInfoList*& ptr()       { return _data; }
      inline EventChannelInfoList* operator->() { return _data; }

      inline EventChannelInfo& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      EventChannelInfoList*& _data;

    private:
      EventChannelInfoList_out();
      EventChannelInfoList_out& operator=(const EventChannelInfoList_var&);
    };

    struct EventRegistrant {
      typedef _CORBA_ConstrType_Variable_Var<EventRegistrant> _var_type;

      
      ::CORBA::String_member channel_name;

      ::CORBA::String_member reg_id;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef EventRegistrant::_var_type EventRegistrant_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< EventRegistrant,EventRegistrant_var > EventRegistrant_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventRegistrant;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventRegistrantList;

    class EventRegistrantList_var;

    class EventRegistrantList : public _CORBA_Unbounded_Sequence< EventRegistrant >  {
    public:
      typedef EventRegistrantList_var _var_type;
      inline EventRegistrantList() {}
      inline EventRegistrantList(const EventRegistrantList& _s)
        : _CORBA_Unbounded_Sequence< EventRegistrant > (_s) {}

      inline EventRegistrantList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< EventRegistrant > (_max) {}
      inline EventRegistrantList(_CORBA_ULong _max, _CORBA_ULong _len, EventRegistrant* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< EventRegistrant > (_max, _len, _val, _rel) {}

    

      inline EventRegistrantList& operator = (const EventRegistrantList& _s) {
        _CORBA_Unbounded_Sequence< EventRegistrant > ::operator=(_s);
        return *this;
      }
    };

    class EventRegistrantList_out;

    class EventRegistrantList_var {
    public:
      inline EventRegistrantList_var() : _pd_seq(0) {}
      inline EventRegistrantList_var(EventRegistrantList* _s) : _pd_seq(_s) {}
      inline EventRegistrantList_var(const EventRegistrantList_var& _s) {
        if (_s._pd_seq)  _pd_seq = new EventRegistrantList(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~EventRegistrantList_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline EventRegistrantList_var& operator = (EventRegistrantList* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline EventRegistrantList_var& operator = (const EventRegistrantList_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new EventRegistrantList;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline EventRegistrant& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline EventRegistrantList* operator -> () { return _pd_seq; }
      inline const EventRegistrantList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator EventRegistrantList& () const { return *_pd_seq; }
#else
      inline operator const EventRegistrantList& () const { return *_pd_seq; }
      inline operator EventRegistrantList& () { return *_pd_seq; }
#endif
        
      inline const EventRegistrantList& in() const { return *_pd_seq; }
      inline EventRegistrantList&       inout()    { return *_pd_seq; }
      inline EventRegistrantList*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline EventRegistrantList* _retn() { EventRegistrantList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class EventRegistrantList_out;
      
    private:
      EventRegistrantList* _pd_seq;
    };

    class EventRegistrantList_out {
    public:
      inline EventRegistrantList_out(EventRegistrantList*& _s) : _data(_s) { _data = 0; }
      inline EventRegistrantList_out(EventRegistrantList_var& _s)
        : _data(_s._pd_seq) { _s = (EventRegistrantList*) 0; }
      inline EventRegistrantList_out(const EventRegistrantList_out& _s) : _data(_s._data) {}
      inline EventRegistrantList_out& operator = (const EventRegistrantList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline EventRegistrantList_out& operator = (EventRegistrantList* _s) {
        _data = _s;
        return *this;
      }
      inline operator EventRegistrantList*&()  { return _data; }
      inline EventRegistrantList*& ptr()       { return _data; }
      inline EventRegistrantList* operator->() { return _data; }

      inline EventRegistrant& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      EventRegistrantList*& _data;

    private:
      EventRegistrantList_out();
      EventRegistrantList_out& operator=(const EventRegistrantList_var&);
    };

    struct EventRegistration {
      typedef _CORBA_ConstrType_Variable_Var<EventRegistration> _var_type;

      
      ::CORBA::String_member channel_name;

      ::CORBA::String_member reg_id;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef EventRegistration::_var_type EventRegistration_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< EventRegistration,EventRegistration_var > EventRegistration_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventRegistration;

    struct EventChannelReg {
      typedef _CORBA_ConstrType_Variable_Var<EventChannelReg> _var_type;

      
      EventRegistration reg;

      _CORBA_ObjRef_Member< CosEventChannelAdmin::_objref_EventChannel, CosEventChannelAdmin::EventChannel_Helper>  channel;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef EventChannelReg::_var_type EventChannelReg_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< EventChannelReg,EventChannelReg_var > EventChannelReg_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannelReg;

    struct PublisherReg {
      typedef _CORBA_ConstrType_Variable_Var<PublisherReg> _var_type;

      
      EventRegistration reg;

      _CORBA_ObjRef_Member< CosEventChannelAdmin::_objref_EventChannel, CosEventChannelAdmin::EventChannel_Helper>  channel;

      _CORBA_ObjRef_Member< CosEventChannelAdmin::_objref_ProxyPushConsumer, CosEventChannelAdmin::ProxyPushConsumer_Helper>  proxy_consumer;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef PublisherReg::_var_type PublisherReg_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< PublisherReg,PublisherReg_var > PublisherReg_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PublisherReg;

    class ChannelAlreadyExists : public ::CORBA::UserException {
    public:
      
      

      inline ChannelAlreadyExists() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ChannelAlreadyExists(const ChannelAlreadyExists&);
      
      ChannelAlreadyExists& operator=(const ChannelAlreadyExists&);
      virtual ~ChannelAlreadyExists();
      virtual void _raise() const;
      static ChannelAlreadyExists* _downcast(::CORBA::Exception*);
      static const ChannelAlreadyExists* _downcast(const ::CORBA::Exception*);
      static inline ChannelAlreadyExists* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ChannelAlreadyExists;

    class ChannelDoesNotExist : public ::CORBA::UserException {
    public:
      
      

      inline ChannelDoesNotExist() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ChannelDoesNotExist(const ChannelDoesNotExist&);
      
      ChannelDoesNotExist& operator=(const ChannelDoesNotExist&);
      virtual ~ChannelDoesNotExist();
      virtual void _raise() const;
      static ChannelDoesNotExist* _downcast(::CORBA::Exception*);
      static const ChannelDoesNotExist* _downcast(const ::CORBA::Exception*);
      static inline ChannelDoesNotExist* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ChannelDoesNotExist;

    class InvalidChannelName : public ::CORBA::UserException {
    public:
      
      

      inline InvalidChannelName() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidChannelName(const InvalidChannelName&);
      
      InvalidChannelName& operator=(const InvalidChannelName&);
      virtual ~InvalidChannelName();
      virtual void _raise() const;
      static InvalidChannelName* _downcast(::CORBA::Exception*);
      static const InvalidChannelName* _downcast(const ::CORBA::Exception*);
      static inline InvalidChannelName* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidChannelName;

    class OperationFailed : public ::CORBA::UserException {
    public:
      
      

      inline OperationFailed() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      OperationFailed(const OperationFailed&);
      
      OperationFailed& operator=(const OperationFailed&);
      virtual ~OperationFailed();
      virtual void _raise() const;
      static OperationFailed* _downcast(::CORBA::Exception*);
      static const OperationFailed* _downcast(const ::CORBA::Exception*);
      static inline OperationFailed* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationFailed;

    class OperationNotAllowed : public ::CORBA::UserException {
    public:
      
      

      inline OperationNotAllowed() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      OperationNotAllowed(const OperationNotAllowed&);
      
      OperationNotAllowed& operator=(const OperationNotAllowed&);
      virtual ~OperationNotAllowed();
      virtual void _raise() const;
      static OperationNotAllowed* _downcast(::CORBA::Exception*);
      static const OperationNotAllowed* _downcast(const ::CORBA::Exception*);
      static inline OperationNotAllowed* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationNotAllowed;

    class ServiceUnavailable : public ::CORBA::UserException {
    public:
      
      

      inline ServiceUnavailable() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ServiceUnavailable(const ServiceUnavailable&);
      
      ServiceUnavailable& operator=(const ServiceUnavailable&);
      virtual ~ServiceUnavailable();
      virtual void _raise() const;
      static ServiceUnavailable* _downcast(::CORBA::Exception*);
      static const ServiceUnavailable* _downcast(const ::CORBA::Exception*);
      static inline ServiceUnavailable* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ServiceUnavailable;

    class RegistrationsExists : public ::CORBA::UserException {
    public:
      
      

      inline RegistrationsExists() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      RegistrationsExists(const RegistrationsExists&);
      
      RegistrationsExists& operator=(const RegistrationsExists&);
      virtual ~RegistrationsExists();
      virtual void _raise() const;
      static RegistrationsExists* _downcast(::CORBA::Exception*);
      static const RegistrationsExists* _downcast(const ::CORBA::Exception*);
      static inline RegistrationsExists* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegistrationsExists;

    class RegistrationAlreadyExists : public ::CORBA::UserException {
    public:
      
      

      inline RegistrationAlreadyExists() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      RegistrationAlreadyExists(const RegistrationAlreadyExists&);
      
      RegistrationAlreadyExists& operator=(const RegistrationAlreadyExists&);
      virtual ~RegistrationAlreadyExists();
      virtual void _raise() const;
      static RegistrationAlreadyExists* _downcast(::CORBA::Exception*);
      static const RegistrationAlreadyExists* _downcast(const ::CORBA::Exception*);
      static inline RegistrationAlreadyExists* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegistrationAlreadyExists;

    class RegistrationDoesNotExist : public ::CORBA::UserException {
    public:
      
      

      inline RegistrationDoesNotExist() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      RegistrationDoesNotExist(const RegistrationDoesNotExist&);
      
      RegistrationDoesNotExist& operator=(const RegistrationDoesNotExist&);
      virtual ~RegistrationDoesNotExist();
      virtual void _raise() const;
      static RegistrationDoesNotExist* _downcast(::CORBA::Exception*);
      static const RegistrationDoesNotExist* _downcast(const ::CORBA::Exception*);
      static inline RegistrationDoesNotExist* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegistrationDoesNotExist;

  
  };

  class _objref_EventChannelManager :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    CosEventChannelAdmin::EventChannel_ptr create(const char* channel_name);
    CosEventChannelAdmin::EventChannel_ptr get(const char* channel_name);
    CosEventChannelAdmin::EventChannel_ptr createForRegistrations(const char* channel_name);
    void markForRegistrations(const char* channel_name);
    void release(const char* channel_name);
    void forceRelease(const char* channel_name);
    EventChannelManager::EventChannelReg* registerConsumer(::CosEventComm::PushConsumer_ptr consumer, const ::CF::EventChannelManager::EventRegistration& req);
    EventChannelManager::PublisherReg* registerPublisher(const ::CF::EventChannelManager::EventRegistration& req, ::CosEventComm::PushSupplier_ptr disconnectReceiver);
    EventChannelManager::EventChannelReg* registerResource(const ::CF::EventChannelManager::EventRegistration& req);
    void unregister(const ::CF::EventChannelManager::EventRegistration& reg);
    void listChannels(::CORBA::ULong how_many, ::CF::EventChannelManager::EventChannelInfoList_out elist, ::CF::EventChannelInfoIterator_out eiter);
    void listRegistrants(const char* channel_name, ::CORBA::ULong how_many, ::CF::EventChannelManager::EventRegistrantList_out rlist, ::CF::EventRegistrantIterator_out riter);

    // Constructors
    inline _objref_EventChannelManager()  { _PR_setobj(0); }  // nil
    _objref_EventChannelManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EventChannelManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EventChannelManager(const _objref_EventChannelManager&);
    _objref_EventChannelManager& operator = (const _objref_EventChannelManager&);
    // not implemented

    friend class EventChannelManager;
  };

  class _pof_EventChannelManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EventChannelManager() : _OMNI_NS(proxyObjectFactory)(EventChannelManager::_PD_repoId) {}
    virtual ~_pof_EventChannelManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EventChannelManager :
    public virtual omniServant
  {
  public:
    virtual ~_impl_EventChannelManager();

    virtual CosEventChannelAdmin::EventChannel_ptr create(const char* channel_name) = 0;
    virtual CosEventChannelAdmin::EventChannel_ptr get(const char* channel_name) = 0;
    virtual CosEventChannelAdmin::EventChannel_ptr createForRegistrations(const char* channel_name) = 0;
    virtual void markForRegistrations(const char* channel_name) = 0;
    virtual void release(const char* channel_name) = 0;
    virtual void forceRelease(const char* channel_name) = 0;
    virtual EventChannelManager::EventChannelReg* registerConsumer(::CosEventComm::PushConsumer_ptr consumer, const ::CF::EventChannelManager::EventRegistration& req) = 0;
    virtual EventChannelManager::PublisherReg* registerPublisher(const ::CF::EventChannelManager::EventRegistration& req, ::CosEventComm::PushSupplier_ptr disconnectReceiver) = 0;
    virtual EventChannelManager::EventChannelReg* registerResource(const ::CF::EventChannelManager::EventRegistration& req) = 0;
    virtual void unregister(const ::CF::EventChannelManager::EventRegistration& reg) = 0;
    virtual void listChannels(::CORBA::ULong how_many, ::CF::EventChannelManager::EventChannelInfoList_out elist, ::CF::EventChannelInfoIterator_out eiter) = 0;
    virtual void listRegistrants(const char* channel_name, ::CORBA::ULong how_many, ::CF::EventChannelManager::EventRegistrantList_out rlist, ::CF::EventRegistrantIterator_out riter) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannelManager;

#ifndef __CF_mEventChannelInfoIterator__
#define __CF_mEventChannelInfoIterator__
  class EventChannelInfoIterator;
  class _objref_EventChannelInfoIterator;
  class _impl_EventChannelInfoIterator;
  
  typedef _objref_EventChannelInfoIterator* EventChannelInfoIterator_ptr;
  typedef EventChannelInfoIterator_ptr EventChannelInfoIteratorRef;

  class EventChannelInfoIterator_Helper {
  public:
    typedef EventChannelInfoIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannelInfoIterator, EventChannelInfoIterator_Helper> EventChannelInfoIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannelInfoIterator,EventChannelInfoIterator_Helper > EventChannelInfoIterator_out;

#endif

  // interface EventChannelInfoIterator
  class EventChannelInfoIterator {
  public:
    // Declarations for this interface type.
    typedef EventChannelInfoIterator_ptr _ptr_type;
    typedef EventChannelInfoIterator_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_EventChannelInfoIterator :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Boolean next_one(::CF::EventChannelManager::EventChannelInfo_out eci);
    ::CORBA::Boolean next_n(::CORBA::ULong how_many, ::CF::EventChannelManager::EventChannelInfoList_out ecil);
    void destroy();

    // Constructors
    inline _objref_EventChannelInfoIterator()  { _PR_setobj(0); }  // nil
    _objref_EventChannelInfoIterator(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EventChannelInfoIterator();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EventChannelInfoIterator(const _objref_EventChannelInfoIterator&);
    _objref_EventChannelInfoIterator& operator = (const _objref_EventChannelInfoIterator&);
    // not implemented

    friend class EventChannelInfoIterator;
  };

  class _pof_EventChannelInfoIterator : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EventChannelInfoIterator() : _OMNI_NS(proxyObjectFactory)(EventChannelInfoIterator::_PD_repoId) {}
    virtual ~_pof_EventChannelInfoIterator();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EventChannelInfoIterator :
    public virtual omniServant
  {
  public:
    virtual ~_impl_EventChannelInfoIterator();

    virtual ::CORBA::Boolean next_one(::CF::EventChannelManager::EventChannelInfo_out eci) = 0;
    virtual ::CORBA::Boolean next_n(::CORBA::ULong how_many, ::CF::EventChannelManager::EventChannelInfoList_out ecil) = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannelInfoIterator;

#ifndef __CF_mEventRegistrantIterator__
#define __CF_mEventRegistrantIterator__
  class EventRegistrantIterator;
  class _objref_EventRegistrantIterator;
  class _impl_EventRegistrantIterator;
  
  typedef _objref_EventRegistrantIterator* EventRegistrantIterator_ptr;
  typedef EventRegistrantIterator_ptr EventRegistrantIteratorRef;

  class EventRegistrantIterator_Helper {
  public:
    typedef EventRegistrantIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventRegistrantIterator, EventRegistrantIterator_Helper> EventRegistrantIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventRegistrantIterator,EventRegistrantIterator_Helper > EventRegistrantIterator_out;

#endif

  // interface EventRegistrantIterator
  class EventRegistrantIterator {
  public:
    // Declarations for this interface type.
    typedef EventRegistrantIterator_ptr _ptr_type;
    typedef EventRegistrantIterator_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_EventRegistrantIterator :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Boolean next_one(::CF::EventChannelManager::EventRegistrant_out er);
    ::CORBA::Boolean next_n(::CORBA::ULong how_many, ::CF::EventChannelManager::EventRegistrantList_out erl);
    void destroy();

    // Constructors
    inline _objref_EventRegistrantIterator()  { _PR_setobj(0); }  // nil
    _objref_EventRegistrantIterator(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EventRegistrantIterator();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EventRegistrantIterator(const _objref_EventRegistrantIterator&);
    _objref_EventRegistrantIterator& operator = (const _objref_EventRegistrantIterator&);
    // not implemented

    friend class EventRegistrantIterator;
  };

  class _pof_EventRegistrantIterator : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EventRegistrantIterator() : _OMNI_NS(proxyObjectFactory)(EventRegistrantIterator::_PD_repoId) {}
    virtual ~_pof_EventRegistrantIterator();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EventRegistrantIterator :
    public virtual omniServant
  {
  public:
    virtual ~_impl_EventRegistrantIterator();

    virtual ::CORBA::Boolean next_one(::CF::EventChannelManager::EventRegistrant_out er) = 0;
    virtual ::CORBA::Boolean next_n(::CORBA::ULong how_many, ::CF::EventChannelManager::EventRegistrantList_out erl) = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventRegistrantIterator;

_CORBA_MODULE_END



_CORBA_MODULE POA_CF
_CORBA_MODULE_BEG

  class EventChannelManager :
    public virtual CF::_impl_EventChannelManager,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~EventChannelManager();

    inline ::CF::EventChannelManager_ptr _this() {
      return (::CF::EventChannelManager_ptr) _do_this(::CF::EventChannelManager::_PD_repoId);
    }
  };

  class EventChannelInfoIterator :
    public virtual CF::_impl_EventChannelInfoIterator,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~EventChannelInfoIterator();

    inline ::CF::EventChannelInfoIterator_ptr _this() {
      return (::CF::EventChannelInfoIterator_ptr) _do_this(::CF::EventChannelInfoIterator::_PD_repoId);
    }
  };

  class EventRegistrantIterator :
    public virtual CF::_impl_EventRegistrantIterator,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~EventRegistrantIterator();

    inline ::CF::EventRegistrantIterator_ptr _this() {
      return (::CF::EventRegistrantIterator_ptr) _do_this(::CF::EventRegistrantIterator::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::EventChannelInfo& _s);
extern void operator<<=(::CORBA::Any& _a, CF::EventChannelManager::EventChannelInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager::EventChannelInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::EventChannelInfo*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::EventChannelInfoList& _s);
void operator<<=(::CORBA::Any& _a, CF::EventChannelManager::EventChannelInfoList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager::EventChannelInfoList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::EventChannelInfoList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::EventRegistrant& _s);
extern void operator<<=(::CORBA::Any& _a, CF::EventChannelManager::EventRegistrant* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager::EventRegistrant*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::EventRegistrant*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::EventRegistrantList& _s);
void operator<<=(::CORBA::Any& _a, CF::EventChannelManager::EventRegistrantList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager::EventRegistrantList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::EventRegistrantList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::EventRegistration& _s);
extern void operator<<=(::CORBA::Any& _a, CF::EventChannelManager::EventRegistration* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager::EventRegistration*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::EventRegistration*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::EventChannelReg& _s);
extern void operator<<=(::CORBA::Any& _a, CF::EventChannelManager::EventChannelReg* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager::EventChannelReg*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::EventChannelReg*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::PublisherReg& _s);
extern void operator<<=(::CORBA::Any& _a, CF::EventChannelManager::PublisherReg* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager::PublisherReg*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::PublisherReg*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::ChannelAlreadyExists& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::ChannelAlreadyExists* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::ChannelAlreadyExists*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::ChannelDoesNotExist& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::ChannelDoesNotExist* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::ChannelDoesNotExist*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::InvalidChannelName& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::InvalidChannelName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::InvalidChannelName*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::OperationFailed& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::OperationFailed* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::OperationFailed*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::OperationNotAllowed& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::OperationNotAllowed* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::OperationNotAllowed*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::ServiceUnavailable& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::ServiceUnavailable* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::ServiceUnavailable*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::RegistrationsExists& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::RegistrationsExists* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::RegistrationsExists*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::RegistrationAlreadyExists& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::RegistrationAlreadyExists* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::RegistrationAlreadyExists*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::RegistrationDoesNotExist& _s);
void operator<<=(::CORBA::Any& _a, const CF::EventChannelManager::RegistrationDoesNotExist* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::EventChannelManager::RegistrationDoesNotExist*& _sp);

void operator<<=(::CORBA::Any& _a, CF::EventChannelManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::EventChannelManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::EventChannelInfoIterator_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::EventChannelInfoIterator_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventChannelInfoIterator_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::EventRegistrantIterator_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::EventRegistrantIterator_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::EventRegistrantIterator_ptr& _s);



inline void
CF::EventChannelManager::_marshalObjRef(::CF::EventChannelManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::EventChannelInfoIterator::_marshalObjRef(::CF::EventChannelInfoIterator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::EventRegistrantIterator::_marshalObjRef(::CF::EventRegistrantIterator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_EventChannelManager
#endif

#endif  // __EventChannelManager_hh__


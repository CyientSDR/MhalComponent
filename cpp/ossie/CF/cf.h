// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __cf_hh__
#define __cf_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_cf
#endif



#ifndef __CosNaming_hh_EXTERNAL_GUARD__
#define __CosNaming_hh_EXTERNAL_GUARD__
#include <COS/CosNaming.hh>
#endif
#ifndef __DataType_hh_EXTERNAL_GUARD__
#define __DataType_hh_EXTERNAL_GUARD__
#include <ossie/CF/DataType.h>
#endif
#ifndef __Port_hh_EXTERNAL_GUARD__
#define __Port_hh_EXTERNAL_GUARD__
#include <ossie/CF/Port.h>
#endif
#ifndef __LogInterfaces_hh_EXTERNAL_GUARD__
#define __LogInterfaces_hh_EXTERNAL_GUARD__
#include <ossie/CF/LogInterfaces.h>
#endif
#ifndef __CosEventComm_hh_EXTERNAL_GUARD__
#define __CosEventComm_hh_EXTERNAL_GUARD__
#include <COS/CosEventComm.hh>
#endif
#ifndef __CosEventChannelAdmin_hh_EXTERNAL_GUARD__
#define __CosEventChannelAdmin_hh_EXTERNAL_GUARD__
#include <COS/CosEventChannelAdmin.hh>
#endif
#ifndef __EventChannelManager_hh_EXTERNAL_GUARD__
#define __EventChannelManager_hh_EXTERNAL_GUARD__
#include <ossie/CF/EventChannelManager.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CF

_CORBA_MODULE_BEG

#ifndef __CF_mDevice__
#define __CF_mDevice__
  class Device;
  class _objref_Device;
  class _impl_Device;
  
  typedef _objref_Device* Device_ptr;
  typedef Device_ptr DeviceRef;

  class Device_Helper {
  public:
    typedef Device_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Device, Device_Helper> Device_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Device,Device_Helper > Device_out;

#endif

#ifndef __CF_mFile__
#define __CF_mFile__
  class File;
  class _objref_File;
  class _impl_File;
  
  typedef _objref_File* File_ptr;
  typedef File_ptr FileRef;

  class File_Helper {
  public:
    typedef File_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_File, File_Helper> File_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_File,File_Helper > File_out;

#endif

#ifndef __CF_mResource__
#define __CF_mResource__
  class Resource;
  class _objref_Resource;
  class _impl_Resource;
  
  typedef _objref_Resource* Resource_ptr;
  typedef Resource_ptr ResourceRef;

  class Resource_Helper {
  public:
    typedef Resource_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Resource, Resource_Helper> Resource_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Resource,Resource_Helper > Resource_out;

#endif

#ifndef __CF_mApplication__
#define __CF_mApplication__
  class Application;
  class _objref_Application;
  class _impl_Application;
  
  typedef _objref_Application* Application_ptr;
  typedef Application_ptr ApplicationRef;

  class Application_Helper {
  public:
    typedef Application_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Application, Application_Helper> Application_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Application,Application_Helper > Application_out;

#endif

#ifndef __CF_mApplicationFactory__
#define __CF_mApplicationFactory__
  class ApplicationFactory;
  class _objref_ApplicationFactory;
  class _impl_ApplicationFactory;
  
  typedef _objref_ApplicationFactory* ApplicationFactory_ptr;
  typedef ApplicationFactory_ptr ApplicationFactoryRef;

  class ApplicationFactory_Helper {
  public:
    typedef ApplicationFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ApplicationFactory, ApplicationFactory_Helper> ApplicationFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ApplicationFactory,ApplicationFactory_Helper > ApplicationFactory_out;

#endif

#ifndef __CF_mDeviceManager__
#define __CF_mDeviceManager__
  class DeviceManager;
  class _objref_DeviceManager;
  class _impl_DeviceManager;
  
  typedef _objref_DeviceManager* DeviceManager_ptr;
  typedef DeviceManager_ptr DeviceManagerRef;

  class DeviceManager_Helper {
  public:
    typedef DeviceManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceManager, DeviceManager_Helper> DeviceManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceManager,DeviceManager_Helper > DeviceManager_out;

#endif

#ifndef __CF_mDomainManager__
#define __CF_mDomainManager__
  class DomainManager;
  class _objref_DomainManager;
  class _impl_DomainManager;
  
  typedef _objref_DomainManager* DomainManager_ptr;
  typedef DomainManager_ptr DomainManagerRef;

  class DomainManager_Helper {
  public:
    typedef DomainManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DomainManager, DomainManager_Helper> DomainManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DomainManager,DomainManager_Helper > DomainManager_out;

#endif

#ifndef __CF_mAllocationManager__
#define __CF_mAllocationManager__
  class AllocationManager;
  class _objref_AllocationManager;
  class _impl_AllocationManager;
  
  typedef _objref_AllocationManager* AllocationManager_ptr;
  typedef AllocationManager_ptr AllocationManagerRef;

  class AllocationManager_Helper {
  public:
    typedef AllocationManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_AllocationManager, AllocationManager_Helper> AllocationManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_AllocationManager,AllocationManager_Helper > AllocationManager_out;

#endif

#ifndef __CF_mPort__
#define __CF_mPort__
  class Port;
  class _objref_Port;
  class _impl_Port;
  
  typedef _objref_Port* Port_ptr;
  typedef Port_ptr PortRef;

  class Port_Helper {
  public:
    typedef Port_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Port, Port_Helper> Port_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Port,Port_Helper > Port_out;

#endif

  class InvalidProfile : public ::CORBA::UserException {
  public:
    
    

    inline InvalidProfile() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidProfile(const InvalidProfile&);
    
    InvalidProfile& operator=(const InvalidProfile&);
    virtual ~InvalidProfile();
    virtual void _raise() const;
    static InvalidProfile* _downcast(::CORBA::Exception*);
    static const InvalidProfile* _downcast(const ::CORBA::Exception*);
    static inline InvalidProfile* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidProfile;

  class InvalidObjectReference : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member msg;

  

    inline InvalidObjectReference() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidObjectReference(const InvalidObjectReference&);
    InvalidObjectReference(const char* i_msg);
    InvalidObjectReference& operator=(const InvalidObjectReference&);
    virtual ~InvalidObjectReference();
    virtual void _raise() const;
    static InvalidObjectReference* _downcast(::CORBA::Exception*);
    static const InvalidObjectReference* _downcast(const ::CORBA::Exception*);
    static inline InvalidObjectReference* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidObjectReference;

  class DuplicateName : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member msg;

  

    inline DuplicateName() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    DuplicateName(const DuplicateName&);
    DuplicateName(const char* i_msg);
    DuplicateName& operator=(const DuplicateName&);
    virtual ~DuplicateName();
    virtual void _raise() const;
    static DuplicateName* _downcast(::CORBA::Exception*);
    static const DuplicateName* _downcast(const ::CORBA::Exception*);
    static inline DuplicateName* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DuplicateName;

  class InvalidIdentifier : public ::CORBA::UserException {
  public:
    
    

    inline InvalidIdentifier() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidIdentifier(const InvalidIdentifier&);
    
    InvalidIdentifier& operator=(const InvalidIdentifier&);
    virtual ~InvalidIdentifier();
    virtual void _raise() const;
    static InvalidIdentifier* _downcast(::CORBA::Exception*);
    static const InvalidIdentifier* _downcast(const ::CORBA::Exception*);
    static inline InvalidIdentifier* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidIdentifier;

  class UnallowedAccess : public ::CORBA::UserException {
  public:
    
    

    inline UnallowedAccess() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnallowedAccess(const UnallowedAccess&);
    
    UnallowedAccess& operator=(const UnallowedAccess&);
    virtual ~UnallowedAccess();
    virtual void _raise() const;
    static UnallowedAccess* _downcast(::CORBA::Exception*);
    static const UnallowedAccess* _downcast(const ::CORBA::Exception*);
    static inline UnallowedAccess* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnallowedAccess;

  struct FailedCapacityType {
    typedef _CORBA_ConstrType_Variable_Var<FailedCapacityType> _var_type;

    
    ::CORBA::String_member deviceId;

    Properties insufficientCapacities;

    ::CORBA::String_member insufficientCapacityMessage;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FailedCapacityType::_var_type FailedCapacityType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FailedCapacityType,FailedCapacityType_var > FailedCapacityType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FailedCapacityType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FailedCapacities;

  class FailedCapacities_var;

  class FailedCapacities : public _CORBA_Unbounded_Sequence< FailedCapacityType >  {
  public:
    typedef FailedCapacities_var _var_type;
    inline FailedCapacities() {}
    inline FailedCapacities(const FailedCapacities& _s)
      : _CORBA_Unbounded_Sequence< FailedCapacityType > (_s) {}

    inline FailedCapacities(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< FailedCapacityType > (_max) {}
    inline FailedCapacities(_CORBA_ULong _max, _CORBA_ULong _len, FailedCapacityType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< FailedCapacityType > (_max, _len, _val, _rel) {}

  

    inline FailedCapacities& operator = (const FailedCapacities& _s) {
      _CORBA_Unbounded_Sequence< FailedCapacityType > ::operator=(_s);
      return *this;
    }
  };

  class FailedCapacities_out;

  class FailedCapacities_var {
  public:
    inline FailedCapacities_var() : _pd_seq(0) {}
    inline FailedCapacities_var(FailedCapacities* _s) : _pd_seq(_s) {}
    inline FailedCapacities_var(const FailedCapacities_var& _s) {
      if (_s._pd_seq)  _pd_seq = new FailedCapacities(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~FailedCapacities_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline FailedCapacities_var& operator = (FailedCapacities* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FailedCapacities_var& operator = (const FailedCapacities_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new FailedCapacities;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline FailedCapacityType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FailedCapacities* operator -> () { return _pd_seq; }
    inline const FailedCapacities* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FailedCapacities& () const { return *_pd_seq; }
#else
    inline operator const FailedCapacities& () const { return *_pd_seq; }
    inline operator FailedCapacities& () { return *_pd_seq; }
#endif
      
    inline const FailedCapacities& in() const { return *_pd_seq; }
    inline FailedCapacities&       inout()    { return *_pd_seq; }
    inline FailedCapacities*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FailedCapacities* _retn() { FailedCapacities* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FailedCapacities_out;
    
  private:
    FailedCapacities* _pd_seq;
  };

  class FailedCapacities_out {
  public:
    inline FailedCapacities_out(FailedCapacities*& _s) : _data(_s) { _data = 0; }
    inline FailedCapacities_out(FailedCapacities_var& _s)
      : _data(_s._pd_seq) { _s = (FailedCapacities*) 0; }
    inline FailedCapacities_out(const FailedCapacities_out& _s) : _data(_s._data) {}
    inline FailedCapacities_out& operator = (const FailedCapacities_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FailedCapacities_out& operator = (FailedCapacities* _s) {
      _data = _s;
      return *this;
    }
    inline operator FailedCapacities*&()  { return _data; }
    inline FailedCapacities*& ptr()       { return _data; }
    inline FailedCapacities* operator->() { return _data; }

    inline FailedCapacityType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FailedCapacities*& _data;

  private:
    FailedCapacities_out();
    FailedCapacities_out& operator=(const FailedCapacities_var&);
  };

  class UnknownProperties : public ::CORBA::UserException {
  public:
    
    Properties invalidProperties;

  

    inline UnknownProperties() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnknownProperties(const UnknownProperties&);
    UnknownProperties(const Properties i_invalidProperties);
    UnknownProperties& operator=(const UnknownProperties&);
    virtual ~UnknownProperties();
    virtual void _raise() const;
    static UnknownProperties* _downcast(::CORBA::Exception*);
    static const UnknownProperties* _downcast(const ::CORBA::Exception*);
    static inline UnknownProperties* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownProperties;

  struct DeviceAssignmentType {
    typedef _CORBA_ConstrType_Variable_Var<DeviceAssignmentType> _var_type;

    
    ::CORBA::String_member componentId;

    ::CORBA::String_member assignedDeviceId;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DeviceAssignmentType::_var_type DeviceAssignmentType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< DeviceAssignmentType,DeviceAssignmentType_var > DeviceAssignmentType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceAssignmentType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceAssignmentSequence;

  class DeviceAssignmentSequence_var;

  class DeviceAssignmentSequence : public _CORBA_Unbounded_Sequence< DeviceAssignmentType >  {
  public:
    typedef DeviceAssignmentSequence_var _var_type;
    inline DeviceAssignmentSequence() {}
    inline DeviceAssignmentSequence(const DeviceAssignmentSequence& _s)
      : _CORBA_Unbounded_Sequence< DeviceAssignmentType > (_s) {}

    inline DeviceAssignmentSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< DeviceAssignmentType > (_max) {}
    inline DeviceAssignmentSequence(_CORBA_ULong _max, _CORBA_ULong _len, DeviceAssignmentType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< DeviceAssignmentType > (_max, _len, _val, _rel) {}

  

    inline DeviceAssignmentSequence& operator = (const DeviceAssignmentSequence& _s) {
      _CORBA_Unbounded_Sequence< DeviceAssignmentType > ::operator=(_s);
      return *this;
    }
  };

  class DeviceAssignmentSequence_out;

  class DeviceAssignmentSequence_var {
  public:
    inline DeviceAssignmentSequence_var() : _pd_seq(0) {}
    inline DeviceAssignmentSequence_var(DeviceAssignmentSequence* _s) : _pd_seq(_s) {}
    inline DeviceAssignmentSequence_var(const DeviceAssignmentSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DeviceAssignmentSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DeviceAssignmentSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DeviceAssignmentSequence_var& operator = (DeviceAssignmentSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DeviceAssignmentSequence_var& operator = (const DeviceAssignmentSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new DeviceAssignmentSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline DeviceAssignmentType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DeviceAssignmentSequence* operator -> () { return _pd_seq; }
    inline const DeviceAssignmentSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DeviceAssignmentSequence& () const { return *_pd_seq; }
#else
    inline operator const DeviceAssignmentSequence& () const { return *_pd_seq; }
    inline operator DeviceAssignmentSequence& () { return *_pd_seq; }
#endif
      
    inline const DeviceAssignmentSequence& in() const { return *_pd_seq; }
    inline DeviceAssignmentSequence&       inout()    { return *_pd_seq; }
    inline DeviceAssignmentSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DeviceAssignmentSequence* _retn() { DeviceAssignmentSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DeviceAssignmentSequence_out;
    
  private:
    DeviceAssignmentSequence* _pd_seq;
  };

  class DeviceAssignmentSequence_out {
  public:
    inline DeviceAssignmentSequence_out(DeviceAssignmentSequence*& _s) : _data(_s) { _data = 0; }
    inline DeviceAssignmentSequence_out(DeviceAssignmentSequence_var& _s)
      : _data(_s._pd_seq) { _s = (DeviceAssignmentSequence*) 0; }
    inline DeviceAssignmentSequence_out(const DeviceAssignmentSequence_out& _s) : _data(_s._data) {}
    inline DeviceAssignmentSequence_out& operator = (const DeviceAssignmentSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DeviceAssignmentSequence_out& operator = (DeviceAssignmentSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator DeviceAssignmentSequence*&()  { return _data; }
    inline DeviceAssignmentSequence*& ptr()       { return _data; }
    inline DeviceAssignmentSequence* operator->() { return _data; }

    inline DeviceAssignmentType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DeviceAssignmentSequence*& _data;

  private:
    DeviceAssignmentSequence_out();
    DeviceAssignmentSequence_out& operator=(const DeviceAssignmentSequence_var&);
  };

  enum ErrorNumberType { CF_NOTSET, CF_E2BIG, CF_EACCES, CF_EAGAIN, CF_EBADF, CF_EBADMSG, CF_EBUSY, CF_ECANCELED, CF_ECHILD, CF_EDEADLK, CF_EDOM, CF_EEXIST, CF_EFAULT, CF_EFBIG, CF_EINPROGRESS, CF_EINTR, CF_EINVAL, CF_EIO, CF_EISDIR, CF_EMFILE, CF_EMLINK, CF_EMSGSIZE, CF_ENAMETOOLONG, CF_ENFILE, CF_ENODEV, CF_ENOENT, CF_ENOEXEC, CF_ENOLCK, CF_ENOMEM, CF_ENOSPC, CF_ENOSYS, CF_ENOTDIR, CF_ENOTEMPTY, CF_ENOTSUP, CF_ENOTTY, CF_ENXIO, CF_EPERM, CF_EPIPE, CF_ERANGE, CF_EROFS, CF_ESPIPE, CF_ESRCH, CF_ETIMEDOUT, CF_EXDEV /*, __max_ErrorNumberType=0xffffffff */ };
  typedef ErrorNumberType& ErrorNumberType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ErrorNumberType;

  struct PortType {
    typedef _CORBA_ConstrType_Variable_Var<PortType> _var_type;

    
    ::CORBA::String_member portName;

    ::CORBA::Object_Member port;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PortType::_var_type PortType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PortType,PortType_var > PortType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Ports;

  class Ports_var;

  class Ports : public _CORBA_Unbounded_Sequence< PortType >  {
  public:
    typedef Ports_var _var_type;
    inline Ports() {}
    inline Ports(const Ports& _s)
      : _CORBA_Unbounded_Sequence< PortType > (_s) {}

    inline Ports(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PortType > (_max) {}
    inline Ports(_CORBA_ULong _max, _CORBA_ULong _len, PortType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PortType > (_max, _len, _val, _rel) {}

  

    inline Ports& operator = (const Ports& _s) {
      _CORBA_Unbounded_Sequence< PortType > ::operator=(_s);
      return *this;
    }
  };

  class Ports_out;

  class Ports_var {
  public:
    inline Ports_var() : _pd_seq(0) {}
    inline Ports_var(Ports* _s) : _pd_seq(_s) {}
    inline Ports_var(const Ports_var& _s) {
      if (_s._pd_seq)  _pd_seq = new Ports(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~Ports_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline Ports_var& operator = (Ports* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Ports_var& operator = (const Ports_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new Ports;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline PortType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Ports* operator -> () { return _pd_seq; }
    inline const Ports* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Ports& () const { return *_pd_seq; }
#else
    inline operator const Ports& () const { return *_pd_seq; }
    inline operator Ports& () { return *_pd_seq; }
#endif
      
    inline const Ports& in() const { return *_pd_seq; }
    inline Ports&       inout()    { return *_pd_seq; }
    inline Ports*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Ports* _retn() { Ports* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Ports_out;
    
  private:
    Ports* _pd_seq;
  };

  class Ports_out {
  public:
    inline Ports_out(Ports*& _s) : _data(_s) { _data = 0; }
    inline Ports_out(Ports_var& _s)
      : _data(_s._pd_seq) { _s = (Ports*) 0; }
    inline Ports_out(const Ports_out& _s) : _data(_s._data) {}
    inline Ports_out& operator = (const Ports_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Ports_out& operator = (Ports* _s) {
      _data = _s;
      return *this;
    }
    inline operator Ports*&()  { return _data; }
    inline Ports*& ptr()       { return _data; }
    inline Ports* operator->() { return _data; }

    inline PortType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Ports*& _data;

  private:
    Ports_out();
    Ports_out& operator=(const Ports_var&);
  };

  enum ComponentEnumType { APPLICATION_COMPONENT, DEVICE_COMPONENT, CF_SERVICE_COMPONENT, NON_CF_SERVICE_COMPONENT, FRAMEWORK_COMPONENT /*, __max_ComponentEnumType=0xffffffff */ };
  typedef ComponentEnumType& ComponentEnumType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentEnumType;

  struct ComponentType {
    typedef _CORBA_ConstrType_Variable_Var<ComponentType> _var_type;

    
    ::CORBA::String_member identifier;

    ::CORBA::String_member softwareProfile;

    ComponentEnumType type;

    ::CORBA::Object_Member componentObject;

    Ports providesPorts;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ComponentType::_var_type ComponentType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentType,ComponentType_var > ComponentType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Components;

  class Components_var;

  class Components : public _CORBA_Unbounded_Sequence< ComponentType >  {
  public:
    typedef Components_var _var_type;
    inline Components() {}
    inline Components(const Components& _s)
      : _CORBA_Unbounded_Sequence< ComponentType > (_s) {}

    inline Components(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ComponentType > (_max) {}
    inline Components(_CORBA_ULong _max, _CORBA_ULong _len, ComponentType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ComponentType > (_max, _len, _val, _rel) {}

  

    inline Components& operator = (const Components& _s) {
      _CORBA_Unbounded_Sequence< ComponentType > ::operator=(_s);
      return *this;
    }
  };

  class Components_out;

  class Components_var {
  public:
    inline Components_var() : _pd_seq(0) {}
    inline Components_var(Components* _s) : _pd_seq(_s) {}
    inline Components_var(const Components_var& _s) {
      if (_s._pd_seq)  _pd_seq = new Components(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~Components_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline Components_var& operator = (Components* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Components_var& operator = (const Components_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new Components;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ComponentType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Components* operator -> () { return _pd_seq; }
    inline const Components* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Components& () const { return *_pd_seq; }
#else
    inline operator const Components& () const { return *_pd_seq; }
    inline operator Components& () { return *_pd_seq; }
#endif
      
    inline const Components& in() const { return *_pd_seq; }
    inline Components&       inout()    { return *_pd_seq; }
    inline Components*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Components* _retn() { Components* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Components_out;
    
  private:
    Components* _pd_seq;
  };

  class Components_out {
  public:
    inline Components_out(Components*& _s) : _data(_s) { _data = 0; }
    inline Components_out(Components_var& _s)
      : _data(_s._pd_seq) { _s = (Components*) 0; }
    inline Components_out(const Components_out& _s) : _data(_s._data) {}
    inline Components_out& operator = (const Components_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Components_out& operator = (Components* _s) {
      _data = _s;
      return *this;
    }
    inline operator Components*&()  { return _data; }
    inline Components*& ptr()       { return _data; }
    inline Components* operator->() { return _data; }

    inline ComponentType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Components*& _data;

  private:
    Components_out();
    Components_out& operator=(const Components_var&);
  };

  class InvalidFileName : public ::CORBA::UserException {
  public:
    
    ErrorNumberType errorNumber;

    ::CORBA::String_member msg;

  

    inline InvalidFileName() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidFileName(const InvalidFileName&);
    InvalidFileName(ErrorNumberType i_errorNumber, const char* i_msg);
    InvalidFileName& operator=(const InvalidFileName&);
    virtual ~InvalidFileName();
    virtual void _raise() const;
    static InvalidFileName* _downcast(::CORBA::Exception*);
    static const InvalidFileName* _downcast(const ::CORBA::Exception*);
    static inline InvalidFileName* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFileName;

  class FileException : public ::CORBA::UserException {
  public:
    
    ErrorNumberType errorNumber;

    ::CORBA::String_member msg;

  

    inline FileException() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    FileException(const FileException&);
    FileException(ErrorNumberType i_errorNumber, const char* i_msg);
    FileException& operator=(const FileException&);
    virtual ~FileException();
    virtual void _raise() const;
    static FileException* _downcast(::CORBA::Exception*);
    static const FileException* _downcast(const ::CORBA::Exception*);
    static inline FileException* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileException;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceSequence;

  class DeviceSequence_var;

  class DeviceSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper >  {
  public:
    typedef DeviceSequence_var _var_type;
    inline DeviceSequence() {}
    inline DeviceSequence(const DeviceSequence& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > (_s) {}

    inline DeviceSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > (_max) {}
    inline DeviceSequence(_CORBA_ULong _max, _CORBA_ULong _len, Device_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > (_max, _len, _val, _rel) {}

  

    inline DeviceSequence& operator = (const DeviceSequence& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > ::operator=(_s);
      return *this;
    }
  };

  class DeviceSequence_out;

  class DeviceSequence_var {
  public:
    inline DeviceSequence_var() : _pd_seq(0) {}
    inline DeviceSequence_var(DeviceSequence* _s) : _pd_seq(_s) {}
    inline DeviceSequence_var(const DeviceSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DeviceSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DeviceSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DeviceSequence_var& operator = (DeviceSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DeviceSequence_var& operator = (const DeviceSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new DeviceSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_Device, Device_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DeviceSequence* operator -> () { return _pd_seq; }
    inline const DeviceSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DeviceSequence& () const { return *_pd_seq; }
#else
    inline operator const DeviceSequence& () const { return *_pd_seq; }
    inline operator DeviceSequence& () { return *_pd_seq; }
#endif
      
    inline const DeviceSequence& in() const { return *_pd_seq; }
    inline DeviceSequence&       inout()    { return *_pd_seq; }
    inline DeviceSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DeviceSequence* _retn() { DeviceSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DeviceSequence_out;
    
  private:
    DeviceSequence* _pd_seq;
  };

  class DeviceSequence_out {
  public:
    inline DeviceSequence_out(DeviceSequence*& _s) : _data(_s) { _data = 0; }
    inline DeviceSequence_out(DeviceSequence_var& _s)
      : _data(_s._pd_seq) { _s = (DeviceSequence*) 0; }
    inline DeviceSequence_out(const DeviceSequence_out& _s) : _data(_s._data) {}
    inline DeviceSequence_out& operator = (const DeviceSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DeviceSequence_out& operator = (DeviceSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator DeviceSequence*&()  { return _data; }
    inline DeviceSequence*& ptr()       { return _data; }
    inline DeviceSequence* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_Device, Device_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DeviceSequence*& _data;

  private:
    DeviceSequence_out();
    DeviceSequence_out& operator=(const DeviceSequence_var&);
  };

#ifndef __CF_mAggregateDevice__
#define __CF_mAggregateDevice__
  class AggregateDevice;
  class _objref_AggregateDevice;
  class _impl_AggregateDevice;
  
  typedef _objref_AggregateDevice* AggregateDevice_ptr;
  typedef AggregateDevice_ptr AggregateDeviceRef;

  class AggregateDevice_Helper {
  public:
    typedef AggregateDevice_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_AggregateDevice, AggregateDevice_Helper> AggregateDevice_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_AggregateDevice,AggregateDevice_Helper > AggregateDevice_out;

#endif

  // interface AggregateDevice
  class AggregateDevice {
  public:
    // Declarations for this interface type.
    typedef AggregateDevice_ptr _ptr_type;
    typedef AggregateDevice_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_AggregateDevice :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    DeviceSequence* devices();
    void addDevice(::CF::Device_ptr associatedDevice);
    void removeDevice(::CF::Device_ptr associatedDevice);

    // Constructors
    inline _objref_AggregateDevice()  { _PR_setobj(0); }  // nil
    _objref_AggregateDevice(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_AggregateDevice();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_AggregateDevice(const _objref_AggregateDevice&);
    _objref_AggregateDevice& operator = (const _objref_AggregateDevice&);
    // not implemented

    friend class AggregateDevice;
  };

  class _pof_AggregateDevice : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_AggregateDevice() : _OMNI_NS(proxyObjectFactory)(AggregateDevice::_PD_repoId) {}
    virtual ~_pof_AggregateDevice();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_AggregateDevice :
    public virtual omniServant
  {
  public:
    virtual ~_impl_AggregateDevice();

    virtual DeviceSequence* devices() = 0;
    virtual void addDevice(::CF::Device_ptr associatedDevice) = 0;
    virtual void removeDevice(::CF::Device_ptr associatedDevice) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AggregateDevice;

#ifndef __CF_mFileSystem__
#define __CF_mFileSystem__
  class FileSystem;
  class _objref_FileSystem;
  class _impl_FileSystem;
  
  typedef _objref_FileSystem* FileSystem_ptr;
  typedef FileSystem_ptr FileSystemRef;

  class FileSystem_Helper {
  public:
    typedef FileSystem_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FileSystem, FileSystem_Helper> FileSystem_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FileSystem,FileSystem_Helper > FileSystem_out;

#endif

  // interface FileSystem
  class FileSystem {
  public:
    // Declarations for this interface type.
    typedef FileSystem_ptr _ptr_type;
    typedef FileSystem_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class UnknownFileSystemProperties : public ::CORBA::UserException {
    public:
      
      Properties invalidProperties;

    

      inline UnknownFileSystemProperties() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnknownFileSystemProperties(const UnknownFileSystemProperties&);
      UnknownFileSystemProperties(const Properties i_invalidProperties);
      UnknownFileSystemProperties& operator=(const UnknownFileSystemProperties&);
      virtual ~UnknownFileSystemProperties();
      virtual void _raise() const;
      static UnknownFileSystemProperties* _downcast(::CORBA::Exception*);
      static const UnknownFileSystemProperties* _downcast(const ::CORBA::Exception*);
      static inline UnknownFileSystemProperties* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownFileSystemProperties;

    static _core_attr const char * SIZE;

    static _core_attr const char * AVAILABLE_SPACE;

    enum FileType { PLAIN, DIRECTORY, FILE_SYSTEM /*, __max_FileType=0xffffffff */ };
    typedef FileType& FileType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileType;

    struct FileInformationType {
      typedef _CORBA_ConstrType_Variable_Var<FileInformationType> _var_type;

      
      ::CORBA::String_member name;

      FileType kind;

      ::CORBA::ULongLong size;

      Properties fileProperties;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef FileInformationType::_var_type FileInformationType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< FileInformationType,FileInformationType_var > FileInformationType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileInformationType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileInformationSequence;

    class FileInformationSequence_var;

    class FileInformationSequence : public _CORBA_Unbounded_Sequence< FileInformationType >  {
    public:
      typedef FileInformationSequence_var _var_type;
      inline FileInformationSequence() {}
      inline FileInformationSequence(const FileInformationSequence& _s)
        : _CORBA_Unbounded_Sequence< FileInformationType > (_s) {}

      inline FileInformationSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< FileInformationType > (_max) {}
      inline FileInformationSequence(_CORBA_ULong _max, _CORBA_ULong _len, FileInformationType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< FileInformationType > (_max, _len, _val, _rel) {}

    

      inline FileInformationSequence& operator = (const FileInformationSequence& _s) {
        _CORBA_Unbounded_Sequence< FileInformationType > ::operator=(_s);
        return *this;
      }
    };

    class FileInformationSequence_out;

    class FileInformationSequence_var {
    public:
      inline FileInformationSequence_var() : _pd_seq(0) {}
      inline FileInformationSequence_var(FileInformationSequence* _s) : _pd_seq(_s) {}
      inline FileInformationSequence_var(const FileInformationSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new FileInformationSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~FileInformationSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline FileInformationSequence_var& operator = (FileInformationSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline FileInformationSequence_var& operator = (const FileInformationSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new FileInformationSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline FileInformationType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline FileInformationSequence* operator -> () { return _pd_seq; }
      inline const FileInformationSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator FileInformationSequence& () const { return *_pd_seq; }
#else
      inline operator const FileInformationSequence& () const { return *_pd_seq; }
      inline operator FileInformationSequence& () { return *_pd_seq; }
#endif
        
      inline const FileInformationSequence& in() const { return *_pd_seq; }
      inline FileInformationSequence&       inout()    { return *_pd_seq; }
      inline FileInformationSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline FileInformationSequence* _retn() { FileInformationSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class FileInformationSequence_out;
      
    private:
      FileInformationSequence* _pd_seq;
    };

    class FileInformationSequence_out {
    public:
      inline FileInformationSequence_out(FileInformationSequence*& _s) : _data(_s) { _data = 0; }
      inline FileInformationSequence_out(FileInformationSequence_var& _s)
        : _data(_s._pd_seq) { _s = (FileInformationSequence*) 0; }
      inline FileInformationSequence_out(const FileInformationSequence_out& _s) : _data(_s._data) {}
      inline FileInformationSequence_out& operator = (const FileInformationSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline FileInformationSequence_out& operator = (FileInformationSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator FileInformationSequence*&()  { return _data; }
      inline FileInformationSequence*& ptr()       { return _data; }
      inline FileInformationSequence* operator->() { return _data; }

      inline FileInformationType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      FileInformationSequence*& _data;

    private:
      FileInformationSequence_out();
      FileInformationSequence_out& operator=(const FileInformationSequence_var&);
    };

    static _core_attr const char * CREATED_TIME_ID;

    static _core_attr const char * MODIFIED_TIME_ID;

    static _core_attr const char * LAST_ACCESS_TIME_ID;

  
  };

  class _objref_FileSystem :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void remove(const char* fileName);
    void copy(const char* sourceFileName, const char* destinationFileName);
    void move(const char* sourceFileName, const char* destinationFileName);
    ::CORBA::Boolean exists(const char* fileName);
    FileSystem::FileInformationSequence* list(const char* pattern);
    File_ptr create(const char* fileName);
    File_ptr open(const char* fileName, ::CORBA::Boolean read_Only);
    void mkdir(const char* directoryName);
    void rmdir(const char* directoryName);
    void query(::CF::Properties& fileSystemProperties);

    // Constructors
    inline _objref_FileSystem()  { _PR_setobj(0); }  // nil
    _objref_FileSystem(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FileSystem();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FileSystem(const _objref_FileSystem&);
    _objref_FileSystem& operator = (const _objref_FileSystem&);
    // not implemented

    friend class FileSystem;
  };

  class _pof_FileSystem : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FileSystem() : _OMNI_NS(proxyObjectFactory)(FileSystem::_PD_repoId) {}
    virtual ~_pof_FileSystem();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FileSystem :
    public virtual omniServant
  {
  public:
    virtual ~_impl_FileSystem();

    virtual void remove(const char* fileName) = 0;
    virtual void copy(const char* sourceFileName, const char* destinationFileName) = 0;
    virtual void move(const char* sourceFileName, const char* destinationFileName) = 0;
    virtual ::CORBA::Boolean exists(const char* fileName) = 0;
    virtual FileSystem::FileInformationSequence* list(const char* pattern) = 0;
    virtual File_ptr create(const char* fileName) = 0;
    virtual File_ptr open(const char* fileName, ::CORBA::Boolean read_Only) = 0;
    virtual void mkdir(const char* directoryName) = 0;
    virtual void rmdir(const char* directoryName) = 0;
    virtual void query(::CF::Properties& fileSystemProperties) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileSystem;

#ifndef __CF_mFile__
#define __CF_mFile__
  class File;
  class _objref_File;
  class _impl_File;
  
  typedef _objref_File* File_ptr;
  typedef File_ptr FileRef;

  class File_Helper {
  public:
    typedef File_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_File, File_Helper> File_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_File,File_Helper > File_out;

#endif

  // interface File
  class File {
  public:
    // Declarations for this interface type.
    typedef File_ptr _ptr_type;
    typedef File_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class IOException : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline IOException() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      IOException(const IOException&);
      IOException(ErrorNumberType i_errorNumber, const char* i_msg);
      IOException& operator=(const IOException&);
      virtual ~IOException();
      virtual void _raise() const;
      static IOException* _downcast(::CORBA::Exception*);
      static const IOException* _downcast(const ::CORBA::Exception*);
      static inline IOException* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_IOException;

    class InvalidFilePointer : public ::CORBA::UserException {
    public:
      
      

      inline InvalidFilePointer() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidFilePointer(const InvalidFilePointer&);
      
      InvalidFilePointer& operator=(const InvalidFilePointer&);
      virtual ~InvalidFilePointer();
      virtual void _raise() const;
      static InvalidFilePointer* _downcast(::CORBA::Exception*);
      static const InvalidFilePointer* _downcast(const ::CORBA::Exception*);
      static inline InvalidFilePointer* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFilePointer;

  
  };

  class _objref_File :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* fileName();
    ::CORBA::ULong filePointer();
    void read(::CF::OctetSequence_out data, ::CORBA::ULong length);
    void write(const ::CF::OctetSequence& data);
    ::CORBA::ULong sizeOf();
    void close();
    void setFilePointer(::CORBA::ULong filePointer);

    // Constructors
    inline _objref_File()  { _PR_setobj(0); }  // nil
    _objref_File(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_File();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_File(const _objref_File&);
    _objref_File& operator = (const _objref_File&);
    // not implemented

    friend class File;
  };

  class _pof_File : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_File() : _OMNI_NS(proxyObjectFactory)(File::_PD_repoId) {}
    virtual ~_pof_File();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_File :
    public virtual omniServant
  {
  public:
    virtual ~_impl_File();

    virtual char* fileName() = 0;
    virtual ::CORBA::ULong filePointer() = 0;
    virtual void read(::CF::OctetSequence_out data, ::CORBA::ULong length) = 0;
    virtual void write(const ::CF::OctetSequence& data) = 0;
    virtual ::CORBA::ULong sizeOf() = 0;
    virtual void close() = 0;
    virtual void setFilePointer(::CORBA::ULong filePointer) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_File;

#ifndef __CF_mResourceFactory__
#define __CF_mResourceFactory__
  class ResourceFactory;
  class _objref_ResourceFactory;
  class _impl_ResourceFactory;
  
  typedef _objref_ResourceFactory* ResourceFactory_ptr;
  typedef ResourceFactory_ptr ResourceFactoryRef;

  class ResourceFactory_Helper {
  public:
    typedef ResourceFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ResourceFactory, ResourceFactory_Helper> ResourceFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ResourceFactory,ResourceFactory_Helper > ResourceFactory_out;

#endif

  // interface ResourceFactory
  class ResourceFactory {
  public:
    // Declarations for this interface type.
    typedef ResourceFactory_ptr _ptr_type;
    typedef ResourceFactory_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidResourceId : public ::CORBA::UserException {
    public:
      
      

      inline InvalidResourceId() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidResourceId(const InvalidResourceId&);
      
      InvalidResourceId& operator=(const InvalidResourceId&);
      virtual ~InvalidResourceId();
      virtual void _raise() const;
      static InvalidResourceId* _downcast(::CORBA::Exception*);
      static const InvalidResourceId* _downcast(const ::CORBA::Exception*);
      static inline InvalidResourceId* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidResourceId;

    class ShutdownFailure : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

    

      inline ShutdownFailure() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ShutdownFailure(const ShutdownFailure&);
      ShutdownFailure(const char* i_msg);
      ShutdownFailure& operator=(const ShutdownFailure&);
      virtual ~ShutdownFailure();
      virtual void _raise() const;
      static ShutdownFailure* _downcast(::CORBA::Exception*);
      static const ShutdownFailure* _downcast(const ::CORBA::Exception*);
      static inline ShutdownFailure* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ShutdownFailure;

    class CreateResourceFailure : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline CreateResourceFailure() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      CreateResourceFailure(const CreateResourceFailure&);
      CreateResourceFailure(ErrorNumberType i_errorNumber, const char* i_msg);
      CreateResourceFailure& operator=(const CreateResourceFailure&);
      virtual ~CreateResourceFailure();
      virtual void _raise() const;
      static CreateResourceFailure* _downcast(::CORBA::Exception*);
      static const CreateResourceFailure* _downcast(const ::CORBA::Exception*);
      static inline CreateResourceFailure* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CreateResourceFailure;

  
  };

  class _objref_ResourceFactory :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* identifier();
    Resource_ptr createResource(const char* resourceId, const ::CF::Properties& qualifiers);
    void releaseResource(const char* resourceId);
    void shutdown();

    // Constructors
    inline _objref_ResourceFactory()  { _PR_setobj(0); }  // nil
    _objref_ResourceFactory(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ResourceFactory();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ResourceFactory(const _objref_ResourceFactory&);
    _objref_ResourceFactory& operator = (const _objref_ResourceFactory&);
    // not implemented

    friend class ResourceFactory;
  };

  class _pof_ResourceFactory : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ResourceFactory() : _OMNI_NS(proxyObjectFactory)(ResourceFactory::_PD_repoId) {}
    virtual ~_pof_ResourceFactory();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ResourceFactory :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ResourceFactory();

    virtual char* identifier() = 0;
    virtual Resource_ptr createResource(const char* resourceId, const ::CF::Properties& qualifiers) = 0;
    virtual void releaseResource(const char* resourceId) = 0;
    virtual void shutdown() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ResourceFactory;

#ifndef __CF_mFileManager__
#define __CF_mFileManager__
  class FileManager;
  class _objref_FileManager;
  class _impl_FileManager;
  
  typedef _objref_FileManager* FileManager_ptr;
  typedef FileManager_ptr FileManagerRef;

  class FileManager_Helper {
  public:
    typedef FileManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FileManager, FileManager_Helper> FileManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FileManager,FileManager_Helper > FileManager_out;

#endif

  // interface FileManager
  class FileManager {
  public:
    // Declarations for this interface type.
    typedef FileManager_ptr _ptr_type;
    typedef FileManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct MountType {
      typedef _CORBA_ConstrType_Variable_Var<MountType> _var_type;

      
      ::CORBA::String_member mountPoint;

      _CORBA_ObjRef_Member< _objref_FileSystem, FileSystem_Helper>  fs;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef MountType::_var_type MountType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< MountType,MountType_var > MountType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MountType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MountSequence;

    class MountSequence_var;

    class MountSequence : public _CORBA_Unbounded_Sequence< MountType >  {
    public:
      typedef MountSequence_var _var_type;
      inline MountSequence() {}
      inline MountSequence(const MountSequence& _s)
        : _CORBA_Unbounded_Sequence< MountType > (_s) {}

      inline MountSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< MountType > (_max) {}
      inline MountSequence(_CORBA_ULong _max, _CORBA_ULong _len, MountType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< MountType > (_max, _len, _val, _rel) {}

    

      inline MountSequence& operator = (const MountSequence& _s) {
        _CORBA_Unbounded_Sequence< MountType > ::operator=(_s);
        return *this;
      }
    };

    class MountSequence_out;

    class MountSequence_var {
    public:
      inline MountSequence_var() : _pd_seq(0) {}
      inline MountSequence_var(MountSequence* _s) : _pd_seq(_s) {}
      inline MountSequence_var(const MountSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new MountSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~MountSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline MountSequence_var& operator = (MountSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline MountSequence_var& operator = (const MountSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new MountSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline MountType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline MountSequence* operator -> () { return _pd_seq; }
      inline const MountSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator MountSequence& () const { return *_pd_seq; }
#else
      inline operator const MountSequence& () const { return *_pd_seq; }
      inline operator MountSequence& () { return *_pd_seq; }
#endif
        
      inline const MountSequence& in() const { return *_pd_seq; }
      inline MountSequence&       inout()    { return *_pd_seq; }
      inline MountSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline MountSequence* _retn() { MountSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class MountSequence_out;
      
    private:
      MountSequence* _pd_seq;
    };

    class MountSequence_out {
    public:
      inline MountSequence_out(MountSequence*& _s) : _data(_s) { _data = 0; }
      inline MountSequence_out(MountSequence_var& _s)
        : _data(_s._pd_seq) { _s = (MountSequence*) 0; }
      inline MountSequence_out(const MountSequence_out& _s) : _data(_s._data) {}
      inline MountSequence_out& operator = (const MountSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline MountSequence_out& operator = (MountSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator MountSequence*&()  { return _data; }
      inline MountSequence*& ptr()       { return _data; }
      inline MountSequence* operator->() { return _data; }

      inline MountType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      MountSequence*& _data;

    private:
      MountSequence_out();
      MountSequence_out& operator=(const MountSequence_var&);
    };

    class NonExistentMount : public ::CORBA::UserException {
    public:
      
      

      inline NonExistentMount() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      NonExistentMount(const NonExistentMount&);
      
      NonExistentMount& operator=(const NonExistentMount&);
      virtual ~NonExistentMount();
      virtual void _raise() const;
      static NonExistentMount* _downcast(::CORBA::Exception*);
      static const NonExistentMount* _downcast(const ::CORBA::Exception*);
      static inline NonExistentMount* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_NonExistentMount;

    class InvalidFileSystem : public ::CORBA::UserException {
    public:
      
      

      inline InvalidFileSystem() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidFileSystem(const InvalidFileSystem&);
      
      InvalidFileSystem& operator=(const InvalidFileSystem&);
      virtual ~InvalidFileSystem();
      virtual void _raise() const;
      static InvalidFileSystem* _downcast(::CORBA::Exception*);
      static const InvalidFileSystem* _downcast(const ::CORBA::Exception*);
      static inline InvalidFileSystem* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFileSystem;

    class MountPointAlreadyExists : public ::CORBA::UserException {
    public:
      
      

      inline MountPointAlreadyExists() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      MountPointAlreadyExists(const MountPointAlreadyExists&);
      
      MountPointAlreadyExists& operator=(const MountPointAlreadyExists&);
      virtual ~MountPointAlreadyExists();
      virtual void _raise() const;
      static MountPointAlreadyExists* _downcast(::CORBA::Exception*);
      static const MountPointAlreadyExists* _downcast(const ::CORBA::Exception*);
      static inline MountPointAlreadyExists* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MountPointAlreadyExists;

  
  };

  class _objref_FileManager :
    public virtual _objref_FileSystem
  {
  public:
    // IDL operations
    void mount(const char* mountPoint, ::CF::FileSystem_ptr file_System);
    void unmount(const char* mountPoint);
    FileManager::MountSequence* getMounts();

    // Constructors
    inline _objref_FileManager()  { _PR_setobj(0); }  // nil
    _objref_FileManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FileManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FileManager(const _objref_FileManager&);
    _objref_FileManager& operator = (const _objref_FileManager&);
    // not implemented

    friend class FileManager;
  };

  class _pof_FileManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FileManager() : _OMNI_NS(proxyObjectFactory)(FileManager::_PD_repoId) {}
    virtual ~_pof_FileManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FileManager :
    public virtual _impl_FileSystem
  {
  public:
    virtual ~_impl_FileManager();

    virtual void mount(const char* mountPoint, ::CF::FileSystem_ptr file_System) = 0;
    virtual void unmount(const char* mountPoint) = 0;
    virtual FileManager::MountSequence* getMounts() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileManager;

#ifndef __CF_mLifeCycle__
#define __CF_mLifeCycle__
  class LifeCycle;
  class _objref_LifeCycle;
  class _impl_LifeCycle;
  
  typedef _objref_LifeCycle* LifeCycle_ptr;
  typedef LifeCycle_ptr LifeCycleRef;

  class LifeCycle_Helper {
  public:
    typedef LifeCycle_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LifeCycle, LifeCycle_Helper> LifeCycle_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LifeCycle,LifeCycle_Helper > LifeCycle_out;

#endif

  // interface LifeCycle
  class LifeCycle {
  public:
    // Declarations for this interface type.
    typedef LifeCycle_ptr _ptr_type;
    typedef LifeCycle_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InitializeError : public ::CORBA::UserException {
    public:
      
      StringSequence errorMessages;

    

      inline InitializeError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InitializeError(const InitializeError&);
      InitializeError(const StringSequence i_errorMessages);
      InitializeError& operator=(const InitializeError&);
      virtual ~InitializeError();
      virtual void _raise() const;
      static InitializeError* _downcast(::CORBA::Exception*);
      static const InitializeError* _downcast(const ::CORBA::Exception*);
      static inline InitializeError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InitializeError;

    class ReleaseError : public ::CORBA::UserException {
    public:
      
      StringSequence errorMessages;

    

      inline ReleaseError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ReleaseError(const ReleaseError&);
      ReleaseError(const StringSequence i_errorMessages);
      ReleaseError& operator=(const ReleaseError&);
      virtual ~ReleaseError();
      virtual void _raise() const;
      static ReleaseError* _downcast(::CORBA::Exception*);
      static const ReleaseError* _downcast(const ::CORBA::Exception*);
      static inline ReleaseError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ReleaseError;

  
  };

  class _objref_LifeCycle :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void initialize();
    void releaseObject();

    // Constructors
    inline _objref_LifeCycle()  { _PR_setobj(0); }  // nil
    _objref_LifeCycle(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LifeCycle();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LifeCycle(const _objref_LifeCycle&);
    _objref_LifeCycle& operator = (const _objref_LifeCycle&);
    // not implemented

    friend class LifeCycle;
  };

  class _pof_LifeCycle : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LifeCycle() : _OMNI_NS(proxyObjectFactory)(LifeCycle::_PD_repoId) {}
    virtual ~_pof_LifeCycle();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LifeCycle :
    public virtual omniServant
  {
  public:
    virtual ~_impl_LifeCycle();

    virtual void initialize() = 0;
    virtual void releaseObject() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LifeCycle;

#ifndef __CF_mTestableObject__
#define __CF_mTestableObject__
  class TestableObject;
  class _objref_TestableObject;
  class _impl_TestableObject;
  
  typedef _objref_TestableObject* TestableObject_ptr;
  typedef TestableObject_ptr TestableObjectRef;

  class TestableObject_Helper {
  public:
    typedef TestableObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_TestableObject, TestableObject_Helper> TestableObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_TestableObject,TestableObject_Helper > TestableObject_out;

#endif

  // interface TestableObject
  class TestableObject {
  public:
    // Declarations for this interface type.
    typedef TestableObject_ptr _ptr_type;
    typedef TestableObject_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class UnknownTest : public ::CORBA::UserException {
    public:
      
      

      inline UnknownTest() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnknownTest(const UnknownTest&);
      
      UnknownTest& operator=(const UnknownTest&);
      virtual ~UnknownTest();
      virtual void _raise() const;
      static UnknownTest* _downcast(::CORBA::Exception*);
      static const UnknownTest* _downcast(const ::CORBA::Exception*);
      static inline UnknownTest* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownTest;

  
  };

  class _objref_TestableObject :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void runTest(::CORBA::ULong testid, ::CF::Properties& testValues);

    // Constructors
    inline _objref_TestableObject()  { _PR_setobj(0); }  // nil
    _objref_TestableObject(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_TestableObject();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_TestableObject(const _objref_TestableObject&);
    _objref_TestableObject& operator = (const _objref_TestableObject&);
    // not implemented

    friend class TestableObject;
  };

  class _pof_TestableObject : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_TestableObject() : _OMNI_NS(proxyObjectFactory)(TestableObject::_PD_repoId) {}
    virtual ~_pof_TestableObject();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_TestableObject :
    public virtual omniServant
  {
  public:
    virtual ~_impl_TestableObject();

    virtual void runTest(::CORBA::ULong testid, ::CF::Properties& testValues) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TestableObject;

#ifndef __CF_mPropertyChangeListener__
#define __CF_mPropertyChangeListener__
  class PropertyChangeListener;
  class _objref_PropertyChangeListener;
  class _impl_PropertyChangeListener;
  
  typedef _objref_PropertyChangeListener* PropertyChangeListener_ptr;
  typedef PropertyChangeListener_ptr PropertyChangeListenerRef;

  class PropertyChangeListener_Helper {
  public:
    typedef PropertyChangeListener_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PropertyChangeListener, PropertyChangeListener_Helper> PropertyChangeListener_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PropertyChangeListener,PropertyChangeListener_Helper > PropertyChangeListener_out;

#endif

  // interface PropertyChangeListener
  class PropertyChangeListener {
  public:
    // Declarations for this interface type.
    typedef PropertyChangeListener_ptr _ptr_type;
    typedef PropertyChangeListener_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct PropertyChangeEvent {
      typedef _CORBA_ConstrType_Variable_Var<PropertyChangeEvent> _var_type;

      
      ::CORBA::String_member evt_id;

      ::CORBA::String_member reg_id;

      ::CORBA::String_member resource_id;

      CF::Properties properties;

      UTCTime timestamp;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef PropertyChangeEvent::_var_type PropertyChangeEvent_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< PropertyChangeEvent,PropertyChangeEvent_var > PropertyChangeEvent_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyChangeEvent;

  
  };

  class _objref_PropertyChangeListener :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void propertyChange(const ::CF::PropertyChangeListener::PropertyChangeEvent& prop_event);

    // Constructors
    inline _objref_PropertyChangeListener()  { _PR_setobj(0); }  // nil
    _objref_PropertyChangeListener(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PropertyChangeListener();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PropertyChangeListener(const _objref_PropertyChangeListener&);
    _objref_PropertyChangeListener& operator = (const _objref_PropertyChangeListener&);
    // not implemented

    friend class PropertyChangeListener;
  };

  class _pof_PropertyChangeListener : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PropertyChangeListener() : _OMNI_NS(proxyObjectFactory)(PropertyChangeListener::_PD_repoId) {}
    virtual ~_pof_PropertyChangeListener();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PropertyChangeListener :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PropertyChangeListener();

    virtual void propertyChange(const ::CF::PropertyChangeListener::PropertyChangeEvent& prop_event) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyChangeListener;

#ifndef __CF_mPropertySet__
#define __CF_mPropertySet__
  class PropertySet;
  class _objref_PropertySet;
  class _impl_PropertySet;
  
  typedef _objref_PropertySet* PropertySet_ptr;
  typedef PropertySet_ptr PropertySetRef;

  class PropertySet_Helper {
  public:
    typedef PropertySet_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PropertySet, PropertySet_Helper> PropertySet_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PropertySet,PropertySet_Helper > PropertySet_out;

#endif

  // interface PropertySet
  class PropertySet {
  public:
    // Declarations for this interface type.
    typedef PropertySet_ptr _ptr_type;
    typedef PropertySet_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidConfiguration : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

      Properties invalidProperties;

    

      inline InvalidConfiguration() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidConfiguration(const InvalidConfiguration&);
      InvalidConfiguration(const char* i_msg, const Properties i_invalidProperties);
      InvalidConfiguration& operator=(const InvalidConfiguration&);
      virtual ~InvalidConfiguration();
      virtual void _raise() const;
      static InvalidConfiguration* _downcast(::CORBA::Exception*);
      static const InvalidConfiguration* _downcast(const ::CORBA::Exception*);
      static inline InvalidConfiguration* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidConfiguration;

    class PartialConfiguration : public ::CORBA::UserException {
    public:
      
      Properties invalidProperties;

    

      inline PartialConfiguration() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      PartialConfiguration(const PartialConfiguration&);
      PartialConfiguration(const Properties i_invalidProperties);
      PartialConfiguration& operator=(const PartialConfiguration&);
      virtual ~PartialConfiguration();
      virtual void _raise() const;
      static PartialConfiguration* _downcast(::CORBA::Exception*);
      static const PartialConfiguration* _downcast(const ::CORBA::Exception*);
      static inline PartialConfiguration* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PartialConfiguration;

  
  };

  class _objref_PropertySet :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void configure(const ::CF::Properties& configProperties);
    void query(::CF::Properties& configProperties);

    // Constructors
    inline _objref_PropertySet()  { _PR_setobj(0); }  // nil
    _objref_PropertySet(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PropertySet();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PropertySet(const _objref_PropertySet&);
    _objref_PropertySet& operator = (const _objref_PropertySet&);
    // not implemented

    friend class PropertySet;
  };

  class _pof_PropertySet : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PropertySet() : _OMNI_NS(proxyObjectFactory)(PropertySet::_PD_repoId) {}
    virtual ~_pof_PropertySet();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PropertySet :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PropertySet();

    virtual void configure(const ::CF::Properties& configProperties) = 0;
    virtual void query(::CF::Properties& configProperties) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertySet;

#ifndef __CF_mPropertyEmitter__
#define __CF_mPropertyEmitter__
  class PropertyEmitter;
  class _objref_PropertyEmitter;
  class _impl_PropertyEmitter;
  
  typedef _objref_PropertyEmitter* PropertyEmitter_ptr;
  typedef PropertyEmitter_ptr PropertyEmitterRef;

  class PropertyEmitter_Helper {
  public:
    typedef PropertyEmitter_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PropertyEmitter, PropertyEmitter_Helper> PropertyEmitter_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PropertyEmitter,PropertyEmitter_Helper > PropertyEmitter_out;

#endif

  // interface PropertyEmitter
  class PropertyEmitter {
  public:
    // Declarations for this interface type.
    typedef PropertyEmitter_ptr _ptr_type;
    typedef PropertyEmitter_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class AlreadyInitialized : public ::CORBA::UserException {
    public:
      
      

      inline AlreadyInitialized() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      AlreadyInitialized(const AlreadyInitialized&);
      
      AlreadyInitialized& operator=(const AlreadyInitialized&);
      virtual ~AlreadyInitialized();
      virtual void _raise() const;
      static AlreadyInitialized* _downcast(::CORBA::Exception*);
      static const AlreadyInitialized* _downcast(const ::CORBA::Exception*);
      static inline AlreadyInitialized* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlreadyInitialized;

  
  };

  class _objref_PropertyEmitter :
    public virtual _objref_PropertySet
  {
  public:
    // IDL operations
    void initializeProperties(const ::CF::Properties& initialProperties);
    char* registerPropertyListener(::CORBA::Object_ptr obj, const ::CF::StringSequence& prop_ids, ::CORBA::Float interval);
    void unregisterPropertyListener(const char* id);

    // Constructors
    inline _objref_PropertyEmitter()  { _PR_setobj(0); }  // nil
    _objref_PropertyEmitter(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PropertyEmitter();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PropertyEmitter(const _objref_PropertyEmitter&);
    _objref_PropertyEmitter& operator = (const _objref_PropertyEmitter&);
    // not implemented

    friend class PropertyEmitter;
  };

  class _pof_PropertyEmitter : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PropertyEmitter() : _OMNI_NS(proxyObjectFactory)(PropertyEmitter::_PD_repoId) {}
    virtual ~_pof_PropertyEmitter();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PropertyEmitter :
    public virtual _impl_PropertySet
  {
  public:
    virtual ~_impl_PropertyEmitter();

    virtual void initializeProperties(const ::CF::Properties& initialProperties) = 0;
    virtual char* registerPropertyListener(::CORBA::Object_ptr obj, const ::CF::StringSequence& prop_ids, ::CORBA::Float interval) = 0;
    virtual void unregisterPropertyListener(const char* id) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyEmitter;

#ifndef __CF_mAllocationStatusIterator__
#define __CF_mAllocationStatusIterator__
  class AllocationStatusIterator;
  class _objref_AllocationStatusIterator;
  class _impl_AllocationStatusIterator;
  
  typedef _objref_AllocationStatusIterator* AllocationStatusIterator_ptr;
  typedef AllocationStatusIterator_ptr AllocationStatusIteratorRef;

  class AllocationStatusIterator_Helper {
  public:
    typedef AllocationStatusIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_AllocationStatusIterator, AllocationStatusIterator_Helper> AllocationStatusIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_AllocationStatusIterator,AllocationStatusIterator_Helper > AllocationStatusIterator_out;

#endif

#ifndef __CF_mDeviceLocationIterator__
#define __CF_mDeviceLocationIterator__
  class DeviceLocationIterator;
  class _objref_DeviceLocationIterator;
  class _impl_DeviceLocationIterator;
  
  typedef _objref_DeviceLocationIterator* DeviceLocationIterator_ptr;
  typedef DeviceLocationIterator_ptr DeviceLocationIteratorRef;

  class DeviceLocationIterator_Helper {
  public:
    typedef DeviceLocationIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceLocationIterator, DeviceLocationIterator_Helper> DeviceLocationIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceLocationIterator,DeviceLocationIterator_Helper > DeviceLocationIterator_out;

#endif

#ifndef __CF_mAllocationManager__
#define __CF_mAllocationManager__
  class AllocationManager;
  class _objref_AllocationManager;
  class _impl_AllocationManager;
  
  typedef _objref_AllocationManager* AllocationManager_ptr;
  typedef AllocationManager_ptr AllocationManagerRef;

  class AllocationManager_Helper {
  public:
    typedef AllocationManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_AllocationManager, AllocationManager_Helper> AllocationManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_AllocationManager,AllocationManager_Helper > AllocationManager_out;

#endif

  // interface AllocationManager
  class AllocationManager {
  public:
    // Declarations for this interface type.
    typedef AllocationManager_ptr _ptr_type;
    typedef AllocationManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DevicePoolNames;

    class DevicePoolNames_var;

    class DevicePoolNames : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef DevicePoolNames_var _var_type;
      inline DevicePoolNames() {}
      inline DevicePoolNames(const DevicePoolNames& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline DevicePoolNames(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline DevicePoolNames(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline DevicePoolNames& operator = (const DevicePoolNames& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class DevicePoolNames_out;

    class DevicePoolNames_var {
    public:
      inline DevicePoolNames_var() : _pd_seq(0) {}
      inline DevicePoolNames_var(DevicePoolNames* _s) : _pd_seq(_s) {}
      inline DevicePoolNames_var(const DevicePoolNames_var& _s) {
        if (_s._pd_seq)  _pd_seq = new DevicePoolNames(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~DevicePoolNames_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline DevicePoolNames_var& operator = (DevicePoolNames* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DevicePoolNames_var& operator = (const DevicePoolNames_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new DevicePoolNames;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DevicePoolNames* operator -> () { return _pd_seq; }
      inline const DevicePoolNames* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DevicePoolNames& () const { return *_pd_seq; }
#else
      inline operator const DevicePoolNames& () const { return *_pd_seq; }
      inline operator DevicePoolNames& () { return *_pd_seq; }
#endif
        
      inline const DevicePoolNames& in() const { return *_pd_seq; }
      inline DevicePoolNames&       inout()    { return *_pd_seq; }
      inline DevicePoolNames*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DevicePoolNames* _retn() { DevicePoolNames* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DevicePoolNames_out;
      
    private:
      DevicePoolNames* _pd_seq;
    };

    class DevicePoolNames_out {
    public:
      inline DevicePoolNames_out(DevicePoolNames*& _s) : _data(_s) { _data = 0; }
      inline DevicePoolNames_out(DevicePoolNames_var& _s)
        : _data(_s._pd_seq) { _s = (DevicePoolNames*) 0; }
      inline DevicePoolNames_out(const DevicePoolNames_out& _s) : _data(_s._data) {}
      inline DevicePoolNames_out& operator = (const DevicePoolNames_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DevicePoolNames_out& operator = (DevicePoolNames* _s) {
        _data = _s;
        return *this;
      }
      inline operator DevicePoolNames*&()  { return _data; }
      inline DevicePoolNames*& ptr()       { return _data; }
      inline DevicePoolNames* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DevicePoolNames*& _data;

    private:
      DevicePoolNames_out();
      DevicePoolNames_out& operator=(const DevicePoolNames_var&);
    };

    struct AllocationRequestType {
      typedef _CORBA_ConstrType_Variable_Var<AllocationRequestType> _var_type;

      
      ::CORBA::String_member requestID;

      Properties allocationProperties;

      DevicePoolNames devicePools;

      DeviceSequence requestedDevices;

      ::CORBA::String_member sourceID;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AllocationRequestType::_var_type AllocationRequestType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< AllocationRequestType,AllocationRequestType_var > AllocationRequestType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationRequestType;

    struct AllocationResponseType {
      typedef _CORBA_ConstrType_Variable_Var<AllocationResponseType> _var_type;

      
      ::CORBA::String_member requestID;

      ::CORBA::String_member allocationID;

      Properties allocationProperties;

      _CORBA_ObjRef_Member< _objref_Device, Device_Helper>  allocatedDevice;

      _CORBA_ObjRef_Member< _objref_DeviceManager, DeviceManager_Helper>  allocationDeviceManager;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AllocationResponseType::_var_type AllocationResponseType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< AllocationResponseType,AllocationResponseType_var > AllocationResponseType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationResponseType;

    struct AllocationStatusType {
      typedef _CORBA_ConstrType_Variable_Var<AllocationStatusType> _var_type;

      
      ::CORBA::String_member allocationID;

      ::CORBA::String_member requestingDomain;

      Properties allocationProperties;

      _CORBA_ObjRef_Member< _objref_Device, Device_Helper>  allocatedDevice;

      _CORBA_ObjRef_Member< _objref_DeviceManager, DeviceManager_Helper>  allocationDeviceManager;

      ::CORBA::String_member sourceID;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AllocationStatusType::_var_type AllocationStatusType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< AllocationStatusType,AllocationStatusType_var > AllocationStatusType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationStatusType;

    struct DeviceLocationType {
      typedef _CORBA_ConstrType_Variable_Var<DeviceLocationType> _var_type;

      
      ::CORBA::String_member domainName;

      DevicePoolNames pools;

      _CORBA_ObjRef_Member< _objref_DeviceManager, DeviceManager_Helper>  devMgr;

      _CORBA_ObjRef_Member< _objref_Device, Device_Helper>  dev;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DeviceLocationType::_var_type DeviceLocationType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DeviceLocationType,DeviceLocationType_var > DeviceLocationType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceLocationType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationRequestSequence;

    class AllocationRequestSequence_var;

    class AllocationRequestSequence : public _CORBA_Unbounded_Sequence< AllocationRequestType >  {
    public:
      typedef AllocationRequestSequence_var _var_type;
      inline AllocationRequestSequence() {}
      inline AllocationRequestSequence(const AllocationRequestSequence& _s)
        : _CORBA_Unbounded_Sequence< AllocationRequestType > (_s) {}

      inline AllocationRequestSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< AllocationRequestType > (_max) {}
      inline AllocationRequestSequence(_CORBA_ULong _max, _CORBA_ULong _len, AllocationRequestType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< AllocationRequestType > (_max, _len, _val, _rel) {}

    

      inline AllocationRequestSequence& operator = (const AllocationRequestSequence& _s) {
        _CORBA_Unbounded_Sequence< AllocationRequestType > ::operator=(_s);
        return *this;
      }
    };

    class AllocationRequestSequence_out;

    class AllocationRequestSequence_var {
    public:
      inline AllocationRequestSequence_var() : _pd_seq(0) {}
      inline AllocationRequestSequence_var(AllocationRequestSequence* _s) : _pd_seq(_s) {}
      inline AllocationRequestSequence_var(const AllocationRequestSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new AllocationRequestSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~AllocationRequestSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline AllocationRequestSequence_var& operator = (AllocationRequestSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AllocationRequestSequence_var& operator = (const AllocationRequestSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new AllocationRequestSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline AllocationRequestType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AllocationRequestSequence* operator -> () { return _pd_seq; }
      inline const AllocationRequestSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AllocationRequestSequence& () const { return *_pd_seq; }
#else
      inline operator const AllocationRequestSequence& () const { return *_pd_seq; }
      inline operator AllocationRequestSequence& () { return *_pd_seq; }
#endif
        
      inline const AllocationRequestSequence& in() const { return *_pd_seq; }
      inline AllocationRequestSequence&       inout()    { return *_pd_seq; }
      inline AllocationRequestSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AllocationRequestSequence* _retn() { AllocationRequestSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AllocationRequestSequence_out;
      
    private:
      AllocationRequestSequence* _pd_seq;
    };

    class AllocationRequestSequence_out {
    public:
      inline AllocationRequestSequence_out(AllocationRequestSequence*& _s) : _data(_s) { _data = 0; }
      inline AllocationRequestSequence_out(AllocationRequestSequence_var& _s)
        : _data(_s._pd_seq) { _s = (AllocationRequestSequence*) 0; }
      inline AllocationRequestSequence_out(const AllocationRequestSequence_out& _s) : _data(_s._data) {}
      inline AllocationRequestSequence_out& operator = (const AllocationRequestSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AllocationRequestSequence_out& operator = (AllocationRequestSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator AllocationRequestSequence*&()  { return _data; }
      inline AllocationRequestSequence*& ptr()       { return _data; }
      inline AllocationRequestSequence* operator->() { return _data; }

      inline AllocationRequestType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AllocationRequestSequence*& _data;

    private:
      AllocationRequestSequence_out();
      AllocationRequestSequence_out& operator=(const AllocationRequestSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationResponseSequence;

    class AllocationResponseSequence_var;

    class AllocationResponseSequence : public _CORBA_Unbounded_Sequence< AllocationResponseType >  {
    public:
      typedef AllocationResponseSequence_var _var_type;
      inline AllocationResponseSequence() {}
      inline AllocationResponseSequence(const AllocationResponseSequence& _s)
        : _CORBA_Unbounded_Sequence< AllocationResponseType > (_s) {}

      inline AllocationResponseSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< AllocationResponseType > (_max) {}
      inline AllocationResponseSequence(_CORBA_ULong _max, _CORBA_ULong _len, AllocationResponseType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< AllocationResponseType > (_max, _len, _val, _rel) {}

    

      inline AllocationResponseSequence& operator = (const AllocationResponseSequence& _s) {
        _CORBA_Unbounded_Sequence< AllocationResponseType > ::operator=(_s);
        return *this;
      }
    };

    class AllocationResponseSequence_out;

    class AllocationResponseSequence_var {
    public:
      inline AllocationResponseSequence_var() : _pd_seq(0) {}
      inline AllocationResponseSequence_var(AllocationResponseSequence* _s) : _pd_seq(_s) {}
      inline AllocationResponseSequence_var(const AllocationResponseSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new AllocationResponseSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~AllocationResponseSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline AllocationResponseSequence_var& operator = (AllocationResponseSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AllocationResponseSequence_var& operator = (const AllocationResponseSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new AllocationResponseSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline AllocationResponseType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AllocationResponseSequence* operator -> () { return _pd_seq; }
      inline const AllocationResponseSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AllocationResponseSequence& () const { return *_pd_seq; }
#else
      inline operator const AllocationResponseSequence& () const { return *_pd_seq; }
      inline operator AllocationResponseSequence& () { return *_pd_seq; }
#endif
        
      inline const AllocationResponseSequence& in() const { return *_pd_seq; }
      inline AllocationResponseSequence&       inout()    { return *_pd_seq; }
      inline AllocationResponseSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AllocationResponseSequence* _retn() { AllocationResponseSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AllocationResponseSequence_out;
      
    private:
      AllocationResponseSequence* _pd_seq;
    };

    class AllocationResponseSequence_out {
    public:
      inline AllocationResponseSequence_out(AllocationResponseSequence*& _s) : _data(_s) { _data = 0; }
      inline AllocationResponseSequence_out(AllocationResponseSequence_var& _s)
        : _data(_s._pd_seq) { _s = (AllocationResponseSequence*) 0; }
      inline AllocationResponseSequence_out(const AllocationResponseSequence_out& _s) : _data(_s._data) {}
      inline AllocationResponseSequence_out& operator = (const AllocationResponseSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AllocationResponseSequence_out& operator = (AllocationResponseSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator AllocationResponseSequence*&()  { return _data; }
      inline AllocationResponseSequence*& ptr()       { return _data; }
      inline AllocationResponseSequence* operator->() { return _data; }

      inline AllocationResponseType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AllocationResponseSequence*& _data;

    private:
      AllocationResponseSequence_out();
      AllocationResponseSequence_out& operator=(const AllocationResponseSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationStatusSequence;

    class AllocationStatusSequence_var;

    class AllocationStatusSequence : public _CORBA_Unbounded_Sequence< AllocationStatusType >  {
    public:
      typedef AllocationStatusSequence_var _var_type;
      inline AllocationStatusSequence() {}
      inline AllocationStatusSequence(const AllocationStatusSequence& _s)
        : _CORBA_Unbounded_Sequence< AllocationStatusType > (_s) {}

      inline AllocationStatusSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< AllocationStatusType > (_max) {}
      inline AllocationStatusSequence(_CORBA_ULong _max, _CORBA_ULong _len, AllocationStatusType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< AllocationStatusType > (_max, _len, _val, _rel) {}

    

      inline AllocationStatusSequence& operator = (const AllocationStatusSequence& _s) {
        _CORBA_Unbounded_Sequence< AllocationStatusType > ::operator=(_s);
        return *this;
      }
    };

    class AllocationStatusSequence_out;

    class AllocationStatusSequence_var {
    public:
      inline AllocationStatusSequence_var() : _pd_seq(0) {}
      inline AllocationStatusSequence_var(AllocationStatusSequence* _s) : _pd_seq(_s) {}
      inline AllocationStatusSequence_var(const AllocationStatusSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new AllocationStatusSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~AllocationStatusSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline AllocationStatusSequence_var& operator = (AllocationStatusSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline AllocationStatusSequence_var& operator = (const AllocationStatusSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new AllocationStatusSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline AllocationStatusType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline AllocationStatusSequence* operator -> () { return _pd_seq; }
      inline const AllocationStatusSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator AllocationStatusSequence& () const { return *_pd_seq; }
#else
      inline operator const AllocationStatusSequence& () const { return *_pd_seq; }
      inline operator AllocationStatusSequence& () { return *_pd_seq; }
#endif
        
      inline const AllocationStatusSequence& in() const { return *_pd_seq; }
      inline AllocationStatusSequence&       inout()    { return *_pd_seq; }
      inline AllocationStatusSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline AllocationStatusSequence* _retn() { AllocationStatusSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class AllocationStatusSequence_out;
      
    private:
      AllocationStatusSequence* _pd_seq;
    };

    class AllocationStatusSequence_out {
    public:
      inline AllocationStatusSequence_out(AllocationStatusSequence*& _s) : _data(_s) { _data = 0; }
      inline AllocationStatusSequence_out(AllocationStatusSequence_var& _s)
        : _data(_s._pd_seq) { _s = (AllocationStatusSequence*) 0; }
      inline AllocationStatusSequence_out(const AllocationStatusSequence_out& _s) : _data(_s._data) {}
      inline AllocationStatusSequence_out& operator = (const AllocationStatusSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline AllocationStatusSequence_out& operator = (AllocationStatusSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator AllocationStatusSequence*&()  { return _data; }
      inline AllocationStatusSequence*& ptr()       { return _data; }
      inline AllocationStatusSequence* operator->() { return _data; }

      inline AllocationStatusType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      AllocationStatusSequence*& _data;

    private:
      AllocationStatusSequence_out();
      AllocationStatusSequence_out& operator=(const AllocationStatusSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceLocationSequence;

    class DeviceLocationSequence_var;

    class DeviceLocationSequence : public _CORBA_Unbounded_Sequence< DeviceLocationType >  {
    public:
      typedef DeviceLocationSequence_var _var_type;
      inline DeviceLocationSequence() {}
      inline DeviceLocationSequence(const DeviceLocationSequence& _s)
        : _CORBA_Unbounded_Sequence< DeviceLocationType > (_s) {}

      inline DeviceLocationSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DeviceLocationType > (_max) {}
      inline DeviceLocationSequence(_CORBA_ULong _max, _CORBA_ULong _len, DeviceLocationType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DeviceLocationType > (_max, _len, _val, _rel) {}

    

      inline DeviceLocationSequence& operator = (const DeviceLocationSequence& _s) {
        _CORBA_Unbounded_Sequence< DeviceLocationType > ::operator=(_s);
        return *this;
      }
    };

    class DeviceLocationSequence_out;

    class DeviceLocationSequence_var {
    public:
      inline DeviceLocationSequence_var() : _pd_seq(0) {}
      inline DeviceLocationSequence_var(DeviceLocationSequence* _s) : _pd_seq(_s) {}
      inline DeviceLocationSequence_var(const DeviceLocationSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new DeviceLocationSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~DeviceLocationSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline DeviceLocationSequence_var& operator = (DeviceLocationSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DeviceLocationSequence_var& operator = (const DeviceLocationSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new DeviceLocationSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline DeviceLocationType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DeviceLocationSequence* operator -> () { return _pd_seq; }
      inline const DeviceLocationSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DeviceLocationSequence& () const { return *_pd_seq; }
#else
      inline operator const DeviceLocationSequence& () const { return *_pd_seq; }
      inline operator DeviceLocationSequence& () { return *_pd_seq; }
#endif
        
      inline const DeviceLocationSequence& in() const { return *_pd_seq; }
      inline DeviceLocationSequence&       inout()    { return *_pd_seq; }
      inline DeviceLocationSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DeviceLocationSequence* _retn() { DeviceLocationSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DeviceLocationSequence_out;
      
    private:
      DeviceLocationSequence* _pd_seq;
    };

    class DeviceLocationSequence_out {
    public:
      inline DeviceLocationSequence_out(DeviceLocationSequence*& _s) : _data(_s) { _data = 0; }
      inline DeviceLocationSequence_out(DeviceLocationSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DeviceLocationSequence*) 0; }
      inline DeviceLocationSequence_out(const DeviceLocationSequence_out& _s) : _data(_s._data) {}
      inline DeviceLocationSequence_out& operator = (const DeviceLocationSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DeviceLocationSequence_out& operator = (DeviceLocationSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DeviceLocationSequence*&()  { return _data; }
      inline DeviceLocationSequence*& ptr()       { return _data; }
      inline DeviceLocationSequence* operator->() { return _data; }

      inline DeviceLocationType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DeviceLocationSequence*& _data;

    private:
      DeviceLocationSequence_out();
      DeviceLocationSequence_out& operator=(const DeviceLocationSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_allocationIDSequence;

    class allocationIDSequence_var;

    class allocationIDSequence : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef allocationIDSequence_var _var_type;
      inline allocationIDSequence() {}
      inline allocationIDSequence(const allocationIDSequence& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline allocationIDSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline allocationIDSequence(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline allocationIDSequence& operator = (const allocationIDSequence& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class allocationIDSequence_out;

    class allocationIDSequence_var {
    public:
      inline allocationIDSequence_var() : _pd_seq(0) {}
      inline allocationIDSequence_var(allocationIDSequence* _s) : _pd_seq(_s) {}
      inline allocationIDSequence_var(const allocationIDSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new allocationIDSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~allocationIDSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline allocationIDSequence_var& operator = (allocationIDSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline allocationIDSequence_var& operator = (const allocationIDSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new allocationIDSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline allocationIDSequence* operator -> () { return _pd_seq; }
      inline const allocationIDSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator allocationIDSequence& () const { return *_pd_seq; }
#else
      inline operator const allocationIDSequence& () const { return *_pd_seq; }
      inline operator allocationIDSequence& () { return *_pd_seq; }
#endif
        
      inline const allocationIDSequence& in() const { return *_pd_seq; }
      inline allocationIDSequence&       inout()    { return *_pd_seq; }
      inline allocationIDSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline allocationIDSequence* _retn() { allocationIDSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class allocationIDSequence_out;
      
    private:
      allocationIDSequence* _pd_seq;
    };

    class allocationIDSequence_out {
    public:
      inline allocationIDSequence_out(allocationIDSequence*& _s) : _data(_s) { _data = 0; }
      inline allocationIDSequence_out(allocationIDSequence_var& _s)
        : _data(_s._pd_seq) { _s = (allocationIDSequence*) 0; }
      inline allocationIDSequence_out(const allocationIDSequence_out& _s) : _data(_s._data) {}
      inline allocationIDSequence_out& operator = (const allocationIDSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline allocationIDSequence_out& operator = (allocationIDSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator allocationIDSequence*&()  { return _data; }
      inline allocationIDSequence*& ptr()       { return _data; }
      inline allocationIDSequence* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      allocationIDSequence*& _data;

    private:
      allocationIDSequence_out();
      allocationIDSequence_out& operator=(const allocationIDSequence_var&);
    };

    class AllocationError : public ::CORBA::UserException {
    public:
      
      ::CORBA::Short errorCode;

      ::CORBA::String_member message;

    

      inline AllocationError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      AllocationError(const AllocationError&);
      AllocationError(::CORBA::Short i_errorCode, const char* i_message);
      AllocationError& operator=(const AllocationError&);
      virtual ~AllocationError();
      virtual void _raise() const;
      static AllocationError* _downcast(::CORBA::Exception*);
      static const AllocationError* _downcast(const ::CORBA::Exception*);
      static inline AllocationError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationError;

    class InvalidAllocationId : public ::CORBA::UserException {
    public:
      
      allocationIDSequence invalidAllocationIds;

    

      inline InvalidAllocationId() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidAllocationId(const InvalidAllocationId&);
      InvalidAllocationId(const allocationIDSequence i_invalidAllocationIds);
      InvalidAllocationId& operator=(const InvalidAllocationId&);
      virtual ~InvalidAllocationId();
      virtual void _raise() const;
      static InvalidAllocationId* _downcast(::CORBA::Exception*);
      static const InvalidAllocationId* _downcast(const ::CORBA::Exception*);
      static inline InvalidAllocationId* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidAllocationId;

    enum DeviceScopeType { LOCAL_DEVICES, ALL_DEVICES, AUTHORIZED_DEVICES /*, __max_DeviceScopeType=0xffffffff */ };
    typedef DeviceScopeType& DeviceScopeType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceScopeType;

    enum AllocationScopeType { LOCAL_ALLOCATIONS, ALL_ALLOCATIONS /*, __max_AllocationScopeType=0xffffffff */ };
    typedef AllocationScopeType& AllocationScopeType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationScopeType;

  
  };

  class _objref_AllocationManager :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    AllocationManager::DeviceLocationSequence* allDevices();
    AllocationManager::DeviceLocationSequence* authorizedDevices();
    AllocationManager::DeviceLocationSequence* localDevices();
    void listDevices(::CF::AllocationManager::DeviceScopeType deviceScope, ::CORBA::ULong count, ::CF::AllocationManager::DeviceLocationSequence_out devices, ::CF::DeviceLocationIterator_out dl);
    DomainManager_ptr domainMgr();
    AllocationManager::AllocationResponseSequence* allocate(const ::CF::AllocationManager::AllocationRequestSequence& requests);
    AllocationManager::AllocationResponseSequence* allocateLocal(const ::CF::AllocationManager::AllocationRequestSequence& requests, const char* domainName);
    void deallocate(const ::CF::AllocationManager::allocationIDSequence& allocationIDs);
    AllocationManager::AllocationStatusSequence* allocations(const ::CF::AllocationManager::allocationIDSequence& allocationIDs);
    AllocationManager::AllocationStatusSequence* localAllocations(const ::CF::AllocationManager::allocationIDSequence& allocationIDs);
    void listAllocations(::CF::AllocationManager::AllocationScopeType allocScope, ::CORBA::ULong how_many, ::CF::AllocationManager::AllocationStatusSequence_out allocs, ::CF::AllocationStatusIterator_out ai);

    // Constructors
    inline _objref_AllocationManager()  { _PR_setobj(0); }  // nil
    _objref_AllocationManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_AllocationManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_AllocationManager(const _objref_AllocationManager&);
    _objref_AllocationManager& operator = (const _objref_AllocationManager&);
    // not implemented

    friend class AllocationManager;
  };

  class _pof_AllocationManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_AllocationManager() : _OMNI_NS(proxyObjectFactory)(AllocationManager::_PD_repoId) {}
    virtual ~_pof_AllocationManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_AllocationManager :
    public virtual omniServant
  {
  public:
    virtual ~_impl_AllocationManager();

    virtual AllocationManager::DeviceLocationSequence* allDevices() = 0;
    virtual AllocationManager::DeviceLocationSequence* authorizedDevices() = 0;
    virtual AllocationManager::DeviceLocationSequence* localDevices() = 0;
    virtual void listDevices(::CF::AllocationManager::DeviceScopeType deviceScope, ::CORBA::ULong count, ::CF::AllocationManager::DeviceLocationSequence_out devices, ::CF::DeviceLocationIterator_out dl) = 0;
    virtual DomainManager_ptr domainMgr() = 0;
    virtual AllocationManager::AllocationResponseSequence* allocate(const ::CF::AllocationManager::AllocationRequestSequence& requests) = 0;
    virtual AllocationManager::AllocationResponseSequence* allocateLocal(const ::CF::AllocationManager::AllocationRequestSequence& requests, const char* domainName) = 0;
    virtual void deallocate(const ::CF::AllocationManager::allocationIDSequence& allocationIDs) = 0;
    virtual AllocationManager::AllocationStatusSequence* allocations(const ::CF::AllocationManager::allocationIDSequence& allocationIDs) = 0;
    virtual AllocationManager::AllocationStatusSequence* localAllocations(const ::CF::AllocationManager::allocationIDSequence& allocationIDs) = 0;
    virtual void listAllocations(::CF::AllocationManager::AllocationScopeType allocScope, ::CORBA::ULong how_many, ::CF::AllocationManager::AllocationStatusSequence_out allocs, ::CF::AllocationStatusIterator_out ai) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationManager;

#ifndef __CF_mAllocationStatusIterator__
#define __CF_mAllocationStatusIterator__
  class AllocationStatusIterator;
  class _objref_AllocationStatusIterator;
  class _impl_AllocationStatusIterator;
  
  typedef _objref_AllocationStatusIterator* AllocationStatusIterator_ptr;
  typedef AllocationStatusIterator_ptr AllocationStatusIteratorRef;

  class AllocationStatusIterator_Helper {
  public:
    typedef AllocationStatusIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_AllocationStatusIterator, AllocationStatusIterator_Helper> AllocationStatusIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_AllocationStatusIterator,AllocationStatusIterator_Helper > AllocationStatusIterator_out;

#endif

  // interface AllocationStatusIterator
  class AllocationStatusIterator {
  public:
    // Declarations for this interface type.
    typedef AllocationStatusIterator_ptr _ptr_type;
    typedef AllocationStatusIterator_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_AllocationStatusIterator :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Boolean next_one(::CF::AllocationManager::AllocationStatusType_out allocation);
    ::CORBA::Boolean next_n(::CORBA::ULong count, ::CF::AllocationManager::AllocationStatusSequence_out allocations);
    void destroy();

    // Constructors
    inline _objref_AllocationStatusIterator()  { _PR_setobj(0); }  // nil
    _objref_AllocationStatusIterator(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_AllocationStatusIterator();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_AllocationStatusIterator(const _objref_AllocationStatusIterator&);
    _objref_AllocationStatusIterator& operator = (const _objref_AllocationStatusIterator&);
    // not implemented

    friend class AllocationStatusIterator;
  };

  class _pof_AllocationStatusIterator : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_AllocationStatusIterator() : _OMNI_NS(proxyObjectFactory)(AllocationStatusIterator::_PD_repoId) {}
    virtual ~_pof_AllocationStatusIterator();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_AllocationStatusIterator :
    public virtual omniServant
  {
  public:
    virtual ~_impl_AllocationStatusIterator();

    virtual ::CORBA::Boolean next_one(::CF::AllocationManager::AllocationStatusType_out allocation) = 0;
    virtual ::CORBA::Boolean next_n(::CORBA::ULong count, ::CF::AllocationManager::AllocationStatusSequence_out allocations) = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AllocationStatusIterator;

#ifndef __CF_mDeviceLocationIterator__
#define __CF_mDeviceLocationIterator__
  class DeviceLocationIterator;
  class _objref_DeviceLocationIterator;
  class _impl_DeviceLocationIterator;
  
  typedef _objref_DeviceLocationIterator* DeviceLocationIterator_ptr;
  typedef DeviceLocationIterator_ptr DeviceLocationIteratorRef;

  class DeviceLocationIterator_Helper {
  public:
    typedef DeviceLocationIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceLocationIterator, DeviceLocationIterator_Helper> DeviceLocationIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceLocationIterator,DeviceLocationIterator_Helper > DeviceLocationIterator_out;

#endif

  // interface DeviceLocationIterator
  class DeviceLocationIterator {
  public:
    // Declarations for this interface type.
    typedef DeviceLocationIterator_ptr _ptr_type;
    typedef DeviceLocationIterator_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DeviceLocationIterator :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Boolean next_one(::CF::AllocationManager::DeviceLocationType_out deviceLocation);
    ::CORBA::Boolean next_n(::CORBA::ULong count, ::CF::AllocationManager::DeviceLocationSequence_out deviceLocations);
    void destroy();

    // Constructors
    inline _objref_DeviceLocationIterator()  { _PR_setobj(0); }  // nil
    _objref_DeviceLocationIterator(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DeviceLocationIterator();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DeviceLocationIterator(const _objref_DeviceLocationIterator&);
    _objref_DeviceLocationIterator& operator = (const _objref_DeviceLocationIterator&);
    // not implemented

    friend class DeviceLocationIterator;
  };

  class _pof_DeviceLocationIterator : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DeviceLocationIterator() : _OMNI_NS(proxyObjectFactory)(DeviceLocationIterator::_PD_repoId) {}
    virtual ~_pof_DeviceLocationIterator();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DeviceLocationIterator :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DeviceLocationIterator();

    virtual ::CORBA::Boolean next_one(::CF::AllocationManager::DeviceLocationType_out deviceLocation) = 0;
    virtual ::CORBA::Boolean next_n(::CORBA::ULong count, ::CF::AllocationManager::DeviceLocationSequence_out deviceLocations) = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceLocationIterator;

#ifndef __CF_mConnectionStatusIterator__
#define __CF_mConnectionStatusIterator__
  class ConnectionStatusIterator;
  class _objref_ConnectionStatusIterator;
  class _impl_ConnectionStatusIterator;
  
  typedef _objref_ConnectionStatusIterator* ConnectionStatusIterator_ptr;
  typedef ConnectionStatusIterator_ptr ConnectionStatusIteratorRef;

  class ConnectionStatusIterator_Helper {
  public:
    typedef ConnectionStatusIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ConnectionStatusIterator, ConnectionStatusIterator_Helper> ConnectionStatusIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ConnectionStatusIterator,ConnectionStatusIterator_Helper > ConnectionStatusIterator_out;

#endif

#ifndef __CF_mConnectionManager__
#define __CF_mConnectionManager__
  class ConnectionManager;
  class _objref_ConnectionManager;
  class _impl_ConnectionManager;
  
  typedef _objref_ConnectionManager* ConnectionManager_ptr;
  typedef ConnectionManager_ptr ConnectionManagerRef;

  class ConnectionManager_Helper {
  public:
    typedef ConnectionManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ConnectionManager, ConnectionManager_Helper> ConnectionManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ConnectionManager,ConnectionManager_Helper > ConnectionManager_out;

#endif

  // interface ConnectionManager
  class ConnectionManager {
  public:
    // Declarations for this interface type.
    typedef ConnectionManager_ptr _ptr_type;
    typedef ConnectionManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    enum EndpointKind { ENDPOINT_APPLICATION, ENDPOINT_DEVICE, ENDPOINT_SERVICE, ENDPOINT_EVENTCHANNEL, ENDPOINT_COMPONENT, ENDPOINT_DOMAINMANAGER, ENDPOINT_DEVICEMANAGER, ENDPOINT_OBJECTREF /*, __max_EndpointKind=0xffffffff */ };
    typedef EndpointKind& EndpointKind_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EndpointKind;

    class EndpointResolutionType {
    public:

      typedef _CORBA_ConstrType_Variable_Var<EndpointResolutionType> _var_type;

      

      EndpointResolutionType(): _pd__initialised(0) {
        _default();

    
      }
      
      EndpointResolutionType(const EndpointResolutionType& _value) : _pd__initialised(0) {
        if (_value._pd__initialised) {
          if ((_pd__default = _value._pd__default)) {
            _release_member();
          }
          else {
            switch(_value._pd__d) {
              case ENDPOINT_APPLICATION: applicationId(_value.applicationId()); break;

              case ENDPOINT_DEVICE: deviceId(_value.deviceId()); break;

              case ENDPOINT_COMPONENT: componentId(_value.componentId()); break;

              case ENDPOINT_SERVICE: serviceName(_value.serviceName()); break;

              case ENDPOINT_EVENTCHANNEL: channelName(_value.channelName()); break;

              case ENDPOINT_OBJECTREF: objectRef(_value.objectRef()); break;

              case ENDPOINT_DEVICEMANAGER: deviceMgrId(_value.deviceMgrId()); break;

              default: break;

          
            }
          }
          _pd__d = _value._pd__d;

    
          _pd__initialised = _value._pd__initialised;
        }
      }

      ~EndpointResolutionType() {
        _release_member();
      }

      EndpointResolutionType& operator=(const EndpointResolutionType& _value) {
        if (&_value != this) {
          if (_value._pd__initialised) {
            if ((_pd__default = _value._pd__default)) {
              _release_member();
            }
            else {
              switch(_value._pd__d) {
                case ENDPOINT_APPLICATION: applicationId(_value.applicationId()); break;

                case ENDPOINT_DEVICE: deviceId(_value.deviceId()); break;

                case ENDPOINT_COMPONENT: componentId(_value.componentId()); break;

                case ENDPOINT_SERVICE: serviceName(_value.serviceName()); break;

                case ENDPOINT_EVENTCHANNEL: channelName(_value.channelName()); break;

                case ENDPOINT_OBJECTREF: objectRef(_value.objectRef()); break;

                case ENDPOINT_DEVICEMANAGER: deviceMgrId(_value.deviceMgrId()); break;

                default: break;

            
              }
            }
            _pd__d = _value._pd__d;

    
            _pd__initialised = _value._pd__initialised;
          }
          else {
            _release_member();
          }
        }
        return *this;
      }

      EndpointKind _d() const { return _pd__d;}
      void _d(EndpointKind _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case ENDPOINT_APPLICATION: goto fail;
          case ENDPOINT_DEVICE: goto fail;
          case ENDPOINT_COMPONENT: goto fail;
          case ENDPOINT_SERVICE: goto fail;
          case ENDPOINT_EVENTCHANNEL: goto fail;
          case ENDPOINT_OBJECTREF: goto fail;
          case ENDPOINT_DEVICEMANAGER: goto fail;
          default:
          switch (_value){
            case ENDPOINT_APPLICATION: goto fail;
            case ENDPOINT_DEVICE: goto fail;
            case ENDPOINT_COMPONENT: goto fail;
            case ENDPOINT_SERVICE: goto fail;
            case ENDPOINT_EVENTCHANNEL: goto fail;
            case ENDPOINT_OBJECTREF: goto fail;
            case ENDPOINT_DEVICEMANAGER: goto fail;
            default: _pd__d = _value; return;
          }

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      void _default()
      {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DOMAINMANAGER;
        _pd__default = 1;
      }

    

      const char * applicationId () const { return  _pd_applicationId; }

      void applicationId(char* _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_APPLICATION;
        _pd__default = 0;
        _pd_applicationId = _value;
      }
      void applicationId(const char*  _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_APPLICATION;
        _pd__default = 0;
        _pd_applicationId = ::CORBA::string_dup(_value);
      }

      void applicationId(const ::CORBA::String_var& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_APPLICATION;
        _pd__default = 0;
        _pd_applicationId = ::CORBA::string_dup(_value.in());
      }
      void applicationId(const ::CORBA::String_member& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_APPLICATION;
        _pd__default = 0;
        _pd_applicationId = ::CORBA::string_dup(_value.in());
      }

      const char * deviceId () const { return  _pd_deviceId; }

      void deviceId(char* _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICE;
        _pd__default = 0;
        _pd_deviceId = _value;
      }
      void deviceId(const char*  _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICE;
        _pd__default = 0;
        _pd_deviceId = ::CORBA::string_dup(_value);
      }

      void deviceId(const ::CORBA::String_var& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICE;
        _pd__default = 0;
        _pd_deviceId = ::CORBA::string_dup(_value.in());
      }
      void deviceId(const ::CORBA::String_member& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICE;
        _pd__default = 0;
        _pd_deviceId = ::CORBA::string_dup(_value.in());
      }

      const char * componentId () const { return  _pd_componentId; }

      void componentId(char* _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_COMPONENT;
        _pd__default = 0;
        _pd_componentId = _value;
      }
      void componentId(const char*  _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_COMPONENT;
        _pd__default = 0;
        _pd_componentId = ::CORBA::string_dup(_value);
      }

      void componentId(const ::CORBA::String_var& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_COMPONENT;
        _pd__default = 0;
        _pd_componentId = ::CORBA::string_dup(_value.in());
      }
      void componentId(const ::CORBA::String_member& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_COMPONENT;
        _pd__default = 0;
        _pd_componentId = ::CORBA::string_dup(_value.in());
      }

      const char * serviceName () const { return  _pd_serviceName; }

      void serviceName(char* _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_SERVICE;
        _pd__default = 0;
        _pd_serviceName = _value;
      }
      void serviceName(const char*  _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_SERVICE;
        _pd__default = 0;
        _pd_serviceName = ::CORBA::string_dup(_value);
      }

      void serviceName(const ::CORBA::String_var& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_SERVICE;
        _pd__default = 0;
        _pd_serviceName = ::CORBA::string_dup(_value.in());
      }
      void serviceName(const ::CORBA::String_member& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_SERVICE;
        _pd__default = 0;
        _pd_serviceName = ::CORBA::string_dup(_value.in());
      }

      const char * channelName () const { return  _pd_channelName; }

      void channelName(char* _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_EVENTCHANNEL;
        _pd__default = 0;
        _pd_channelName = _value;
      }
      void channelName(const char*  _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_EVENTCHANNEL;
        _pd__default = 0;
        _pd_channelName = ::CORBA::string_dup(_value);
      }

      void channelName(const ::CORBA::String_var& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_EVENTCHANNEL;
        _pd__default = 0;
        _pd_channelName = ::CORBA::string_dup(_value.in());
      }
      void channelName(const ::CORBA::String_member& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_EVENTCHANNEL;
        _pd__default = 0;
        _pd_channelName = ::CORBA::string_dup(_value.in());
      }

      ::CORBA::Object_ptr objectRef () const { return _pd_objectRef; }
      void objectRef(::CORBA::Object_ptr _value) {
         _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_OBJECTREF;
        _pd__default = 0;
        ::CORBA::Object::_duplicate(_value);
        _pd_objectRef = _value;
      }
      void objectRef(const ::CORBA::Object_Member& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_OBJECTREF;
        _pd__default = 0;
        ::CORBA::Object::_duplicate(_value);
        _pd_objectRef = _value;
      }
      void objectRef(const ::CORBA::Object_var&  _value) {
         _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_OBJECTREF;
        _pd__default = 0;
        ::CORBA::Object::_duplicate(_value);
        _pd_objectRef = _value;
      }

      const char * deviceMgrId () const { return  _pd_deviceMgrId; }

      void deviceMgrId(char* _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICEMANAGER;
        _pd__default = 0;
        _pd_deviceMgrId = _value;
      }
      void deviceMgrId(const char*  _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICEMANAGER;
        _pd__default = 0;
        _pd_deviceMgrId = ::CORBA::string_dup(_value);
      }

      void deviceMgrId(const ::CORBA::String_var& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICEMANAGER;
        _pd__default = 0;
        _pd_deviceMgrId = ::CORBA::string_dup(_value.in());
      }
      void deviceMgrId(const ::CORBA::String_member& _value) {
        _release_member();
        _pd__initialised = 1;
        _pd__d = ENDPOINT_DEVICEMANAGER;
        _pd__default = 0;
        _pd_deviceMgrId = ::CORBA::string_dup(_value.in());
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      EndpointKind _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      union {
        char* _pd_applicationId;
        char* _pd_deviceId;
        char* _pd_componentId;
        char* _pd_serviceName;
        char* _pd_channelName;
        ::CORBA::Object_ptr _pd_objectRef;
        char* _pd_deviceMgrId;
    
      };
      void _release_member () {
        if (!_pd__initialised)
          return;

        switch(_pd__d) {
          case ENDPOINT_APPLICATION:

            ::CORBA::string_free(_pd_applicationId);


            break;

          case ENDPOINT_DEVICE:

            ::CORBA::string_free(_pd_deviceId);


            break;

          case ENDPOINT_COMPONENT:

            ::CORBA::string_free(_pd_componentId);


            break;

          case ENDPOINT_SERVICE:

            ::CORBA::string_free(_pd_serviceName);


            break;

          case ENDPOINT_EVENTCHANNEL:

            ::CORBA::string_free(_pd_channelName);


            break;

          case ENDPOINT_OBJECTREF:

            ::CORBA::release(_pd_objectRef);


            break;

          case ENDPOINT_DEVICEMANAGER:

            ::CORBA::string_free(_pd_deviceMgrId);


            break;

          default:
            
            break;


        } 
        _pd__initialised = 0;
      }

    
    };

    typedef EndpointResolutionType::_var_type EndpointResolutionType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< EndpointResolutionType,EndpointResolutionType_var > EndpointResolutionType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EndpointResolutionType;

    struct EndpointRequest {
      typedef _CORBA_ConstrType_Variable_Var<EndpointRequest> _var_type;

      
      EndpointResolutionType endpoint;

      ::CORBA::String_member portName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef EndpointRequest::_var_type EndpointRequest_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< EndpointRequest,EndpointRequest_var > EndpointRequest_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EndpointRequest;

    struct EndpointStatusType {
      typedef _CORBA_ConstrType_Variable_Var<EndpointStatusType> _var_type;

      
      ::CORBA::Object_Member endpointObject;

      ::CORBA::String_member portName;

      ::CORBA::String_member repositoryId;

      ::CORBA::String_member entityId;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef EndpointStatusType::_var_type EndpointStatusType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< EndpointStatusType,EndpointStatusType_var > EndpointStatusType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_EndpointStatusType;

    struct ConnectionStatusType {
      typedef _CORBA_ConstrType_Variable_Var<ConnectionStatusType> _var_type;

      
      EndpointStatusType providesEndpoint;

      EndpointStatusType usesEndpoint;

      ::CORBA::String_member connectionId;

      ::CORBA::String_member requesterId;

      ::CORBA::String_member connectionRecordId;

      ::CORBA::Boolean connected;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ConnectionStatusType::_var_type ConnectionStatusType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ConnectionStatusType,ConnectionStatusType_var > ConnectionStatusType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionStatusType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionStatusSequence;

    class ConnectionStatusSequence_var;

    class ConnectionStatusSequence : public _CORBA_Unbounded_Sequence< ConnectionStatusType >  {
    public:
      typedef ConnectionStatusSequence_var _var_type;
      inline ConnectionStatusSequence() {}
      inline ConnectionStatusSequence(const ConnectionStatusSequence& _s)
        : _CORBA_Unbounded_Sequence< ConnectionStatusType > (_s) {}

      inline ConnectionStatusSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ConnectionStatusType > (_max) {}
      inline ConnectionStatusSequence(_CORBA_ULong _max, _CORBA_ULong _len, ConnectionStatusType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ConnectionStatusType > (_max, _len, _val, _rel) {}

    

      inline ConnectionStatusSequence& operator = (const ConnectionStatusSequence& _s) {
        _CORBA_Unbounded_Sequence< ConnectionStatusType > ::operator=(_s);
        return *this;
      }
    };

    class ConnectionStatusSequence_out;

    class ConnectionStatusSequence_var {
    public:
      inline ConnectionStatusSequence_var() : _pd_seq(0) {}
      inline ConnectionStatusSequence_var(ConnectionStatusSequence* _s) : _pd_seq(_s) {}
      inline ConnectionStatusSequence_var(const ConnectionStatusSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ConnectionStatusSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ConnectionStatusSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ConnectionStatusSequence_var& operator = (ConnectionStatusSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ConnectionStatusSequence_var& operator = (const ConnectionStatusSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ConnectionStatusSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ConnectionStatusType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ConnectionStatusSequence* operator -> () { return _pd_seq; }
      inline const ConnectionStatusSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ConnectionStatusSequence& () const { return *_pd_seq; }
#else
      inline operator const ConnectionStatusSequence& () const { return *_pd_seq; }
      inline operator ConnectionStatusSequence& () { return *_pd_seq; }
#endif
        
      inline const ConnectionStatusSequence& in() const { return *_pd_seq; }
      inline ConnectionStatusSequence&       inout()    { return *_pd_seq; }
      inline ConnectionStatusSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ConnectionStatusSequence* _retn() { ConnectionStatusSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ConnectionStatusSequence_out;
      
    private:
      ConnectionStatusSequence* _pd_seq;
    };

    class ConnectionStatusSequence_out {
    public:
      inline ConnectionStatusSequence_out(ConnectionStatusSequence*& _s) : _data(_s) { _data = 0; }
      inline ConnectionStatusSequence_out(ConnectionStatusSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ConnectionStatusSequence*) 0; }
      inline ConnectionStatusSequence_out(const ConnectionStatusSequence_out& _s) : _data(_s._data) {}
      inline ConnectionStatusSequence_out& operator = (const ConnectionStatusSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ConnectionStatusSequence_out& operator = (ConnectionStatusSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ConnectionStatusSequence*&()  { return _data; }
      inline ConnectionStatusSequence*& ptr()       { return _data; }
      inline ConnectionStatusSequence* operator->() { return _data; }

      inline ConnectionStatusType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ConnectionStatusSequence*& _data;

    private:
      ConnectionStatusSequence_out();
      ConnectionStatusSequence_out& operator=(const ConnectionStatusSequence_var&);
    };

  
  };

  class _objref_ConnectionManager :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* connect(const ::CF::ConnectionManager::EndpointRequest& usesEndpoint, const ::CF::ConnectionManager::EndpointRequest& providesEndpoint, const char* requesterId, const char* connectionId);
    void disconnect(const char* connectionRecordId);
    ConnectionManager::ConnectionStatusSequence* connections();
    void listConnections(::CORBA::ULong how_many, ::CF::ConnectionManager::ConnectionStatusSequence_out connections, ::CF::ConnectionStatusIterator_out iter);

    // Constructors
    inline _objref_ConnectionManager()  { _PR_setobj(0); }  // nil
    _objref_ConnectionManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ConnectionManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ConnectionManager(const _objref_ConnectionManager&);
    _objref_ConnectionManager& operator = (const _objref_ConnectionManager&);
    // not implemented

    friend class ConnectionManager;
  };

  class _pof_ConnectionManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ConnectionManager() : _OMNI_NS(proxyObjectFactory)(ConnectionManager::_PD_repoId) {}
    virtual ~_pof_ConnectionManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ConnectionManager :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ConnectionManager();

    virtual char* connect(const ::CF::ConnectionManager::EndpointRequest& usesEndpoint, const ::CF::ConnectionManager::EndpointRequest& providesEndpoint, const char* requesterId, const char* connectionId) = 0;
    virtual void disconnect(const char* connectionRecordId) = 0;
    virtual ConnectionManager::ConnectionStatusSequence* connections() = 0;
    virtual void listConnections(::CORBA::ULong how_many, ::CF::ConnectionManager::ConnectionStatusSequence_out connections, ::CF::ConnectionStatusIterator_out iter) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionManager;

#ifndef __CF_mConnectionStatusIterator__
#define __CF_mConnectionStatusIterator__
  class ConnectionStatusIterator;
  class _objref_ConnectionStatusIterator;
  class _impl_ConnectionStatusIterator;
  
  typedef _objref_ConnectionStatusIterator* ConnectionStatusIterator_ptr;
  typedef ConnectionStatusIterator_ptr ConnectionStatusIteratorRef;

  class ConnectionStatusIterator_Helper {
  public:
    typedef ConnectionStatusIterator_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ConnectionStatusIterator, ConnectionStatusIterator_Helper> ConnectionStatusIterator_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ConnectionStatusIterator,ConnectionStatusIterator_Helper > ConnectionStatusIterator_out;

#endif

  // interface ConnectionStatusIterator
  class ConnectionStatusIterator {
  public:
    // Declarations for this interface type.
    typedef ConnectionStatusIterator_ptr _ptr_type;
    typedef ConnectionStatusIterator_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ConnectionStatusIterator :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Boolean next_one(::CF::ConnectionManager::ConnectionStatusType_out connection);
    ::CORBA::Boolean next_n(::CORBA::ULong count, ::CF::ConnectionManager::ConnectionStatusSequence_out connections);
    void destroy();

    // Constructors
    inline _objref_ConnectionStatusIterator()  { _PR_setobj(0); }  // nil
    _objref_ConnectionStatusIterator(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ConnectionStatusIterator();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ConnectionStatusIterator(const _objref_ConnectionStatusIterator&);
    _objref_ConnectionStatusIterator& operator = (const _objref_ConnectionStatusIterator&);
    // not implemented

    friend class ConnectionStatusIterator;
  };

  class _pof_ConnectionStatusIterator : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ConnectionStatusIterator() : _OMNI_NS(proxyObjectFactory)(ConnectionStatusIterator::_PD_repoId) {}
    virtual ~_pof_ConnectionStatusIterator();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ConnectionStatusIterator :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ConnectionStatusIterator();

    virtual ::CORBA::Boolean next_one(::CF::ConnectionManager::ConnectionStatusType_out connection) = 0;
    virtual ::CORBA::Boolean next_n(::CORBA::ULong count, ::CF::ConnectionManager::ConnectionStatusSequence_out connections) = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionStatusIterator;

#ifndef __CF_mApplicationFactory__
#define __CF_mApplicationFactory__
  class ApplicationFactory;
  class _objref_ApplicationFactory;
  class _impl_ApplicationFactory;
  
  typedef _objref_ApplicationFactory* ApplicationFactory_ptr;
  typedef ApplicationFactory_ptr ApplicationFactoryRef;

  class ApplicationFactory_Helper {
  public:
    typedef ApplicationFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ApplicationFactory, ApplicationFactory_Helper> ApplicationFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ApplicationFactory,ApplicationFactory_Helper > ApplicationFactory_out;

#endif

  // interface ApplicationFactory
  class ApplicationFactory {
  public:
    // Declarations for this interface type.
    typedef ApplicationFactory_ptr _ptr_type;
    typedef ApplicationFactory_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class CreateApplicationRequestError : public ::CORBA::UserException {
    public:
      
      DeviceAssignmentSequence invalidAssignments;

    

      inline CreateApplicationRequestError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      CreateApplicationRequestError(const CreateApplicationRequestError&);
      CreateApplicationRequestError(const DeviceAssignmentSequence i_invalidAssignments);
      CreateApplicationRequestError& operator=(const CreateApplicationRequestError&);
      virtual ~CreateApplicationRequestError();
      virtual void _raise() const;
      static CreateApplicationRequestError* _downcast(::CORBA::Exception*);
      static const CreateApplicationRequestError* _downcast(const ::CORBA::Exception*);
      static inline CreateApplicationRequestError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CreateApplicationRequestError;

    class CreateApplicationError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline CreateApplicationError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      CreateApplicationError(const CreateApplicationError&);
      CreateApplicationError(ErrorNumberType i_errorNumber, const char* i_msg);
      CreateApplicationError& operator=(const CreateApplicationError&);
      virtual ~CreateApplicationError();
      virtual void _raise() const;
      static CreateApplicationError* _downcast(::CORBA::Exception*);
      static const CreateApplicationError* _downcast(const ::CORBA::Exception*);
      static inline CreateApplicationError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CreateApplicationError;

    class CreateApplicationInsufficientCapacityError : public ::CORBA::UserException {
    public:
      
      FailedCapacities devicesAttempted;

      ::CORBA::String_member msg;

    

      inline CreateApplicationInsufficientCapacityError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      CreateApplicationInsufficientCapacityError(const CreateApplicationInsufficientCapacityError&);
      CreateApplicationInsufficientCapacityError(const FailedCapacities i_devicesAttempted, const char* i_msg);
      CreateApplicationInsufficientCapacityError& operator=(const CreateApplicationInsufficientCapacityError&);
      virtual ~CreateApplicationInsufficientCapacityError();
      virtual void _raise() const;
      static CreateApplicationInsufficientCapacityError* _downcast(::CORBA::Exception*);
      static const CreateApplicationInsufficientCapacityError* _downcast(const ::CORBA::Exception*);
      static inline CreateApplicationInsufficientCapacityError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CreateApplicationInsufficientCapacityError;

    class InvalidInitConfiguration : public ::CORBA::UserException {
    public:
      
      Properties invalidProperties;

    

      inline InvalidInitConfiguration() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidInitConfiguration(const InvalidInitConfiguration&);
      InvalidInitConfiguration(const Properties i_invalidProperties);
      InvalidInitConfiguration& operator=(const InvalidInitConfiguration&);
      virtual ~InvalidInitConfiguration();
      virtual void _raise() const;
      static InvalidInitConfiguration* _downcast(::CORBA::Exception*);
      static const InvalidInitConfiguration* _downcast(const ::CORBA::Exception*);
      static inline InvalidInitConfiguration* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidInitConfiguration;

  
  };

  class _objref_ApplicationFactory :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* name();
    char* identifier();
    char* softwareProfile();
    Application_ptr create(const char* name, const ::CF::Properties& initConfiguration, const ::CF::DeviceAssignmentSequence& deviceAssignments);

    // Constructors
    inline _objref_ApplicationFactory()  { _PR_setobj(0); }  // nil
    _objref_ApplicationFactory(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ApplicationFactory();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ApplicationFactory(const _objref_ApplicationFactory&);
    _objref_ApplicationFactory& operator = (const _objref_ApplicationFactory&);
    // not implemented

    friend class ApplicationFactory;
  };

  class _pof_ApplicationFactory : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ApplicationFactory() : _OMNI_NS(proxyObjectFactory)(ApplicationFactory::_PD_repoId) {}
    virtual ~_pof_ApplicationFactory();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ApplicationFactory :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ApplicationFactory();

    virtual char* name() = 0;
    virtual char* identifier() = 0;
    virtual char* softwareProfile() = 0;
    virtual Application_ptr create(const char* name, const ::CF::Properties& initConfiguration, const ::CF::DeviceAssignmentSequence& deviceAssignments) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationFactory;

#ifndef __CF_mDomainManager__
#define __CF_mDomainManager__
  class DomainManager;
  class _objref_DomainManager;
  class _impl_DomainManager;
  
  typedef _objref_DomainManager* DomainManager_ptr;
  typedef DomainManager_ptr DomainManagerRef;

  class DomainManager_Helper {
  public:
    typedef DomainManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DomainManager, DomainManager_Helper> DomainManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DomainManager,DomainManager_Helper > DomainManager_out;

#endif

  // interface DomainManager
  class DomainManager {
  public:
    // Declarations for this interface type.
    typedef DomainManager_ptr _ptr_type;
    typedef DomainManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class ApplicationInstallationError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline ApplicationInstallationError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ApplicationInstallationError(const ApplicationInstallationError&);
      ApplicationInstallationError(ErrorNumberType i_errorNumber, const char* i_msg);
      ApplicationInstallationError& operator=(const ApplicationInstallationError&);
      virtual ~ApplicationInstallationError();
      virtual void _raise() const;
      static ApplicationInstallationError* _downcast(::CORBA::Exception*);
      static const ApplicationInstallationError* _downcast(const ::CORBA::Exception*);
      static inline ApplicationInstallationError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationInstallationError;

    class ApplicationAlreadyInstalled : public ::CORBA::UserException {
    public:
      
      

      inline ApplicationAlreadyInstalled() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ApplicationAlreadyInstalled(const ApplicationAlreadyInstalled&);
      
      ApplicationAlreadyInstalled& operator=(const ApplicationAlreadyInstalled&);
      virtual ~ApplicationAlreadyInstalled();
      virtual void _raise() const;
      static ApplicationAlreadyInstalled* _downcast(::CORBA::Exception*);
      static const ApplicationAlreadyInstalled* _downcast(const ::CORBA::Exception*);
      static inline ApplicationAlreadyInstalled* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationAlreadyInstalled;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationSequence;

    class ApplicationSequence_var;

    class ApplicationSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper >  {
    public:
      typedef ApplicationSequence_var _var_type;
      inline ApplicationSequence() {}
      inline ApplicationSequence(const ApplicationSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > (_s) {}

      inline ApplicationSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > (_max) {}
      inline ApplicationSequence(_CORBA_ULong _max, _CORBA_ULong _len, Application_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > (_max, _len, _val, _rel) {}

    

      inline ApplicationSequence& operator = (const ApplicationSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > ::operator=(_s);
        return *this;
      }
    };

    class ApplicationSequence_out;

    class ApplicationSequence_var {
    public:
      inline ApplicationSequence_var() : _pd_seq(0) {}
      inline ApplicationSequence_var(ApplicationSequence* _s) : _pd_seq(_s) {}
      inline ApplicationSequence_var(const ApplicationSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ApplicationSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ApplicationSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ApplicationSequence_var& operator = (ApplicationSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ApplicationSequence_var& operator = (const ApplicationSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ApplicationSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_Application, Application_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ApplicationSequence* operator -> () { return _pd_seq; }
      inline const ApplicationSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ApplicationSequence& () const { return *_pd_seq; }
#else
      inline operator const ApplicationSequence& () const { return *_pd_seq; }
      inline operator ApplicationSequence& () { return *_pd_seq; }
#endif
        
      inline const ApplicationSequence& in() const { return *_pd_seq; }
      inline ApplicationSequence&       inout()    { return *_pd_seq; }
      inline ApplicationSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ApplicationSequence* _retn() { ApplicationSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ApplicationSequence_out;
      
    private:
      ApplicationSequence* _pd_seq;
    };

    class ApplicationSequence_out {
    public:
      inline ApplicationSequence_out(ApplicationSequence*& _s) : _data(_s) { _data = 0; }
      inline ApplicationSequence_out(ApplicationSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ApplicationSequence*) 0; }
      inline ApplicationSequence_out(const ApplicationSequence_out& _s) : _data(_s._data) {}
      inline ApplicationSequence_out& operator = (const ApplicationSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ApplicationSequence_out& operator = (ApplicationSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ApplicationSequence*&()  { return _data; }
      inline ApplicationSequence*& ptr()       { return _data; }
      inline ApplicationSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_Application, Application_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ApplicationSequence*& _data;

    private:
      ApplicationSequence_out();
      ApplicationSequence_out& operator=(const ApplicationSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationFactorySequence;

    class ApplicationFactorySequence_var;

    class ApplicationFactorySequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper >  {
    public:
      typedef ApplicationFactorySequence_var _var_type;
      inline ApplicationFactorySequence() {}
      inline ApplicationFactorySequence(const ApplicationFactorySequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > (_s) {}

      inline ApplicationFactorySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > (_max) {}
      inline ApplicationFactorySequence(_CORBA_ULong _max, _CORBA_ULong _len, ApplicationFactory_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > (_max, _len, _val, _rel) {}

    

      inline ApplicationFactorySequence& operator = (const ApplicationFactorySequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > ::operator=(_s);
        return *this;
      }
    };

    class ApplicationFactorySequence_out;

    class ApplicationFactorySequence_var {
    public:
      inline ApplicationFactorySequence_var() : _pd_seq(0) {}
      inline ApplicationFactorySequence_var(ApplicationFactorySequence* _s) : _pd_seq(_s) {}
      inline ApplicationFactorySequence_var(const ApplicationFactorySequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ApplicationFactorySequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ApplicationFactorySequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ApplicationFactorySequence_var& operator = (ApplicationFactorySequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ApplicationFactorySequence_var& operator = (const ApplicationFactorySequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ApplicationFactorySequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ApplicationFactorySequence* operator -> () { return _pd_seq; }
      inline const ApplicationFactorySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ApplicationFactorySequence& () const { return *_pd_seq; }
#else
      inline operator const ApplicationFactorySequence& () const { return *_pd_seq; }
      inline operator ApplicationFactorySequence& () { return *_pd_seq; }
#endif
        
      inline const ApplicationFactorySequence& in() const { return *_pd_seq; }
      inline ApplicationFactorySequence&       inout()    { return *_pd_seq; }
      inline ApplicationFactorySequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ApplicationFactorySequence* _retn() { ApplicationFactorySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ApplicationFactorySequence_out;
      
    private:
      ApplicationFactorySequence* _pd_seq;
    };

    class ApplicationFactorySequence_out {
    public:
      inline ApplicationFactorySequence_out(ApplicationFactorySequence*& _s) : _data(_s) { _data = 0; }
      inline ApplicationFactorySequence_out(ApplicationFactorySequence_var& _s)
        : _data(_s._pd_seq) { _s = (ApplicationFactorySequence*) 0; }
      inline ApplicationFactorySequence_out(const ApplicationFactorySequence_out& _s) : _data(_s._data) {}
      inline ApplicationFactorySequence_out& operator = (const ApplicationFactorySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ApplicationFactorySequence_out& operator = (ApplicationFactorySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ApplicationFactorySequence*&()  { return _data; }
      inline ApplicationFactorySequence*& ptr()       { return _data; }
      inline ApplicationFactorySequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ApplicationFactorySequence*& _data;

    private:
      ApplicationFactorySequence_out();
      ApplicationFactorySequence_out& operator=(const ApplicationFactorySequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceManagerSequence;

    class DeviceManagerSequence_var;

    class DeviceManagerSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper >  {
    public:
      typedef DeviceManagerSequence_var _var_type;
      inline DeviceManagerSequence() {}
      inline DeviceManagerSequence(const DeviceManagerSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > (_s) {}

      inline DeviceManagerSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > (_max) {}
      inline DeviceManagerSequence(_CORBA_ULong _max, _CORBA_ULong _len, DeviceManager_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > (_max, _len, _val, _rel) {}

    

      inline DeviceManagerSequence& operator = (const DeviceManagerSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > ::operator=(_s);
        return *this;
      }
    };

    class DeviceManagerSequence_out;

    class DeviceManagerSequence_var {
    public:
      inline DeviceManagerSequence_var() : _pd_seq(0) {}
      inline DeviceManagerSequence_var(DeviceManagerSequence* _s) : _pd_seq(_s) {}
      inline DeviceManagerSequence_var(const DeviceManagerSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new DeviceManagerSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~DeviceManagerSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline DeviceManagerSequence_var& operator = (DeviceManagerSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DeviceManagerSequence_var& operator = (const DeviceManagerSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new DeviceManagerSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DeviceManagerSequence* operator -> () { return _pd_seq; }
      inline const DeviceManagerSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DeviceManagerSequence& () const { return *_pd_seq; }
#else
      inline operator const DeviceManagerSequence& () const { return *_pd_seq; }
      inline operator DeviceManagerSequence& () { return *_pd_seq; }
#endif
        
      inline const DeviceManagerSequence& in() const { return *_pd_seq; }
      inline DeviceManagerSequence&       inout()    { return *_pd_seq; }
      inline DeviceManagerSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DeviceManagerSequence* _retn() { DeviceManagerSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DeviceManagerSequence_out;
      
    private:
      DeviceManagerSequence* _pd_seq;
    };

    class DeviceManagerSequence_out {
    public:
      inline DeviceManagerSequence_out(DeviceManagerSequence*& _s) : _data(_s) { _data = 0; }
      inline DeviceManagerSequence_out(DeviceManagerSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DeviceManagerSequence*) 0; }
      inline DeviceManagerSequence_out(const DeviceManagerSequence_out& _s) : _data(_s._data) {}
      inline DeviceManagerSequence_out& operator = (const DeviceManagerSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DeviceManagerSequence_out& operator = (DeviceManagerSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DeviceManagerSequence*&()  { return _data; }
      inline DeviceManagerSequence*& ptr()       { return _data; }
      inline DeviceManagerSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DeviceManagerSequence*& _data;

    private:
      DeviceManagerSequence_out();
      DeviceManagerSequence_out& operator=(const DeviceManagerSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DomainManagerSequence;

    class DomainManagerSequence_var;

    class DomainManagerSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_DomainManager, _CORBA_ObjRef_Element< _objref_DomainManager, DomainManager_Helper> , DomainManager_Helper >  {
    public:
      typedef DomainManagerSequence_var _var_type;
      inline DomainManagerSequence() {}
      inline DomainManagerSequence(const DomainManagerSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DomainManager, _CORBA_ObjRef_Element< _objref_DomainManager, DomainManager_Helper> , DomainManager_Helper > (_s) {}

      inline DomainManagerSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DomainManager, _CORBA_ObjRef_Element< _objref_DomainManager, DomainManager_Helper> , DomainManager_Helper > (_max) {}
      inline DomainManagerSequence(_CORBA_ULong _max, _CORBA_ULong _len, DomainManager_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DomainManager, _CORBA_ObjRef_Element< _objref_DomainManager, DomainManager_Helper> , DomainManager_Helper > (_max, _len, _val, _rel) {}

    

      inline DomainManagerSequence& operator = (const DomainManagerSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_DomainManager, _CORBA_ObjRef_Element< _objref_DomainManager, DomainManager_Helper> , DomainManager_Helper > ::operator=(_s);
        return *this;
      }
    };

    class DomainManagerSequence_out;

    class DomainManagerSequence_var {
    public:
      inline DomainManagerSequence_var() : _pd_seq(0) {}
      inline DomainManagerSequence_var(DomainManagerSequence* _s) : _pd_seq(_s) {}
      inline DomainManagerSequence_var(const DomainManagerSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new DomainManagerSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~DomainManagerSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline DomainManagerSequence_var& operator = (DomainManagerSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DomainManagerSequence_var& operator = (const DomainManagerSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new DomainManagerSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_DomainManager, DomainManager_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DomainManagerSequence* operator -> () { return _pd_seq; }
      inline const DomainManagerSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DomainManagerSequence& () const { return *_pd_seq; }
#else
      inline operator const DomainManagerSequence& () const { return *_pd_seq; }
      inline operator DomainManagerSequence& () { return *_pd_seq; }
#endif
        
      inline const DomainManagerSequence& in() const { return *_pd_seq; }
      inline DomainManagerSequence&       inout()    { return *_pd_seq; }
      inline DomainManagerSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DomainManagerSequence* _retn() { DomainManagerSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DomainManagerSequence_out;
      
    private:
      DomainManagerSequence* _pd_seq;
    };

    class DomainManagerSequence_out {
    public:
      inline DomainManagerSequence_out(DomainManagerSequence*& _s) : _data(_s) { _data = 0; }
      inline DomainManagerSequence_out(DomainManagerSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DomainManagerSequence*) 0; }
      inline DomainManagerSequence_out(const DomainManagerSequence_out& _s) : _data(_s._data) {}
      inline DomainManagerSequence_out& operator = (const DomainManagerSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DomainManagerSequence_out& operator = (DomainManagerSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DomainManagerSequence*&()  { return _data; }
      inline DomainManagerSequence*& ptr()       { return _data; }
      inline DomainManagerSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_DomainManager, DomainManager_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DomainManagerSequence*& _data;

    private:
      DomainManagerSequence_out();
      DomainManagerSequence_out& operator=(const DomainManagerSequence_var&);
    };

    class InvalidIdentifier : public ::CORBA::UserException {
    public:
      
      

      inline InvalidIdentifier() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidIdentifier(const InvalidIdentifier&);
      
      InvalidIdentifier& operator=(const InvalidIdentifier&);
      virtual ~InvalidIdentifier();
      virtual void _raise() const;
      static InvalidIdentifier* _downcast(::CORBA::Exception*);
      static const InvalidIdentifier* _downcast(const ::CORBA::Exception*);
      static inline InvalidIdentifier* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidIdentifier;

    class DeviceManagerNotRegistered : public ::CORBA::UserException {
    public:
      
      

      inline DeviceManagerNotRegistered() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      DeviceManagerNotRegistered(const DeviceManagerNotRegistered&);
      
      DeviceManagerNotRegistered& operator=(const DeviceManagerNotRegistered&);
      virtual ~DeviceManagerNotRegistered();
      virtual void _raise() const;
      static DeviceManagerNotRegistered* _downcast(::CORBA::Exception*);
      static const DeviceManagerNotRegistered* _downcast(const ::CORBA::Exception*);
      static inline DeviceManagerNotRegistered* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceManagerNotRegistered;

    class ApplicationUninstallationError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline ApplicationUninstallationError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ApplicationUninstallationError(const ApplicationUninstallationError&);
      ApplicationUninstallationError(ErrorNumberType i_errorNumber, const char* i_msg);
      ApplicationUninstallationError& operator=(const ApplicationUninstallationError&);
      virtual ~ApplicationUninstallationError();
      virtual void _raise() const;
      static ApplicationUninstallationError* _downcast(::CORBA::Exception*);
      static const ApplicationUninstallationError* _downcast(const ::CORBA::Exception*);
      static inline ApplicationUninstallationError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationUninstallationError;

    class RegisterError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline RegisterError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      RegisterError(const RegisterError&);
      RegisterError(ErrorNumberType i_errorNumber, const char* i_msg);
      RegisterError& operator=(const RegisterError&);
      virtual ~RegisterError();
      virtual void _raise() const;
      static RegisterError* _downcast(::CORBA::Exception*);
      static const RegisterError* _downcast(const ::CORBA::Exception*);
      static inline RegisterError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegisterError;

    class UnregisterError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline UnregisterError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnregisterError(const UnregisterError&);
      UnregisterError(ErrorNumberType i_errorNumber, const char* i_msg);
      UnregisterError& operator=(const UnregisterError&);
      virtual ~UnregisterError();
      virtual void _raise() const;
      static UnregisterError* _downcast(::CORBA::Exception*);
      static const UnregisterError* _downcast(const ::CORBA::Exception*);
      static inline UnregisterError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnregisterError;

    class AlreadyConnected : public ::CORBA::UserException {
    public:
      
      

      inline AlreadyConnected() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      AlreadyConnected(const AlreadyConnected&);
      
      AlreadyConnected& operator=(const AlreadyConnected&);
      virtual ~AlreadyConnected();
      virtual void _raise() const;
      static AlreadyConnected* _downcast(::CORBA::Exception*);
      static const AlreadyConnected* _downcast(const ::CORBA::Exception*);
      static inline AlreadyConnected* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlreadyConnected;

    class InvalidEventChannelName : public ::CORBA::UserException {
    public:
      
      

      inline InvalidEventChannelName() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidEventChannelName(const InvalidEventChannelName&);
      
      InvalidEventChannelName& operator=(const InvalidEventChannelName&);
      virtual ~InvalidEventChannelName();
      virtual void _raise() const;
      static InvalidEventChannelName* _downcast(::CORBA::Exception*);
      static const InvalidEventChannelName* _downcast(const ::CORBA::Exception*);
      static inline InvalidEventChannelName* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidEventChannelName;

    class NotConnected : public ::CORBA::UserException {
    public:
      
      

      inline NotConnected() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      NotConnected(const NotConnected&);
      
      NotConnected& operator=(const NotConnected&);
      virtual ~NotConnected();
      virtual void _raise() const;
      static NotConnected* _downcast(::CORBA::Exception*);
      static const NotConnected* _downcast(const ::CORBA::Exception*);
      static inline NotConnected* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_NotConnected;

  
  };

  class _objref_DomainManager :
    public virtual _objref_PropertyEmitter,
    public virtual _objref_Logging
  {
  public:
    // IDL operations
    char* domainManagerProfile();
    DomainManager::DeviceManagerSequence* deviceManagers();
    DomainManager::ApplicationSequence* applications();
    DomainManager::ApplicationFactorySequence* applicationFactories();
    FileManager_ptr fileMgr();
    AllocationManager_ptr allocationMgr();
    ConnectionManager_ptr connectionMgr();
    EventChannelManager_ptr eventChannelMgr();
    char* identifier();
    char* name();
    DomainManager::DomainManagerSequence* remoteDomainManagers();
    void registerDevice(::CF::Device_ptr registeringDevice, ::CF::DeviceManager_ptr registeredDeviceMgr);
    void registerDeviceManager(::CF::DeviceManager_ptr deviceMgr);
    void unregisterDeviceManager(::CF::DeviceManager_ptr deviceMgr);
    void unregisterDevice(::CF::Device_ptr unregisteringDevice);
    Application_ptr createApplication(const char* profileFileName, const char* name, const ::CF::Properties& initConfiguration, const ::CF::DeviceAssignmentSequence& deviceAssignments);
    void installApplication(const char* profileFileName);
    void uninstallApplication(const char* applicationId);
    void registerService(::CORBA::Object_ptr registeringService, ::CF::DeviceManager_ptr registeredDeviceMgr, const char* name);
    void unregisterService(::CORBA::Object_ptr unregisteringService, const char* name);
    void registerWithEventChannel(::CORBA::Object_ptr registeringObject, const char* registeringId, const char* eventChannelName);
    void unregisterFromEventChannel(const char* unregisteringId, const char* eventChannelName);
    void registerRemoteDomainManager(::CF::DomainManager_ptr registeringDomainManager);
    void unregisterRemoteDomainManager(::CF::DomainManager_ptr unregisteringDomainManager);

    // Constructors
    inline _objref_DomainManager()  { _PR_setobj(0); }  // nil
    _objref_DomainManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DomainManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DomainManager(const _objref_DomainManager&);
    _objref_DomainManager& operator = (const _objref_DomainManager&);
    // not implemented

    friend class DomainManager;
  };

  class _pof_DomainManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DomainManager() : _OMNI_NS(proxyObjectFactory)(DomainManager::_PD_repoId) {}
    virtual ~_pof_DomainManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DomainManager :
    public virtual _impl_PropertyEmitter,
    public virtual _impl_Logging
  {
  public:
    virtual ~_impl_DomainManager();

    virtual char* domainManagerProfile() = 0;
    virtual DomainManager::DeviceManagerSequence* deviceManagers() = 0;
    virtual DomainManager::ApplicationSequence* applications() = 0;
    virtual DomainManager::ApplicationFactorySequence* applicationFactories() = 0;
    virtual FileManager_ptr fileMgr() = 0;
    virtual AllocationManager_ptr allocationMgr() = 0;
    virtual ConnectionManager_ptr connectionMgr() = 0;
    virtual EventChannelManager_ptr eventChannelMgr() = 0;
    virtual char* identifier() = 0;
    virtual char* name() = 0;
    virtual DomainManager::DomainManagerSequence* remoteDomainManagers() = 0;
    virtual void registerDevice(::CF::Device_ptr registeringDevice, ::CF::DeviceManager_ptr registeredDeviceMgr) = 0;
    virtual void registerDeviceManager(::CF::DeviceManager_ptr deviceMgr) = 0;
    virtual void unregisterDeviceManager(::CF::DeviceManager_ptr deviceMgr) = 0;
    virtual void unregisterDevice(::CF::Device_ptr unregisteringDevice) = 0;
    virtual Application_ptr createApplication(const char* profileFileName, const char* name, const ::CF::Properties& initConfiguration, const ::CF::DeviceAssignmentSequence& deviceAssignments) = 0;
    virtual void installApplication(const char* profileFileName) = 0;
    virtual void uninstallApplication(const char* applicationId) = 0;
    virtual void registerService(::CORBA::Object_ptr registeringService, ::CF::DeviceManager_ptr registeredDeviceMgr, const char* name) = 0;
    virtual void unregisterService(::CORBA::Object_ptr unregisteringService, const char* name) = 0;
    virtual void registerWithEventChannel(::CORBA::Object_ptr registeringObject, const char* registeringId, const char* eventChannelName) = 0;
    virtual void unregisterFromEventChannel(const char* unregisteringId, const char* eventChannelName) = 0;
    virtual void registerRemoteDomainManager(::CF::DomainManager_ptr registeringDomainManager) = 0;
    virtual void unregisterRemoteDomainManager(::CF::DomainManager_ptr unregisteringDomainManager) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DomainManager;

#ifndef __CF_mPortSupplier__
#define __CF_mPortSupplier__
  class PortSupplier;
  class _objref_PortSupplier;
  class _impl_PortSupplier;
  
  typedef _objref_PortSupplier* PortSupplier_ptr;
  typedef PortSupplier_ptr PortSupplierRef;

  class PortSupplier_Helper {
  public:
    typedef PortSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PortSupplier, PortSupplier_Helper> PortSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PortSupplier,PortSupplier_Helper > PortSupplier_out;

#endif

  // interface PortSupplier
  class PortSupplier {
  public:
    // Declarations for this interface type.
    typedef PortSupplier_ptr _ptr_type;
    typedef PortSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class UnknownPort : public ::CORBA::UserException {
    public:
      
      

      inline UnknownPort() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnknownPort(const UnknownPort&);
      
      UnknownPort& operator=(const UnknownPort&);
      virtual ~UnknownPort();
      virtual void _raise() const;
      static UnknownPort* _downcast(::CORBA::Exception*);
      static const UnknownPort* _downcast(const ::CORBA::Exception*);
      static inline UnknownPort* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownPort;

  
  };

  class _objref_PortSupplier :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Object_ptr getPort(const char* name);

    // Constructors
    inline _objref_PortSupplier()  { _PR_setobj(0); }  // nil
    _objref_PortSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PortSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PortSupplier(const _objref_PortSupplier&);
    _objref_PortSupplier& operator = (const _objref_PortSupplier&);
    // not implemented

    friend class PortSupplier;
  };

  class _pof_PortSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PortSupplier() : _OMNI_NS(proxyObjectFactory)(PortSupplier::_PD_repoId) {}
    virtual ~_pof_PortSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PortSupplier :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PortSupplier();

    virtual ::CORBA::Object_ptr getPort(const char* name) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortSupplier;

#ifndef __CF_mPortSet__
#define __CF_mPortSet__
  class PortSet;
  class _objref_PortSet;
  class _impl_PortSet;
  
  typedef _objref_PortSet* PortSet_ptr;
  typedef PortSet_ptr PortSetRef;

  class PortSet_Helper {
  public:
    typedef PortSet_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PortSet, PortSet_Helper> PortSet_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PortSet,PortSet_Helper > PortSet_out;

#endif

  // interface PortSet
  class PortSet {
  public:
    // Declarations for this interface type.
    typedef PortSet_ptr _ptr_type;
    typedef PortSet_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct PortInfoType {
      typedef _CORBA_ConstrType_Variable_Var<PortInfoType> _var_type;

      
      ::CORBA::Object_Member obj_ptr;

      ::CORBA::String_member name;

      ::CORBA::String_member repid;

      ::CORBA::String_member description;

      ::CORBA::String_member direction;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef PortInfoType::_var_type PortInfoType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< PortInfoType,PortInfoType_var > PortInfoType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortInfoType;

    static _core_attr const char * DIRECTION_PROVIDES;

    static _core_attr const char * DIRECTION_USES;

    static _core_attr const char * DIRECTION_BIDIR;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortInfoSequence;

    class PortInfoSequence_var;

    class PortInfoSequence : public _CORBA_Unbounded_Sequence< PortInfoType >  {
    public:
      typedef PortInfoSequence_var _var_type;
      inline PortInfoSequence() {}
      inline PortInfoSequence(const PortInfoSequence& _s)
        : _CORBA_Unbounded_Sequence< PortInfoType > (_s) {}

      inline PortInfoSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< PortInfoType > (_max) {}
      inline PortInfoSequence(_CORBA_ULong _max, _CORBA_ULong _len, PortInfoType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< PortInfoType > (_max, _len, _val, _rel) {}

    

      inline PortInfoSequence& operator = (const PortInfoSequence& _s) {
        _CORBA_Unbounded_Sequence< PortInfoType > ::operator=(_s);
        return *this;
      }
    };

    class PortInfoSequence_out;

    class PortInfoSequence_var {
    public:
      inline PortInfoSequence_var() : _pd_seq(0) {}
      inline PortInfoSequence_var(PortInfoSequence* _s) : _pd_seq(_s) {}
      inline PortInfoSequence_var(const PortInfoSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new PortInfoSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~PortInfoSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline PortInfoSequence_var& operator = (PortInfoSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline PortInfoSequence_var& operator = (const PortInfoSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new PortInfoSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline PortInfoType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline PortInfoSequence* operator -> () { return _pd_seq; }
      inline const PortInfoSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator PortInfoSequence& () const { return *_pd_seq; }
#else
      inline operator const PortInfoSequence& () const { return *_pd_seq; }
      inline operator PortInfoSequence& () { return *_pd_seq; }
#endif
        
      inline const PortInfoSequence& in() const { return *_pd_seq; }
      inline PortInfoSequence&       inout()    { return *_pd_seq; }
      inline PortInfoSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline PortInfoSequence* _retn() { PortInfoSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class PortInfoSequence_out;
      
    private:
      PortInfoSequence* _pd_seq;
    };

    class PortInfoSequence_out {
    public:
      inline PortInfoSequence_out(PortInfoSequence*& _s) : _data(_s) { _data = 0; }
      inline PortInfoSequence_out(PortInfoSequence_var& _s)
        : _data(_s._pd_seq) { _s = (PortInfoSequence*) 0; }
      inline PortInfoSequence_out(const PortInfoSequence_out& _s) : _data(_s._data) {}
      inline PortInfoSequence_out& operator = (const PortInfoSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline PortInfoSequence_out& operator = (PortInfoSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator PortInfoSequence*&()  { return _data; }
      inline PortInfoSequence*& ptr()       { return _data; }
      inline PortInfoSequence* operator->() { return _data; }

      inline PortInfoType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      PortInfoSequence*& _data;

    private:
      PortInfoSequence_out();
      PortInfoSequence_out& operator=(const PortInfoSequence_var&);
    };

  
  };

  class _objref_PortSet :
    public virtual _objref_PortSupplier
  {
  public:
    // IDL operations
    PortSet::PortInfoSequence* getPortSet();

    // Constructors
    inline _objref_PortSet()  { _PR_setobj(0); }  // nil
    _objref_PortSet(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PortSet();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PortSet(const _objref_PortSet&);
    _objref_PortSet& operator = (const _objref_PortSet&);
    // not implemented

    friend class PortSet;
  };

  class _pof_PortSet : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PortSet() : _OMNI_NS(proxyObjectFactory)(PortSet::_PD_repoId) {}
    virtual ~_pof_PortSet();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PortSet :
    public virtual _impl_PortSupplier
  {
  public:
    virtual ~_impl_PortSet();

    virtual PortSet::PortInfoSequence* getPortSet() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortSet;

#ifndef __CF_mResource__
#define __CF_mResource__
  class Resource;
  class _objref_Resource;
  class _impl_Resource;
  
  typedef _objref_Resource* Resource_ptr;
  typedef Resource_ptr ResourceRef;

  class Resource_Helper {
  public:
    typedef Resource_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Resource, Resource_Helper> Resource_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Resource,Resource_Helper > Resource_out;

#endif

  // interface Resource
  class Resource {
  public:
    // Declarations for this interface type.
    typedef Resource_ptr _ptr_type;
    typedef Resource_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class StartError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline StartError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      StartError(const StartError&);
      StartError(ErrorNumberType i_errorNumber, const char* i_msg);
      StartError& operator=(const StartError&);
      virtual ~StartError();
      virtual void _raise() const;
      static StartError* _downcast(::CORBA::Exception*);
      static const StartError* _downcast(const ::CORBA::Exception*);
      static inline StartError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_StartError;

    class StopError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline StopError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      StopError(const StopError&);
      StopError(ErrorNumberType i_errorNumber, const char* i_msg);
      StopError& operator=(const StopError&);
      virtual ~StopError();
      virtual void _raise() const;
      static StopError* _downcast(::CORBA::Exception*);
      static const StopError* _downcast(const ::CORBA::Exception*);
      static inline StopError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_StopError;

  
  };

  class _objref_Resource :
    public virtual _objref_LifeCycle,
    public virtual _objref_TestableObject,
    public virtual _objref_PropertyEmitter,
    public virtual _objref_PortSet,
    public virtual _objref_Logging
  {
  public:
    // IDL operations
    char* identifier();
    ::CORBA::Boolean started();
    char* softwareProfile();
    void start();
    void stop();

    // Constructors
    inline _objref_Resource()  { _PR_setobj(0); }  // nil
    _objref_Resource(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Resource();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Resource(const _objref_Resource&);
    _objref_Resource& operator = (const _objref_Resource&);
    // not implemented

    friend class Resource;
  };

  class _pof_Resource : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Resource() : _OMNI_NS(proxyObjectFactory)(Resource::_PD_repoId) {}
    virtual ~_pof_Resource();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Resource :
    public virtual _impl_LifeCycle,
    public virtual _impl_TestableObject,
    public virtual _impl_PropertyEmitter,
    public virtual _impl_PortSet,
    public virtual _impl_Logging
  {
  public:
    virtual ~_impl_Resource();

    virtual char* identifier() = 0;
    virtual ::CORBA::Boolean started() = 0;
    virtual char* softwareProfile() = 0;
    virtual void start() = 0;
    virtual void stop() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Resource;

#ifndef __CF_mDevice__
#define __CF_mDevice__
  class Device;
  class _objref_Device;
  class _impl_Device;
  
  typedef _objref_Device* Device_ptr;
  typedef Device_ptr DeviceRef;

  class Device_Helper {
  public:
    typedef Device_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Device, Device_Helper> Device_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Device,Device_Helper > Device_out;

#endif

  // interface Device
  class Device {
  public:
    // Declarations for this interface type.
    typedef Device_ptr _ptr_type;
    typedef Device_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidState : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

    

      inline InvalidState() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidState(const InvalidState&);
      InvalidState(const char* i_msg);
      InvalidState& operator=(const InvalidState&);
      virtual ~InvalidState();
      virtual void _raise() const;
      static InvalidState* _downcast(::CORBA::Exception*);
      static const InvalidState* _downcast(const ::CORBA::Exception*);
      static inline InvalidState* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidState;

    class InvalidCapacity : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

      Properties capacities;

    

      inline InvalidCapacity() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidCapacity(const InvalidCapacity&);
      InvalidCapacity(const char* i_msg, const Properties i_capacities);
      InvalidCapacity& operator=(const InvalidCapacity&);
      virtual ~InvalidCapacity();
      virtual void _raise() const;
      static InvalidCapacity* _downcast(::CORBA::Exception*);
      static const InvalidCapacity* _downcast(const ::CORBA::Exception*);
      static inline InvalidCapacity* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidCapacity;

    class InsufficientCapacity : public ::CORBA::UserException {
    public:
      
      Properties insufficientCapacities;

      ::CORBA::String_member msg;

    

      inline InsufficientCapacity() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InsufficientCapacity(const InsufficientCapacity&);
      InsufficientCapacity(const Properties i_insufficientCapacities, const char* i_msg);
      InsufficientCapacity& operator=(const InsufficientCapacity&);
      virtual ~InsufficientCapacity();
      virtual void _raise() const;
      static InsufficientCapacity* _downcast(::CORBA::Exception*);
      static const InsufficientCapacity* _downcast(const ::CORBA::Exception*);
      static inline InsufficientCapacity* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InsufficientCapacity;

    enum AdminType { LOCKED, SHUTTING_DOWN, UNLOCKED /*, __max_AdminType=0xffffffff */ };
    typedef AdminType& AdminType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminType;

    enum OperationalType { ENABLED, DISABLED /*, __max_OperationalType=0xffffffff */ };
    typedef OperationalType& OperationalType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationalType;

    enum UsageType { IDLE, ACTIVE, BUSY /*, __max_UsageType=0xffffffff */ };
    typedef UsageType& UsageType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UsageType;

  
  };

  class _objref_Device :
    public virtual _objref_Resource
  {
  public:
    // IDL operations
    Device::UsageType usageState();
    Device::AdminType adminState();
    void adminState(::CF::Device::AdminType _v);
    Device::OperationalType operationalState();
    char* label();
    AggregateDevice_ptr compositeDevice();
    ::CORBA::Boolean allocateCapacity(const ::CF::Properties& capacities);
    void deallocateCapacity(const ::CF::Properties& capacities);

    // Constructors
    inline _objref_Device()  { _PR_setobj(0); }  // nil
    _objref_Device(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Device();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Device(const _objref_Device&);
    _objref_Device& operator = (const _objref_Device&);
    // not implemented

    friend class Device;
  };

  class _pof_Device : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Device() : _OMNI_NS(proxyObjectFactory)(Device::_PD_repoId) {}
    virtual ~_pof_Device();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Device :
    public virtual _impl_Resource
  {
  public:
    virtual ~_impl_Device();

    virtual Device::UsageType usageState() = 0;
    virtual Device::AdminType adminState() = 0;
    virtual void adminState(::CF::Device::AdminType _v) = 0;
    virtual Device::OperationalType operationalState() = 0;
    virtual char* label() = 0;
    virtual AggregateDevice_ptr compositeDevice() = 0;
    virtual ::CORBA::Boolean allocateCapacity(const ::CF::Properties& capacities) = 0;
    virtual void deallocateCapacity(const ::CF::Properties& capacities) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Device;

#ifndef __CF_mApplicationRegistrar__
#define __CF_mApplicationRegistrar__
  class ApplicationRegistrar;
  class _objref_ApplicationRegistrar;
  class _impl_ApplicationRegistrar;
  
  typedef _objref_ApplicationRegistrar* ApplicationRegistrar_ptr;
  typedef ApplicationRegistrar_ptr ApplicationRegistrarRef;

  class ApplicationRegistrar_Helper {
  public:
    typedef ApplicationRegistrar_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ApplicationRegistrar, ApplicationRegistrar_Helper> ApplicationRegistrar_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ApplicationRegistrar,ApplicationRegistrar_Helper > ApplicationRegistrar_out;

#endif

  // interface ApplicationRegistrar
  class ApplicationRegistrar {
  public:
    // Declarations for this interface type.
    typedef ApplicationRegistrar_ptr _ptr_type;
    typedef ApplicationRegistrar_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ApplicationRegistrar :
    public virtual CosNaming::_objref_NamingContext
  {
  public:
    // IDL operations
    Application_ptr app();
    DomainManager_ptr domMgr();
    void registerComponent(const char* Name, ::CF::Resource_ptr obj);

    // Constructors
    inline _objref_ApplicationRegistrar()  { _PR_setobj(0); }  // nil
    _objref_ApplicationRegistrar(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ApplicationRegistrar();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ApplicationRegistrar(const _objref_ApplicationRegistrar&);
    _objref_ApplicationRegistrar& operator = (const _objref_ApplicationRegistrar&);
    // not implemented

    friend class ApplicationRegistrar;
  };

  class _pof_ApplicationRegistrar : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ApplicationRegistrar() : _OMNI_NS(proxyObjectFactory)(ApplicationRegistrar::_PD_repoId) {}
    virtual ~_pof_ApplicationRegistrar();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ApplicationRegistrar :
    public virtual CosNaming::_impl_NamingContext
  {
  public:
    virtual ~_impl_ApplicationRegistrar();

    virtual Application_ptr app() = 0;
    virtual DomainManager_ptr domMgr() = 0;
    virtual void registerComponent(const char* Name, ::CF::Resource_ptr obj) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationRegistrar;

#ifndef __CF_mApplication__
#define __CF_mApplication__
  class Application;
  class _objref_Application;
  class _impl_Application;
  
  typedef _objref_Application* Application_ptr;
  typedef Application_ptr ApplicationRef;

  class Application_Helper {
  public:
    typedef Application_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Application, Application_Helper> Application_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Application,Application_Helper > Application_out;

#endif

  // interface Application
  class Application {
  public:
    // Declarations for this interface type.
    typedef Application_ptr _ptr_type;
    typedef Application_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct ComponentProcessIdType {
      typedef _CORBA_ConstrType_Variable_Var<ComponentProcessIdType> _var_type;

      
      ::CORBA::String_member componentId;

      ::CORBA::ULong processId;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ComponentProcessIdType::_var_type ComponentProcessIdType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentProcessIdType,ComponentProcessIdType_var > ComponentProcessIdType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentProcessIdType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentProcessIdSequence;

    class ComponentProcessIdSequence_var;

    class ComponentProcessIdSequence : public _CORBA_Unbounded_Sequence< ComponentProcessIdType >  {
    public:
      typedef ComponentProcessIdSequence_var _var_type;
      inline ComponentProcessIdSequence() {}
      inline ComponentProcessIdSequence(const ComponentProcessIdSequence& _s)
        : _CORBA_Unbounded_Sequence< ComponentProcessIdType > (_s) {}

      inline ComponentProcessIdSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ComponentProcessIdType > (_max) {}
      inline ComponentProcessIdSequence(_CORBA_ULong _max, _CORBA_ULong _len, ComponentProcessIdType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ComponentProcessIdType > (_max, _len, _val, _rel) {}

    

      inline ComponentProcessIdSequence& operator = (const ComponentProcessIdSequence& _s) {
        _CORBA_Unbounded_Sequence< ComponentProcessIdType > ::operator=(_s);
        return *this;
      }
    };

    class ComponentProcessIdSequence_out;

    class ComponentProcessIdSequence_var {
    public:
      inline ComponentProcessIdSequence_var() : _pd_seq(0) {}
      inline ComponentProcessIdSequence_var(ComponentProcessIdSequence* _s) : _pd_seq(_s) {}
      inline ComponentProcessIdSequence_var(const ComponentProcessIdSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ComponentProcessIdSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ComponentProcessIdSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ComponentProcessIdSequence_var& operator = (ComponentProcessIdSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ComponentProcessIdSequence_var& operator = (const ComponentProcessIdSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ComponentProcessIdSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ComponentProcessIdType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ComponentProcessIdSequence* operator -> () { return _pd_seq; }
      inline const ComponentProcessIdSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ComponentProcessIdSequence& () const { return *_pd_seq; }
#else
      inline operator const ComponentProcessIdSequence& () const { return *_pd_seq; }
      inline operator ComponentProcessIdSequence& () { return *_pd_seq; }
#endif
        
      inline const ComponentProcessIdSequence& in() const { return *_pd_seq; }
      inline ComponentProcessIdSequence&       inout()    { return *_pd_seq; }
      inline ComponentProcessIdSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ComponentProcessIdSequence* _retn() { ComponentProcessIdSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ComponentProcessIdSequence_out;
      
    private:
      ComponentProcessIdSequence* _pd_seq;
    };

    class ComponentProcessIdSequence_out {
    public:
      inline ComponentProcessIdSequence_out(ComponentProcessIdSequence*& _s) : _data(_s) { _data = 0; }
      inline ComponentProcessIdSequence_out(ComponentProcessIdSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ComponentProcessIdSequence*) 0; }
      inline ComponentProcessIdSequence_out(const ComponentProcessIdSequence_out& _s) : _data(_s._data) {}
      inline ComponentProcessIdSequence_out& operator = (const ComponentProcessIdSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ComponentProcessIdSequence_out& operator = (ComponentProcessIdSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ComponentProcessIdSequence*&()  { return _data; }
      inline ComponentProcessIdSequence*& ptr()       { return _data; }
      inline ComponentProcessIdSequence* operator->() { return _data; }

      inline ComponentProcessIdType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ComponentProcessIdSequence*& _data;

    private:
      ComponentProcessIdSequence_out();
      ComponentProcessIdSequence_out& operator=(const ComponentProcessIdSequence_var&);
    };

    struct ComponentElementType {
      typedef _CORBA_ConstrType_Variable_Var<ComponentElementType> _var_type;

      
      ::CORBA::String_member componentId;

      ::CORBA::String_member elementId;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ComponentElementType::_var_type ComponentElementType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentElementType,ComponentElementType_var > ComponentElementType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentElementType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentElementSequence;

    class ComponentElementSequence_var;

    class ComponentElementSequence : public _CORBA_Unbounded_Sequence< ComponentElementType >  {
    public:
      typedef ComponentElementSequence_var _var_type;
      inline ComponentElementSequence() {}
      inline ComponentElementSequence(const ComponentElementSequence& _s)
        : _CORBA_Unbounded_Sequence< ComponentElementType > (_s) {}

      inline ComponentElementSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ComponentElementType > (_max) {}
      inline ComponentElementSequence(_CORBA_ULong _max, _CORBA_ULong _len, ComponentElementType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ComponentElementType > (_max, _len, _val, _rel) {}

    

      inline ComponentElementSequence& operator = (const ComponentElementSequence& _s) {
        _CORBA_Unbounded_Sequence< ComponentElementType > ::operator=(_s);
        return *this;
      }
    };

    class ComponentElementSequence_out;

    class ComponentElementSequence_var {
    public:
      inline ComponentElementSequence_var() : _pd_seq(0) {}
      inline ComponentElementSequence_var(ComponentElementSequence* _s) : _pd_seq(_s) {}
      inline ComponentElementSequence_var(const ComponentElementSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ComponentElementSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ComponentElementSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ComponentElementSequence_var& operator = (ComponentElementSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ComponentElementSequence_var& operator = (const ComponentElementSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ComponentElementSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ComponentElementType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ComponentElementSequence* operator -> () { return _pd_seq; }
      inline const ComponentElementSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ComponentElementSequence& () const { return *_pd_seq; }
#else
      inline operator const ComponentElementSequence& () const { return *_pd_seq; }
      inline operator ComponentElementSequence& () { return *_pd_seq; }
#endif
        
      inline const ComponentElementSequence& in() const { return *_pd_seq; }
      inline ComponentElementSequence&       inout()    { return *_pd_seq; }
      inline ComponentElementSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ComponentElementSequence* _retn() { ComponentElementSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ComponentElementSequence_out;
      
    private:
      ComponentElementSequence* _pd_seq;
    };

    class ComponentElementSequence_out {
    public:
      inline ComponentElementSequence_out(ComponentElementSequence*& _s) : _data(_s) { _data = 0; }
      inline ComponentElementSequence_out(ComponentElementSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ComponentElementSequence*) 0; }
      inline ComponentElementSequence_out(const ComponentElementSequence_out& _s) : _data(_s._data) {}
      inline ComponentElementSequence_out& operator = (const ComponentElementSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ComponentElementSequence_out& operator = (ComponentElementSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ComponentElementSequence*&()  { return _data; }
      inline ComponentElementSequence*& ptr()       { return _data; }
      inline ComponentElementSequence* operator->() { return _data; }

      inline ComponentElementType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ComponentElementSequence*& _data;

    private:
      ComponentElementSequence_out();
      ComponentElementSequence_out& operator=(const ComponentElementSequence_var&);
    };

    class InvalidMetric : public ::CORBA::UserException {
    public:
      
      StringSequence components;

      StringSequence attributes;

    

      inline InvalidMetric() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidMetric(const InvalidMetric&);
      InvalidMetric(const StringSequence i_components, const StringSequence i_attributes);
      InvalidMetric& operator=(const InvalidMetric&);
      virtual ~InvalidMetric();
      virtual void _raise() const;
      static InvalidMetric* _downcast(::CORBA::Exception*);
      static const InvalidMetric* _downcast(const ::CORBA::Exception*);
      static inline InvalidMetric* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidMetric;

  
  };

  class _objref_Application :
    public virtual _objref_Resource
  {
  public:
    // IDL operations
    Components* registeredComponents();
    Application::ComponentElementSequence* componentNamingContexts();
    Application::ComponentProcessIdSequence* componentProcessIds();
    DeviceAssignmentSequence* componentDevices();
    Application::ComponentElementSequence* componentImplementations();
    char* profile();
    char* name();
    ::CORBA::Boolean aware();
    ::CORBA::Float stopTimeout();
    void stopTimeout(::CORBA::Float _v);
    Properties* metrics(const ::CF::StringSequence& components, const ::CF::StringSequence& attributes);

    // Constructors
    inline _objref_Application()  { _PR_setobj(0); }  // nil
    _objref_Application(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Application();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Application(const _objref_Application&);
    _objref_Application& operator = (const _objref_Application&);
    // not implemented

    friend class Application;
  };

  class _pof_Application : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Application() : _OMNI_NS(proxyObjectFactory)(Application::_PD_repoId) {}
    virtual ~_pof_Application();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Application :
    public virtual _impl_Resource
  {
  public:
    virtual ~_impl_Application();

    virtual Components* registeredComponents() = 0;
    virtual Application::ComponentElementSequence* componentNamingContexts() = 0;
    virtual Application::ComponentProcessIdSequence* componentProcessIds() = 0;
    virtual DeviceAssignmentSequence* componentDevices() = 0;
    virtual Application::ComponentElementSequence* componentImplementations() = 0;
    virtual char* profile() = 0;
    virtual char* name() = 0;
    virtual ::CORBA::Boolean aware() = 0;
    virtual ::CORBA::Float stopTimeout() = 0;
    virtual void stopTimeout(::CORBA::Float _v) = 0;
    virtual Properties* metrics(const ::CF::StringSequence& components, const ::CF::StringSequence& attributes) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Application;

#ifndef __CF_mLoadableDevice__
#define __CF_mLoadableDevice__
  class LoadableDevice;
  class _objref_LoadableDevice;
  class _impl_LoadableDevice;
  
  typedef _objref_LoadableDevice* LoadableDevice_ptr;
  typedef LoadableDevice_ptr LoadableDeviceRef;

  class LoadableDevice_Helper {
  public:
    typedef LoadableDevice_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LoadableDevice, LoadableDevice_Helper> LoadableDevice_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LoadableDevice,LoadableDevice_Helper > LoadableDevice_out;

#endif

  // interface LoadableDevice
  class LoadableDevice {
  public:
    // Declarations for this interface type.
    typedef LoadableDevice_ptr _ptr_type;
    typedef LoadableDevice_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    enum LoadType { KERNEL_MODULE, DRIVER, SHARED_LIBRARY, EXECUTABLE /*, __max_LoadType=0xffffffff */ };
    typedef LoadType& LoadType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_LoadType;

    class InvalidLoadKind : public ::CORBA::UserException {
    public:
      
      

      inline InvalidLoadKind() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidLoadKind(const InvalidLoadKind&);
      
      InvalidLoadKind& operator=(const InvalidLoadKind&);
      virtual ~InvalidLoadKind();
      virtual void _raise() const;
      static InvalidLoadKind* _downcast(::CORBA::Exception*);
      static const InvalidLoadKind* _downcast(const ::CORBA::Exception*);
      static inline InvalidLoadKind* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidLoadKind;

    class LoadFail : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline LoadFail() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      LoadFail(const LoadFail&);
      LoadFail(ErrorNumberType i_errorNumber, const char* i_msg);
      LoadFail& operator=(const LoadFail&);
      virtual ~LoadFail();
      virtual void _raise() const;
      static LoadFail* _downcast(::CORBA::Exception*);
      static const LoadFail* _downcast(const ::CORBA::Exception*);
      static inline LoadFail* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_LoadFail;

  
  };

  class _objref_LoadableDevice :
    public virtual _objref_Device
  {
  public:
    // IDL operations
    void load(::CF::FileSystem_ptr fs, const char* fileName, ::CF::LoadableDevice::LoadType loadKind);
    void unload(const char* fileName);

    // Constructors
    inline _objref_LoadableDevice()  { _PR_setobj(0); }  // nil
    _objref_LoadableDevice(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LoadableDevice();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LoadableDevice(const _objref_LoadableDevice&);
    _objref_LoadableDevice& operator = (const _objref_LoadableDevice&);
    // not implemented

    friend class LoadableDevice;
  };

  class _pof_LoadableDevice : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LoadableDevice() : _OMNI_NS(proxyObjectFactory)(LoadableDevice::_PD_repoId) {}
    virtual ~_pof_LoadableDevice();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LoadableDevice :
    public virtual _impl_Device
  {
  public:
    virtual ~_impl_LoadableDevice();

    virtual void load(::CF::FileSystem_ptr fs, const char* fileName, ::CF::LoadableDevice::LoadType loadKind) = 0;
    virtual void unload(const char* fileName) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LoadableDevice;

#ifndef __CF_mExecutableDevice__
#define __CF_mExecutableDevice__
  class ExecutableDevice;
  class _objref_ExecutableDevice;
  class _impl_ExecutableDevice;
  
  typedef _objref_ExecutableDevice* ExecutableDevice_ptr;
  typedef ExecutableDevice_ptr ExecutableDeviceRef;

  class ExecutableDevice_Helper {
  public:
    typedef ExecutableDevice_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ExecutableDevice, ExecutableDevice_Helper> ExecutableDevice_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ExecutableDevice,ExecutableDevice_Helper > ExecutableDevice_out;

#endif

  // interface ExecutableDevice
  class ExecutableDevice {
  public:
    // Declarations for this interface type.
    typedef ExecutableDevice_ptr _ptr_type;
    typedef ExecutableDevice_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidProcess : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline InvalidProcess() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidProcess(const InvalidProcess&);
      InvalidProcess(ErrorNumberType i_errorNumber, const char* i_msg);
      InvalidProcess& operator=(const InvalidProcess&);
      virtual ~InvalidProcess();
      virtual void _raise() const;
      static InvalidProcess* _downcast(::CORBA::Exception*);
      static const InvalidProcess* _downcast(const ::CORBA::Exception*);
      static inline InvalidProcess* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidProcess;

    class InvalidFunction : public ::CORBA::UserException {
    public:
      
      

      inline InvalidFunction() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidFunction(const InvalidFunction&);
      
      InvalidFunction& operator=(const InvalidFunction&);
      virtual ~InvalidFunction();
      virtual void _raise() const;
      static InvalidFunction* _downcast(::CORBA::Exception*);
      static const InvalidFunction* _downcast(const ::CORBA::Exception*);
      static inline InvalidFunction* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFunction;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProcessID_Type;

    typedef ::CORBA::Long ProcessID_Type;
    typedef ::CORBA::Long_out ProcessID_Type_out;

    class InvalidParameters : public ::CORBA::UserException {
    public:
      
      Properties invalidParms;

    

      inline InvalidParameters() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidParameters(const InvalidParameters&);
      InvalidParameters(const Properties i_invalidParms);
      InvalidParameters& operator=(const InvalidParameters&);
      virtual ~InvalidParameters();
      virtual void _raise() const;
      static InvalidParameters* _downcast(::CORBA::Exception*);
      static const InvalidParameters* _downcast(const ::CORBA::Exception*);
      static inline InvalidParameters* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidParameters;

    class InvalidOptions : public ::CORBA::UserException {
    public:
      
      Properties invalidOpts;

    

      inline InvalidOptions() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidOptions(const InvalidOptions&);
      InvalidOptions(const Properties i_invalidOpts);
      InvalidOptions& operator=(const InvalidOptions&);
      virtual ~InvalidOptions();
      virtual void _raise() const;
      static InvalidOptions* _downcast(::CORBA::Exception*);
      static const InvalidOptions* _downcast(const ::CORBA::Exception*);
      static inline InvalidOptions* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidOptions;

    static _core_attr const char * STACK_SIZE_ID;

    static _core_attr const char * PRIORITY_ID;

    class ExecuteFail : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline ExecuteFail() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ExecuteFail(const ExecuteFail&);
      ExecuteFail(ErrorNumberType i_errorNumber, const char* i_msg);
      ExecuteFail& operator=(const ExecuteFail&);
      virtual ~ExecuteFail();
      virtual void _raise() const;
      static ExecuteFail* _downcast(::CORBA::Exception*);
      static const ExecuteFail* _downcast(const ::CORBA::Exception*);
      static inline ExecuteFail* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecuteFail;

  
  };

  class _objref_ExecutableDevice :
    public virtual _objref_LoadableDevice
  {
  public:
    // IDL operations
    void terminate(::CF::ExecutableDevice::ProcessID_Type processId);
    ExecutableDevice::ProcessID_Type execute(const char* name, const ::CF::Properties& options, const ::CF::Properties& parameters);
    ExecutableDevice::ProcessID_Type executeLinked(const char* name, const ::CF::Properties& options, const ::CF::Properties& parameters, const ::CF::StringSequence& deps);

    // Constructors
    inline _objref_ExecutableDevice()  { _PR_setobj(0); }  // nil
    _objref_ExecutableDevice(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ExecutableDevice();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ExecutableDevice(const _objref_ExecutableDevice&);
    _objref_ExecutableDevice& operator = (const _objref_ExecutableDevice&);
    // not implemented

    friend class ExecutableDevice;
  };

  class _pof_ExecutableDevice : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ExecutableDevice() : _OMNI_NS(proxyObjectFactory)(ExecutableDevice::_PD_repoId) {}
    virtual ~_pof_ExecutableDevice();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ExecutableDevice :
    public virtual _impl_LoadableDevice
  {
  public:
    virtual ~_impl_ExecutableDevice();

    virtual void terminate(::CF::ExecutableDevice::ProcessID_Type processId) = 0;
    virtual ExecutableDevice::ProcessID_Type execute(const char* name, const ::CF::Properties& options, const ::CF::Properties& parameters) = 0;
    virtual ExecutableDevice::ProcessID_Type executeLinked(const char* name, const ::CF::Properties& options, const ::CF::Properties& parameters, const ::CF::StringSequence& deps) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutableDevice;

#ifndef __CF_mDeviceManager__
#define __CF_mDeviceManager__
  class DeviceManager;
  class _objref_DeviceManager;
  class _impl_DeviceManager;
  
  typedef _objref_DeviceManager* DeviceManager_ptr;
  typedef DeviceManager_ptr DeviceManagerRef;

  class DeviceManager_Helper {
  public:
    typedef DeviceManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceManager, DeviceManager_Helper> DeviceManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceManager,DeviceManager_Helper > DeviceManager_out;

#endif

  // interface DeviceManager
  class DeviceManager {
  public:
    // Declarations for this interface type.
    typedef DeviceManager_ptr _ptr_type;
    typedef DeviceManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct ServiceType {
      typedef _CORBA_ConstrType_Variable_Var<ServiceType> _var_type;

      
      ::CORBA::Object_Member serviceObject;

      ::CORBA::String_member serviceName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ServiceType::_var_type ServiceType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ServiceType,ServiceType_var > ServiceType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ServiceType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ServiceSequence;

    class ServiceSequence_var;

    class ServiceSequence : public _CORBA_Unbounded_Sequence< ServiceType >  {
    public:
      typedef ServiceSequence_var _var_type;
      inline ServiceSequence() {}
      inline ServiceSequence(const ServiceSequence& _s)
        : _CORBA_Unbounded_Sequence< ServiceType > (_s) {}

      inline ServiceSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ServiceType > (_max) {}
      inline ServiceSequence(_CORBA_ULong _max, _CORBA_ULong _len, ServiceType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ServiceType > (_max, _len, _val, _rel) {}

    

      inline ServiceSequence& operator = (const ServiceSequence& _s) {
        _CORBA_Unbounded_Sequence< ServiceType > ::operator=(_s);
        return *this;
      }
    };

    class ServiceSequence_out;

    class ServiceSequence_var {
    public:
      inline ServiceSequence_var() : _pd_seq(0) {}
      inline ServiceSequence_var(ServiceSequence* _s) : _pd_seq(_s) {}
      inline ServiceSequence_var(const ServiceSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ServiceSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ServiceSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ServiceSequence_var& operator = (ServiceSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ServiceSequence_var& operator = (const ServiceSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ServiceSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ServiceType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ServiceSequence* operator -> () { return _pd_seq; }
      inline const ServiceSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ServiceSequence& () const { return *_pd_seq; }
#else
      inline operator const ServiceSequence& () const { return *_pd_seq; }
      inline operator ServiceSequence& () { return *_pd_seq; }
#endif
        
      inline const ServiceSequence& in() const { return *_pd_seq; }
      inline ServiceSequence&       inout()    { return *_pd_seq; }
      inline ServiceSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ServiceSequence* _retn() { ServiceSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ServiceSequence_out;
      
    private:
      ServiceSequence* _pd_seq;
    };

    class ServiceSequence_out {
    public:
      inline ServiceSequence_out(ServiceSequence*& _s) : _data(_s) { _data = 0; }
      inline ServiceSequence_out(ServiceSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ServiceSequence*) 0; }
      inline ServiceSequence_out(const ServiceSequence_out& _s) : _data(_s._data) {}
      inline ServiceSequence_out& operator = (const ServiceSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ServiceSequence_out& operator = (ServiceSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ServiceSequence*&()  { return _data; }
      inline ServiceSequence*& ptr()       { return _data; }
      inline ServiceSequence* operator->() { return _data; }

      inline ServiceType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ServiceSequence*& _data;

    private:
      ServiceSequence_out();
      ServiceSequence_out& operator=(const ServiceSequence_var&);
    };

  
  };

  class _objref_DeviceManager :
    public virtual _objref_PropertyEmitter,
    public virtual _objref_PortSet,
    public virtual _objref_Logging
  {
  public:
    // IDL operations
    char* deviceConfigurationProfile();
    FileSystem_ptr fileSys();
    char* identifier();
    char* label();
    DomainManager_ptr domMgr();
    DeviceSequence* registeredDevices();
    DeviceManager::ServiceSequence* registeredServices();
    void registerDevice(::CF::Device_ptr registeringDevice);
    void unregisterDevice(::CF::Device_ptr registeredDevice);
    void shutdown();
    void registerService(::CORBA::Object_ptr registeringService, const char* name);
    void unregisterService(::CORBA::Object_ptr unregisteringService, const char* name);
    char* getComponentImplementationId(const char* componentInstantiationId);

    // Constructors
    inline _objref_DeviceManager()  { _PR_setobj(0); }  // nil
    _objref_DeviceManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DeviceManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DeviceManager(const _objref_DeviceManager&);
    _objref_DeviceManager& operator = (const _objref_DeviceManager&);
    // not implemented

    friend class DeviceManager;
  };

  class _pof_DeviceManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DeviceManager() : _OMNI_NS(proxyObjectFactory)(DeviceManager::_PD_repoId) {}
    virtual ~_pof_DeviceManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DeviceManager :
    public virtual _impl_PropertyEmitter,
    public virtual _impl_PortSet,
    public virtual _impl_Logging
  {
  public:
    virtual ~_impl_DeviceManager();

    virtual char* deviceConfigurationProfile() = 0;
    virtual FileSystem_ptr fileSys() = 0;
    virtual char* identifier() = 0;
    virtual char* label() = 0;
    virtual DomainManager_ptr domMgr() = 0;
    virtual DeviceSequence* registeredDevices() = 0;
    virtual DeviceManager::ServiceSequence* registeredServices() = 0;
    virtual void registerDevice(::CF::Device_ptr registeringDevice) = 0;
    virtual void unregisterDevice(::CF::Device_ptr registeredDevice) = 0;
    virtual void shutdown() = 0;
    virtual void registerService(::CORBA::Object_ptr registeringService, const char* name) = 0;
    virtual void unregisterService(::CORBA::Object_ptr unregisteringService, const char* name) = 0;
    virtual char* getComponentImplementationId(const char* componentInstantiationId) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceManager;

  struct complexDouble {
    typedef _CORBA_ConstrType_Fix_Var<complexDouble> _var_type;

    
    ::CORBA::Double real;

    ::CORBA::Double imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexDouble::_var_type complexDouble_var;

  typedef complexDouble& complexDouble_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexDouble;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexDoubleSeq;

  class complexDoubleSeq_var;

  class complexDoubleSeq : public _CORBA_Unbounded_Sequence< complexDouble >  {
  public:
    typedef complexDoubleSeq_var _var_type;
    inline complexDoubleSeq() {}
    inline complexDoubleSeq(const complexDoubleSeq& _s)
      : _CORBA_Unbounded_Sequence< complexDouble > (_s) {}

    inline complexDoubleSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexDouble > (_max) {}
    inline complexDoubleSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexDouble* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexDouble > (_max, _len, _val, _rel) {}

  

    inline complexDoubleSeq& operator = (const complexDoubleSeq& _s) {
      _CORBA_Unbounded_Sequence< complexDouble > ::operator=(_s);
      return *this;
    }
  };

  class complexDoubleSeq_out;

  class complexDoubleSeq_var {
  public:
    inline complexDoubleSeq_var() : _pd_seq(0) {}
    inline complexDoubleSeq_var(complexDoubleSeq* _s) : _pd_seq(_s) {}
    inline complexDoubleSeq_var(const complexDoubleSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexDoubleSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexDoubleSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexDoubleSeq_var& operator = (complexDoubleSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexDoubleSeq_var& operator = (const complexDoubleSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexDoubleSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexDouble& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexDoubleSeq* operator -> () { return _pd_seq; }
    inline const complexDoubleSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexDoubleSeq& () const { return *_pd_seq; }
#else
    inline operator const complexDoubleSeq& () const { return *_pd_seq; }
    inline operator complexDoubleSeq& () { return *_pd_seq; }
#endif
      
    inline const complexDoubleSeq& in() const { return *_pd_seq; }
    inline complexDoubleSeq&       inout()    { return *_pd_seq; }
    inline complexDoubleSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexDoubleSeq* _retn() { complexDoubleSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexDoubleSeq_out;
    
  private:
    complexDoubleSeq* _pd_seq;
  };

  class complexDoubleSeq_out {
  public:
    inline complexDoubleSeq_out(complexDoubleSeq*& _s) : _data(_s) { _data = 0; }
    inline complexDoubleSeq_out(complexDoubleSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexDoubleSeq*) 0; }
    inline complexDoubleSeq_out(const complexDoubleSeq_out& _s) : _data(_s._data) {}
    inline complexDoubleSeq_out& operator = (const complexDoubleSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexDoubleSeq_out& operator = (complexDoubleSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexDoubleSeq*&()  { return _data; }
    inline complexDoubleSeq*& ptr()       { return _data; }
    inline complexDoubleSeq* operator->() { return _data; }

    inline complexDouble& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexDoubleSeq*& _data;

  private:
    complexDoubleSeq_out();
    complexDoubleSeq_out& operator=(const complexDoubleSeq_var&);
  };

  struct complexFloat {
    typedef _CORBA_ConstrType_Fix_Var<complexFloat> _var_type;

    
    ::CORBA::Float real;

    ::CORBA::Float imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexFloat::_var_type complexFloat_var;

  typedef complexFloat& complexFloat_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexFloat;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexFloatSeq;

  class complexFloatSeq_var;

  class complexFloatSeq : public _CORBA_Unbounded_Sequence< complexFloat >  {
  public:
    typedef complexFloatSeq_var _var_type;
    inline complexFloatSeq() {}
    inline complexFloatSeq(const complexFloatSeq& _s)
      : _CORBA_Unbounded_Sequence< complexFloat > (_s) {}

    inline complexFloatSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexFloat > (_max) {}
    inline complexFloatSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexFloat* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexFloat > (_max, _len, _val, _rel) {}

  

    inline complexFloatSeq& operator = (const complexFloatSeq& _s) {
      _CORBA_Unbounded_Sequence< complexFloat > ::operator=(_s);
      return *this;
    }
  };

  class complexFloatSeq_out;

  class complexFloatSeq_var {
  public:
    inline complexFloatSeq_var() : _pd_seq(0) {}
    inline complexFloatSeq_var(complexFloatSeq* _s) : _pd_seq(_s) {}
    inline complexFloatSeq_var(const complexFloatSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexFloatSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexFloatSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexFloatSeq_var& operator = (complexFloatSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexFloatSeq_var& operator = (const complexFloatSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexFloatSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexFloat& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexFloatSeq* operator -> () { return _pd_seq; }
    inline const complexFloatSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexFloatSeq& () const { return *_pd_seq; }
#else
    inline operator const complexFloatSeq& () const { return *_pd_seq; }
    inline operator complexFloatSeq& () { return *_pd_seq; }
#endif
      
    inline const complexFloatSeq& in() const { return *_pd_seq; }
    inline complexFloatSeq&       inout()    { return *_pd_seq; }
    inline complexFloatSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexFloatSeq* _retn() { complexFloatSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexFloatSeq_out;
    
  private:
    complexFloatSeq* _pd_seq;
  };

  class complexFloatSeq_out {
  public:
    inline complexFloatSeq_out(complexFloatSeq*& _s) : _data(_s) { _data = 0; }
    inline complexFloatSeq_out(complexFloatSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexFloatSeq*) 0; }
    inline complexFloatSeq_out(const complexFloatSeq_out& _s) : _data(_s._data) {}
    inline complexFloatSeq_out& operator = (const complexFloatSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexFloatSeq_out& operator = (complexFloatSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexFloatSeq*&()  { return _data; }
    inline complexFloatSeq*& ptr()       { return _data; }
    inline complexFloatSeq* operator->() { return _data; }

    inline complexFloat& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexFloatSeq*& _data;

  private:
    complexFloatSeq_out();
    complexFloatSeq_out& operator=(const complexFloatSeq_var&);
  };

  struct complexBoolean {
    typedef _CORBA_ConstrType_Fix_Var<complexBoolean> _var_type;

    
    ::CORBA::Boolean real;

    ::CORBA::Boolean imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexBoolean::_var_type complexBoolean_var;

  typedef complexBoolean& complexBoolean_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexBoolean;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexBooleanSeq;

  class complexBooleanSeq_var;

  class complexBooleanSeq : public _CORBA_Unbounded_Sequence< complexBoolean >  {
  public:
    typedef complexBooleanSeq_var _var_type;
    inline complexBooleanSeq() {}
    inline complexBooleanSeq(const complexBooleanSeq& _s)
      : _CORBA_Unbounded_Sequence< complexBoolean > (_s) {}

    inline complexBooleanSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexBoolean > (_max) {}
    inline complexBooleanSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexBoolean* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexBoolean > (_max, _len, _val, _rel) {}

  

    inline complexBooleanSeq& operator = (const complexBooleanSeq& _s) {
      _CORBA_Unbounded_Sequence< complexBoolean > ::operator=(_s);
      return *this;
    }
  };

  class complexBooleanSeq_out;

  class complexBooleanSeq_var {
  public:
    inline complexBooleanSeq_var() : _pd_seq(0) {}
    inline complexBooleanSeq_var(complexBooleanSeq* _s) : _pd_seq(_s) {}
    inline complexBooleanSeq_var(const complexBooleanSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexBooleanSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexBooleanSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexBooleanSeq_var& operator = (complexBooleanSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexBooleanSeq_var& operator = (const complexBooleanSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexBooleanSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexBoolean& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexBooleanSeq* operator -> () { return _pd_seq; }
    inline const complexBooleanSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexBooleanSeq& () const { return *_pd_seq; }
#else
    inline operator const complexBooleanSeq& () const { return *_pd_seq; }
    inline operator complexBooleanSeq& () { return *_pd_seq; }
#endif
      
    inline const complexBooleanSeq& in() const { return *_pd_seq; }
    inline complexBooleanSeq&       inout()    { return *_pd_seq; }
    inline complexBooleanSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexBooleanSeq* _retn() { complexBooleanSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexBooleanSeq_out;
    
  private:
    complexBooleanSeq* _pd_seq;
  };

  class complexBooleanSeq_out {
  public:
    inline complexBooleanSeq_out(complexBooleanSeq*& _s) : _data(_s) { _data = 0; }
    inline complexBooleanSeq_out(complexBooleanSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexBooleanSeq*) 0; }
    inline complexBooleanSeq_out(const complexBooleanSeq_out& _s) : _data(_s._data) {}
    inline complexBooleanSeq_out& operator = (const complexBooleanSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexBooleanSeq_out& operator = (complexBooleanSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexBooleanSeq*&()  { return _data; }
    inline complexBooleanSeq*& ptr()       { return _data; }
    inline complexBooleanSeq* operator->() { return _data; }

    inline complexBoolean& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexBooleanSeq*& _data;

  private:
    complexBooleanSeq_out();
    complexBooleanSeq_out& operator=(const complexBooleanSeq_var&);
  };

  struct complexULong {
    typedef _CORBA_ConstrType_Fix_Var<complexULong> _var_type;

    
    ::CORBA::ULong real;

    ::CORBA::ULong imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexULong::_var_type complexULong_var;

  typedef complexULong& complexULong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULongSeq;

  class complexULongSeq_var;

  class complexULongSeq : public _CORBA_Unbounded_Sequence< complexULong >  {
  public:
    typedef complexULongSeq_var _var_type;
    inline complexULongSeq() {}
    inline complexULongSeq(const complexULongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexULong > (_s) {}

    inline complexULongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexULong > (_max) {}
    inline complexULongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexULong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexULong > (_max, _len, _val, _rel) {}

  

    inline complexULongSeq& operator = (const complexULongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexULong > ::operator=(_s);
      return *this;
    }
  };

  class complexULongSeq_out;

  class complexULongSeq_var {
  public:
    inline complexULongSeq_var() : _pd_seq(0) {}
    inline complexULongSeq_var(complexULongSeq* _s) : _pd_seq(_s) {}
    inline complexULongSeq_var(const complexULongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexULongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexULongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexULongSeq_var& operator = (complexULongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexULongSeq_var& operator = (const complexULongSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexULongSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexULong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexULongSeq* operator -> () { return _pd_seq; }
    inline const complexULongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexULongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexULongSeq& () const { return *_pd_seq; }
    inline operator complexULongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexULongSeq& in() const { return *_pd_seq; }
    inline complexULongSeq&       inout()    { return *_pd_seq; }
    inline complexULongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexULongSeq* _retn() { complexULongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexULongSeq_out;
    
  private:
    complexULongSeq* _pd_seq;
  };

  class complexULongSeq_out {
  public:
    inline complexULongSeq_out(complexULongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexULongSeq_out(complexULongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexULongSeq*) 0; }
    inline complexULongSeq_out(const complexULongSeq_out& _s) : _data(_s._data) {}
    inline complexULongSeq_out& operator = (const complexULongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexULongSeq_out& operator = (complexULongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexULongSeq*&()  { return _data; }
    inline complexULongSeq*& ptr()       { return _data; }
    inline complexULongSeq* operator->() { return _data; }

    inline complexULong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexULongSeq*& _data;

  private:
    complexULongSeq_out();
    complexULongSeq_out& operator=(const complexULongSeq_var&);
  };

  struct complexShort {
    typedef _CORBA_ConstrType_Fix_Var<complexShort> _var_type;

    
    ::CORBA::Short real;

    ::CORBA::Short imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexShort::_var_type complexShort_var;

  typedef complexShort& complexShort_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexShort;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexShortSeq;

  class complexShortSeq_var;

  class complexShortSeq : public _CORBA_Unbounded_Sequence< complexShort >  {
  public:
    typedef complexShortSeq_var _var_type;
    inline complexShortSeq() {}
    inline complexShortSeq(const complexShortSeq& _s)
      : _CORBA_Unbounded_Sequence< complexShort > (_s) {}

    inline complexShortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexShort > (_max) {}
    inline complexShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexShort > (_max, _len, _val, _rel) {}

  

    inline complexShortSeq& operator = (const complexShortSeq& _s) {
      _CORBA_Unbounded_Sequence< complexShort > ::operator=(_s);
      return *this;
    }
  };

  class complexShortSeq_out;

  class complexShortSeq_var {
  public:
    inline complexShortSeq_var() : _pd_seq(0) {}
    inline complexShortSeq_var(complexShortSeq* _s) : _pd_seq(_s) {}
    inline complexShortSeq_var(const complexShortSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexShortSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexShortSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexShortSeq_var& operator = (complexShortSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexShortSeq_var& operator = (const complexShortSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexShortSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexShortSeq* operator -> () { return _pd_seq; }
    inline const complexShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexShortSeq& () const { return *_pd_seq; }
#else
    inline operator const complexShortSeq& () const { return *_pd_seq; }
    inline operator complexShortSeq& () { return *_pd_seq; }
#endif
      
    inline const complexShortSeq& in() const { return *_pd_seq; }
    inline complexShortSeq&       inout()    { return *_pd_seq; }
    inline complexShortSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexShortSeq* _retn() { complexShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexShortSeq_out;
    
  private:
    complexShortSeq* _pd_seq;
  };

  class complexShortSeq_out {
  public:
    inline complexShortSeq_out(complexShortSeq*& _s) : _data(_s) { _data = 0; }
    inline complexShortSeq_out(complexShortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexShortSeq*) 0; }
    inline complexShortSeq_out(const complexShortSeq_out& _s) : _data(_s._data) {}
    inline complexShortSeq_out& operator = (const complexShortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexShortSeq_out& operator = (complexShortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexShortSeq*&()  { return _data; }
    inline complexShortSeq*& ptr()       { return _data; }
    inline complexShortSeq* operator->() { return _data; }

    inline complexShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexShortSeq*& _data;

  private:
    complexShortSeq_out();
    complexShortSeq_out& operator=(const complexShortSeq_var&);
  };

  struct complexOctet {
    typedef _CORBA_ConstrType_Fix_Var<complexOctet> _var_type;

    
    ::CORBA::Octet real;

    ::CORBA::Octet imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexOctet::_var_type complexOctet_var;

  typedef complexOctet& complexOctet_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexOctet;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexOctetSeq;

  class complexOctetSeq_var;

  class complexOctetSeq : public _CORBA_Unbounded_Sequence< complexOctet >  {
  public:
    typedef complexOctetSeq_var _var_type;
    inline complexOctetSeq() {}
    inline complexOctetSeq(const complexOctetSeq& _s)
      : _CORBA_Unbounded_Sequence< complexOctet > (_s) {}

    inline complexOctetSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexOctet > (_max) {}
    inline complexOctetSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexOctet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexOctet > (_max, _len, _val, _rel) {}

  

    inline complexOctetSeq& operator = (const complexOctetSeq& _s) {
      _CORBA_Unbounded_Sequence< complexOctet > ::operator=(_s);
      return *this;
    }
  };

  class complexOctetSeq_out;

  class complexOctetSeq_var {
  public:
    inline complexOctetSeq_var() : _pd_seq(0) {}
    inline complexOctetSeq_var(complexOctetSeq* _s) : _pd_seq(_s) {}
    inline complexOctetSeq_var(const complexOctetSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexOctetSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexOctetSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexOctetSeq_var& operator = (complexOctetSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexOctetSeq_var& operator = (const complexOctetSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexOctetSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexOctet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexOctetSeq* operator -> () { return _pd_seq; }
    inline const complexOctetSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexOctetSeq& () const { return *_pd_seq; }
#else
    inline operator const complexOctetSeq& () const { return *_pd_seq; }
    inline operator complexOctetSeq& () { return *_pd_seq; }
#endif
      
    inline const complexOctetSeq& in() const { return *_pd_seq; }
    inline complexOctetSeq&       inout()    { return *_pd_seq; }
    inline complexOctetSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexOctetSeq* _retn() { complexOctetSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexOctetSeq_out;
    
  private:
    complexOctetSeq* _pd_seq;
  };

  class complexOctetSeq_out {
  public:
    inline complexOctetSeq_out(complexOctetSeq*& _s) : _data(_s) { _data = 0; }
    inline complexOctetSeq_out(complexOctetSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexOctetSeq*) 0; }
    inline complexOctetSeq_out(const complexOctetSeq_out& _s) : _data(_s._data) {}
    inline complexOctetSeq_out& operator = (const complexOctetSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexOctetSeq_out& operator = (complexOctetSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexOctetSeq*&()  { return _data; }
    inline complexOctetSeq*& ptr()       { return _data; }
    inline complexOctetSeq* operator->() { return _data; }

    inline complexOctet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexOctetSeq*& _data;

  private:
    complexOctetSeq_out();
    complexOctetSeq_out& operator=(const complexOctetSeq_var&);
  };

  struct complexChar {
    typedef _CORBA_ConstrType_Fix_Var<complexChar> _var_type;

    
    ::CORBA::Char real;

    ::CORBA::Char imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexChar::_var_type complexChar_var;

  typedef complexChar& complexChar_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexChar;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexCharSeq;

  class complexCharSeq_var;

  class complexCharSeq : public _CORBA_Unbounded_Sequence< complexChar >  {
  public:
    typedef complexCharSeq_var _var_type;
    inline complexCharSeq() {}
    inline complexCharSeq(const complexCharSeq& _s)
      : _CORBA_Unbounded_Sequence< complexChar > (_s) {}

    inline complexCharSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexChar > (_max) {}
    inline complexCharSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexChar* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexChar > (_max, _len, _val, _rel) {}

  

    inline complexCharSeq& operator = (const complexCharSeq& _s) {
      _CORBA_Unbounded_Sequence< complexChar > ::operator=(_s);
      return *this;
    }
  };

  class complexCharSeq_out;

  class complexCharSeq_var {
  public:
    inline complexCharSeq_var() : _pd_seq(0) {}
    inline complexCharSeq_var(complexCharSeq* _s) : _pd_seq(_s) {}
    inline complexCharSeq_var(const complexCharSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexCharSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexCharSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexCharSeq_var& operator = (complexCharSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexCharSeq_var& operator = (const complexCharSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexCharSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexChar& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexCharSeq* operator -> () { return _pd_seq; }
    inline const complexCharSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexCharSeq& () const { return *_pd_seq; }
#else
    inline operator const complexCharSeq& () const { return *_pd_seq; }
    inline operator complexCharSeq& () { return *_pd_seq; }
#endif
      
    inline const complexCharSeq& in() const { return *_pd_seq; }
    inline complexCharSeq&       inout()    { return *_pd_seq; }
    inline complexCharSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexCharSeq* _retn() { complexCharSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexCharSeq_out;
    
  private:
    complexCharSeq* _pd_seq;
  };

  class complexCharSeq_out {
  public:
    inline complexCharSeq_out(complexCharSeq*& _s) : _data(_s) { _data = 0; }
    inline complexCharSeq_out(complexCharSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexCharSeq*) 0; }
    inline complexCharSeq_out(const complexCharSeq_out& _s) : _data(_s._data) {}
    inline complexCharSeq_out& operator = (const complexCharSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexCharSeq_out& operator = (complexCharSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexCharSeq*&()  { return _data; }
    inline complexCharSeq*& ptr()       { return _data; }
    inline complexCharSeq* operator->() { return _data; }

    inline complexChar& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexCharSeq*& _data;

  private:
    complexCharSeq_out();
    complexCharSeq_out& operator=(const complexCharSeq_var&);
  };

  struct complexUShort {
    typedef _CORBA_ConstrType_Fix_Var<complexUShort> _var_type;

    
    ::CORBA::UShort real;

    ::CORBA::UShort imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexUShort::_var_type complexUShort_var;

  typedef complexUShort& complexUShort_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexUShort;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexUShortSeq;

  class complexUShortSeq_var;

  class complexUShortSeq : public _CORBA_Unbounded_Sequence< complexUShort >  {
  public:
    typedef complexUShortSeq_var _var_type;
    inline complexUShortSeq() {}
    inline complexUShortSeq(const complexUShortSeq& _s)
      : _CORBA_Unbounded_Sequence< complexUShort > (_s) {}

    inline complexUShortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexUShort > (_max) {}
    inline complexUShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexUShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexUShort > (_max, _len, _val, _rel) {}

  

    inline complexUShortSeq& operator = (const complexUShortSeq& _s) {
      _CORBA_Unbounded_Sequence< complexUShort > ::operator=(_s);
      return *this;
    }
  };

  class complexUShortSeq_out;

  class complexUShortSeq_var {
  public:
    inline complexUShortSeq_var() : _pd_seq(0) {}
    inline complexUShortSeq_var(complexUShortSeq* _s) : _pd_seq(_s) {}
    inline complexUShortSeq_var(const complexUShortSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexUShortSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexUShortSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexUShortSeq_var& operator = (complexUShortSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexUShortSeq_var& operator = (const complexUShortSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexUShortSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexUShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexUShortSeq* operator -> () { return _pd_seq; }
    inline const complexUShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexUShortSeq& () const { return *_pd_seq; }
#else
    inline operator const complexUShortSeq& () const { return *_pd_seq; }
    inline operator complexUShortSeq& () { return *_pd_seq; }
#endif
      
    inline const complexUShortSeq& in() const { return *_pd_seq; }
    inline complexUShortSeq&       inout()    { return *_pd_seq; }
    inline complexUShortSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexUShortSeq* _retn() { complexUShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexUShortSeq_out;
    
  private:
    complexUShortSeq* _pd_seq;
  };

  class complexUShortSeq_out {
  public:
    inline complexUShortSeq_out(complexUShortSeq*& _s) : _data(_s) { _data = 0; }
    inline complexUShortSeq_out(complexUShortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexUShortSeq*) 0; }
    inline complexUShortSeq_out(const complexUShortSeq_out& _s) : _data(_s._data) {}
    inline complexUShortSeq_out& operator = (const complexUShortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexUShortSeq_out& operator = (complexUShortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexUShortSeq*&()  { return _data; }
    inline complexUShortSeq*& ptr()       { return _data; }
    inline complexUShortSeq* operator->() { return _data; }

    inline complexUShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexUShortSeq*& _data;

  private:
    complexUShortSeq_out();
    complexUShortSeq_out& operator=(const complexUShortSeq_var&);
  };

  struct complexLong {
    typedef _CORBA_ConstrType_Fix_Var<complexLong> _var_type;

    
    ::CORBA::Long real;

    ::CORBA::Long imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexLong::_var_type complexLong_var;

  typedef complexLong& complexLong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLongSeq;

  class complexLongSeq_var;

  class complexLongSeq : public _CORBA_Unbounded_Sequence< complexLong >  {
  public:
    typedef complexLongSeq_var _var_type;
    inline complexLongSeq() {}
    inline complexLongSeq(const complexLongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexLong > (_s) {}

    inline complexLongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexLong > (_max) {}
    inline complexLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexLong > (_max, _len, _val, _rel) {}

  

    inline complexLongSeq& operator = (const complexLongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexLong > ::operator=(_s);
      return *this;
    }
  };

  class complexLongSeq_out;

  class complexLongSeq_var {
  public:
    inline complexLongSeq_var() : _pd_seq(0) {}
    inline complexLongSeq_var(complexLongSeq* _s) : _pd_seq(_s) {}
    inline complexLongSeq_var(const complexLongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexLongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexLongSeq_var& operator = (complexLongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexLongSeq_var& operator = (const complexLongSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexLongSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexLongSeq* operator -> () { return _pd_seq; }
    inline const complexLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexLongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexLongSeq& () const { return *_pd_seq; }
    inline operator complexLongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexLongSeq& in() const { return *_pd_seq; }
    inline complexLongSeq&       inout()    { return *_pd_seq; }
    inline complexLongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexLongSeq* _retn() { complexLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexLongSeq_out;
    
  private:
    complexLongSeq* _pd_seq;
  };

  class complexLongSeq_out {
  public:
    inline complexLongSeq_out(complexLongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexLongSeq_out(complexLongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexLongSeq*) 0; }
    inline complexLongSeq_out(const complexLongSeq_out& _s) : _data(_s._data) {}
    inline complexLongSeq_out& operator = (const complexLongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexLongSeq_out& operator = (complexLongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexLongSeq*&()  { return _data; }
    inline complexLongSeq*& ptr()       { return _data; }
    inline complexLongSeq* operator->() { return _data; }

    inline complexLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexLongSeq*& _data;

  private:
    complexLongSeq_out();
    complexLongSeq_out& operator=(const complexLongSeq_var&);
  };

  struct complexLongLong {
    typedef _CORBA_ConstrType_Fix_Var<complexLongLong> _var_type;

    
    ::CORBA::LongLong real;

    ::CORBA::LongLong imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexLongLong::_var_type complexLongLong_var;

  typedef complexLongLong& complexLongLong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLongLong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLongLongSeq;

  class complexLongLongSeq_var;

  class complexLongLongSeq : public _CORBA_Unbounded_Sequence< complexLongLong >  {
  public:
    typedef complexLongLongSeq_var _var_type;
    inline complexLongLongSeq() {}
    inline complexLongLongSeq(const complexLongLongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexLongLong > (_s) {}

    inline complexLongLongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexLongLong > (_max) {}
    inline complexLongLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexLongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexLongLong > (_max, _len, _val, _rel) {}

  

    inline complexLongLongSeq& operator = (const complexLongLongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexLongLong > ::operator=(_s);
      return *this;
    }
  };

  class complexLongLongSeq_out;

  class complexLongLongSeq_var {
  public:
    inline complexLongLongSeq_var() : _pd_seq(0) {}
    inline complexLongLongSeq_var(complexLongLongSeq* _s) : _pd_seq(_s) {}
    inline complexLongLongSeq_var(const complexLongLongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexLongLongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexLongLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexLongLongSeq_var& operator = (complexLongLongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexLongLongSeq_var& operator = (const complexLongLongSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexLongLongSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexLongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexLongLongSeq* operator -> () { return _pd_seq; }
    inline const complexLongLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexLongLongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexLongLongSeq& () const { return *_pd_seq; }
    inline operator complexLongLongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexLongLongSeq& in() const { return *_pd_seq; }
    inline complexLongLongSeq&       inout()    { return *_pd_seq; }
    inline complexLongLongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexLongLongSeq* _retn() { complexLongLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexLongLongSeq_out;
    
  private:
    complexLongLongSeq* _pd_seq;
  };

  class complexLongLongSeq_out {
  public:
    inline complexLongLongSeq_out(complexLongLongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexLongLongSeq_out(complexLongLongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexLongLongSeq*) 0; }
    inline complexLongLongSeq_out(const complexLongLongSeq_out& _s) : _data(_s._data) {}
    inline complexLongLongSeq_out& operator = (const complexLongLongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexLongLongSeq_out& operator = (complexLongLongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexLongLongSeq*&()  { return _data; }
    inline complexLongLongSeq*& ptr()       { return _data; }
    inline complexLongLongSeq* operator->() { return _data; }

    inline complexLongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexLongLongSeq*& _data;

  private:
    complexLongLongSeq_out();
    complexLongLongSeq_out& operator=(const complexLongLongSeq_var&);
  };

  struct complexULongLong {
    typedef _CORBA_ConstrType_Fix_Var<complexULongLong> _var_type;

    
    ::CORBA::ULongLong real;

    ::CORBA::ULongLong imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexULongLong::_var_type complexULongLong_var;

  typedef complexULongLong& complexULongLong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULongLong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULongLongSeq;

  class complexULongLongSeq_var;

  class complexULongLongSeq : public _CORBA_Unbounded_Sequence< complexULongLong >  {
  public:
    typedef complexULongLongSeq_var _var_type;
    inline complexULongLongSeq() {}
    inline complexULongLongSeq(const complexULongLongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexULongLong > (_s) {}

    inline complexULongLongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexULongLong > (_max) {}
    inline complexULongLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexULongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexULongLong > (_max, _len, _val, _rel) {}

  

    inline complexULongLongSeq& operator = (const complexULongLongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexULongLong > ::operator=(_s);
      return *this;
    }
  };

  class complexULongLongSeq_out;

  class complexULongLongSeq_var {
  public:
    inline complexULongLongSeq_var() : _pd_seq(0) {}
    inline complexULongLongSeq_var(complexULongLongSeq* _s) : _pd_seq(_s) {}
    inline complexULongLongSeq_var(const complexULongLongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexULongLongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexULongLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexULongLongSeq_var& operator = (complexULongLongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexULongLongSeq_var& operator = (const complexULongLongSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new complexULongLongSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline complexULongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexULongLongSeq* operator -> () { return _pd_seq; }
    inline const complexULongLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexULongLongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexULongLongSeq& () const { return *_pd_seq; }
    inline operator complexULongLongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexULongLongSeq& in() const { return *_pd_seq; }
    inline complexULongLongSeq&       inout()    { return *_pd_seq; }
    inline complexULongLongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexULongLongSeq* _retn() { complexULongLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexULongLongSeq_out;
    
  private:
    complexULongLongSeq* _pd_seq;
  };

  class complexULongLongSeq_out {
  public:
    inline complexULongLongSeq_out(complexULongLongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexULongLongSeq_out(complexULongLongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexULongLongSeq*) 0; }
    inline complexULongLongSeq_out(const complexULongLongSeq_out& _s) : _data(_s._data) {}
    inline complexULongLongSeq_out& operator = (const complexULongLongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexULongLongSeq_out& operator = (complexULongLongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexULongLongSeq*&()  { return _data; }
    inline complexULongLongSeq*& ptr()       { return _data; }
    inline complexULongLongSeq* operator->() { return _data; }

    inline complexULongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexULongLongSeq*& _data;

  private:
    complexULongLongSeq_out();
    complexULongLongSeq_out& operator=(const complexULongLongSeq_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_CF
_CORBA_MODULE_BEG

  class AggregateDevice :
    public virtual CF::_impl_AggregateDevice,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~AggregateDevice();

    inline ::CF::AggregateDevice_ptr _this() {
      return (::CF::AggregateDevice_ptr) _do_this(::CF::AggregateDevice::_PD_repoId);
    }
  };

  class FileSystem :
    public virtual CF::_impl_FileSystem,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~FileSystem();

    inline ::CF::FileSystem_ptr _this() {
      return (::CF::FileSystem_ptr) _do_this(::CF::FileSystem::_PD_repoId);
    }
  };

  class File :
    public virtual CF::_impl_File,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~File();

    inline ::CF::File_ptr _this() {
      return (::CF::File_ptr) _do_this(::CF::File::_PD_repoId);
    }
  };

  class ResourceFactory :
    public virtual CF::_impl_ResourceFactory,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ResourceFactory();

    inline ::CF::ResourceFactory_ptr _this() {
      return (::CF::ResourceFactory_ptr) _do_this(::CF::ResourceFactory::_PD_repoId);
    }
  };

  class FileManager :
    public virtual CF::_impl_FileManager,
    public virtual FileSystem
  {
  public:
    virtual ~FileManager();

    inline ::CF::FileManager_ptr _this() {
      return (::CF::FileManager_ptr) _do_this(::CF::FileManager::_PD_repoId);
    }
  };

  class LifeCycle :
    public virtual CF::_impl_LifeCycle,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~LifeCycle();

    inline ::CF::LifeCycle_ptr _this() {
      return (::CF::LifeCycle_ptr) _do_this(::CF::LifeCycle::_PD_repoId);
    }
  };

  class TestableObject :
    public virtual CF::_impl_TestableObject,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~TestableObject();

    inline ::CF::TestableObject_ptr _this() {
      return (::CF::TestableObject_ptr) _do_this(::CF::TestableObject::_PD_repoId);
    }
  };

  class PropertyChangeListener :
    public virtual CF::_impl_PropertyChangeListener,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PropertyChangeListener();

    inline ::CF::PropertyChangeListener_ptr _this() {
      return (::CF::PropertyChangeListener_ptr) _do_this(::CF::PropertyChangeListener::_PD_repoId);
    }
  };

  class PropertySet :
    public virtual CF::_impl_PropertySet,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PropertySet();

    inline ::CF::PropertySet_ptr _this() {
      return (::CF::PropertySet_ptr) _do_this(::CF::PropertySet::_PD_repoId);
    }
  };

  class PropertyEmitter :
    public virtual CF::_impl_PropertyEmitter,
    public virtual PropertySet
  {
  public:
    virtual ~PropertyEmitter();

    inline ::CF::PropertyEmitter_ptr _this() {
      return (::CF::PropertyEmitter_ptr) _do_this(::CF::PropertyEmitter::_PD_repoId);
    }
  };

  class AllocationManager :
    public virtual CF::_impl_AllocationManager,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~AllocationManager();

    inline ::CF::AllocationManager_ptr _this() {
      return (::CF::AllocationManager_ptr) _do_this(::CF::AllocationManager::_PD_repoId);
    }
  };

  class AllocationStatusIterator :
    public virtual CF::_impl_AllocationStatusIterator,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~AllocationStatusIterator();

    inline ::CF::AllocationStatusIterator_ptr _this() {
      return (::CF::AllocationStatusIterator_ptr) _do_this(::CF::AllocationStatusIterator::_PD_repoId);
    }
  };

  class DeviceLocationIterator :
    public virtual CF::_impl_DeviceLocationIterator,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DeviceLocationIterator();

    inline ::CF::DeviceLocationIterator_ptr _this() {
      return (::CF::DeviceLocationIterator_ptr) _do_this(::CF::DeviceLocationIterator::_PD_repoId);
    }
  };

  class ConnectionManager :
    public virtual CF::_impl_ConnectionManager,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ConnectionManager();

    inline ::CF::ConnectionManager_ptr _this() {
      return (::CF::ConnectionManager_ptr) _do_this(::CF::ConnectionManager::_PD_repoId);
    }
  };

  class ConnectionStatusIterator :
    public virtual CF::_impl_ConnectionStatusIterator,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ConnectionStatusIterator();

    inline ::CF::ConnectionStatusIterator_ptr _this() {
      return (::CF::ConnectionStatusIterator_ptr) _do_this(::CF::ConnectionStatusIterator::_PD_repoId);
    }
  };

  class ApplicationFactory :
    public virtual CF::_impl_ApplicationFactory,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ApplicationFactory();

    inline ::CF::ApplicationFactory_ptr _this() {
      return (::CF::ApplicationFactory_ptr) _do_this(::CF::ApplicationFactory::_PD_repoId);
    }
  };

  class DomainManager :
    public virtual CF::_impl_DomainManager,
    public virtual PropertyEmitter,
      public virtual Logging
  {
  public:
    virtual ~DomainManager();

    inline ::CF::DomainManager_ptr _this() {
      return (::CF::DomainManager_ptr) _do_this(::CF::DomainManager::_PD_repoId);
    }
  };

  class PortSupplier :
    public virtual CF::_impl_PortSupplier,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PortSupplier();

    inline ::CF::PortSupplier_ptr _this() {
      return (::CF::PortSupplier_ptr) _do_this(::CF::PortSupplier::_PD_repoId);
    }
  };

  class PortSet :
    public virtual CF::_impl_PortSet,
    public virtual PortSupplier
  {
  public:
    virtual ~PortSet();

    inline ::CF::PortSet_ptr _this() {
      return (::CF::PortSet_ptr) _do_this(::CF::PortSet::_PD_repoId);
    }
  };

  class Resource :
    public virtual CF::_impl_Resource,
    public virtual LifeCycle,
      public virtual TestableObject,
      public virtual PropertyEmitter,
      public virtual PortSet,
      public virtual Logging
  {
  public:
    virtual ~Resource();

    inline ::CF::Resource_ptr _this() {
      return (::CF::Resource_ptr) _do_this(::CF::Resource::_PD_repoId);
    }
  };

  class Device :
    public virtual CF::_impl_Device,
    public virtual Resource
  {
  public:
    virtual ~Device();

    inline ::CF::Device_ptr _this() {
      return (::CF::Device_ptr) _do_this(::CF::Device::_PD_repoId);
    }
  };

  class ApplicationRegistrar :
    public virtual CF::_impl_ApplicationRegistrar,
    public virtual POA_CosNaming::NamingContext
  {
  public:
    virtual ~ApplicationRegistrar();

    inline ::CF::ApplicationRegistrar_ptr _this() {
      return (::CF::ApplicationRegistrar_ptr) _do_this(::CF::ApplicationRegistrar::_PD_repoId);
    }
  };

  class Application :
    public virtual CF::_impl_Application,
    public virtual Resource
  {
  public:
    virtual ~Application();

    inline ::CF::Application_ptr _this() {
      return (::CF::Application_ptr) _do_this(::CF::Application::_PD_repoId);
    }
  };

  class LoadableDevice :
    public virtual CF::_impl_LoadableDevice,
    public virtual Device
  {
  public:
    virtual ~LoadableDevice();

    inline ::CF::LoadableDevice_ptr _this() {
      return (::CF::LoadableDevice_ptr) _do_this(::CF::LoadableDevice::_PD_repoId);
    }
  };

  class ExecutableDevice :
    public virtual CF::_impl_ExecutableDevice,
    public virtual LoadableDevice
  {
  public:
    virtual ~ExecutableDevice();

    inline ::CF::ExecutableDevice_ptr _this() {
      return (::CF::ExecutableDevice_ptr) _do_this(::CF::ExecutableDevice::_PD_repoId);
    }
  };

  class DeviceManager :
    public virtual CF::_impl_DeviceManager,
    public virtual PropertyEmitter,
      public virtual PortSet,
      public virtual Logging
  {
  public:
    virtual ~DeviceManager();

    inline ::CF::DeviceManager_ptr _this() {
      return (::CF::DeviceManager_ptr) _do_this(::CF::DeviceManager::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const CF::InvalidProfile& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidProfile* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidObjectReference*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DuplicateName& _s);
void operator<<=(::CORBA::Any& _a, const CF::DuplicateName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DuplicateName*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::InvalidIdentifier& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidIdentifier* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidIdentifier*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::UnallowedAccess& _s);
void operator<<=(::CORBA::Any& _a, const CF::UnallowedAccess* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::UnallowedAccess*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::FailedCapacityType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::FailedCapacityType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FailedCapacityType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FailedCapacityType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FailedCapacities& _s);
void operator<<=(::CORBA::Any& _a, CF::FailedCapacities* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FailedCapacities*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FailedCapacities*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::UnknownProperties& _s);
void operator<<=(::CORBA::Any& _a, const CF::UnknownProperties* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::UnknownProperties*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::DeviceAssignmentType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::DeviceAssignmentType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceAssignmentType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceAssignmentType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DeviceAssignmentSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceAssignmentSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceAssignmentSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceAssignmentSequence*& _sp);

inline void operator >>=(CF::ErrorNumberType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::ErrorNumberType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::CF_EXDEV) {
    _e = (CF::ErrorNumberType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::ErrorNumberType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ErrorNumberType& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::PortType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::PortType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PortType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PortType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Ports& _s);
void operator<<=(::CORBA::Any& _a, CF::Ports* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Ports*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Ports*& _sp);

inline void operator >>=(CF::ComponentEnumType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::ComponentEnumType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::FRAMEWORK_COMPONENT) {
    _e = (CF::ComponentEnumType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::ComponentEnumType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ComponentEnumType& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::ComponentType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::ComponentType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ComponentType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ComponentType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Components& _s);
void operator<<=(::CORBA::Any& _a, CF::Components* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Components*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Components*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidFileName*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileException& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileException* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileException*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DeviceSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::AggregateDevice_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::AggregateDevice_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AggregateDevice_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties*& _sp);

inline void operator >>=(CF::FileSystem::FileType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::FileSystem::FileType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::FileSystem::FILE_SYSTEM) {
    _e = (CF::FileSystem::FileType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileType& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::FileSystem::FileInformationType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileInformationType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileInformationType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::FileInformationType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileSystem::FileInformationSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileInformationSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileInformationSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::FileInformationSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::FileSystem_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::FileSystem_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::File::IOException& _s);
void operator<<=(::CORBA::Any& _a, const CF::File::IOException* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::File::IOException*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::File::InvalidFilePointer& _s);
void operator<<=(::CORBA::Any& _a, const CF::File::InvalidFilePointer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::File::InvalidFilePointer*& _sp);

void operator<<=(::CORBA::Any& _a, CF::File_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::File_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::File_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId& _s);
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure& _s);
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure& _s);
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure*& _sp);

void operator<<=(::CORBA::Any& _a, CF::ResourceFactory_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ResourceFactory_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ResourceFactory_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::FileManager::MountType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager::MountType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::FileManager::MountSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager::MountSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::NonExistentMount& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileManager::NonExistentMount* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::NonExistentMount*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists*& _sp);

void operator<<=(::CORBA::Any& _a, CF::FileManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::FileManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::InitializeError& _s);
void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::InitializeError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LifeCycle::InitializeError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::ReleaseError& _s);
void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::ReleaseError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LifeCycle::ReleaseError*& _sp);

void operator<<=(::CORBA::Any& _a, CF::LifeCycle_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LifeCycle_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LifeCycle_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::TestableObject::UnknownTest& _s);
void operator<<=(::CORBA::Any& _a, const CF::TestableObject::UnknownTest* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::TestableObject::UnknownTest*& _sp);

void operator<<=(::CORBA::Any& _a, CF::TestableObject_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::TestableObject_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::TestableObject_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::PropertyChangeListener::PropertyChangeEvent& _s);
extern void operator<<=(::CORBA::Any& _a, CF::PropertyChangeListener::PropertyChangeEvent* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PropertyChangeListener::PropertyChangeEvent*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertyChangeListener::PropertyChangeEvent*& _sp);

void operator<<=(::CORBA::Any& _a, CF::PropertyChangeListener_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::PropertyChangeListener_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PropertyChangeListener_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration& _s);
void operator<<=(::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration& _s);
void operator<<=(::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration*& _sp);

void operator<<=(::CORBA::Any& _a, CF::PropertySet_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::PropertySet_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PropertySet_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::PropertyEmitter::AlreadyInitialized& _s);
void operator<<=(::CORBA::Any& _a, const CF::PropertyEmitter::AlreadyInitialized* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertyEmitter::AlreadyInitialized*& _sp);

void operator<<=(::CORBA::Any& _a, CF::PropertyEmitter_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::PropertyEmitter_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PropertyEmitter_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::DevicePoolNames& _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationManager::DevicePoolNames* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::DevicePoolNames*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::DevicePoolNames*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationRequestType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::AllocationManager::AllocationRequestType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::AllocationRequestType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::AllocationRequestType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationResponseType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::AllocationManager::AllocationResponseType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::AllocationResponseType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::AllocationResponseType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationStatusType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::AllocationManager::AllocationStatusType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::AllocationStatusType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::AllocationStatusType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::DeviceLocationType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::AllocationManager::DeviceLocationType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::DeviceLocationType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::DeviceLocationType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationRequestSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationManager::AllocationRequestSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::AllocationRequestSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::AllocationRequestSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationResponseSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationManager::AllocationResponseSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::AllocationResponseSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::AllocationResponseSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationStatusSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationManager::AllocationStatusSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::AllocationStatusSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::AllocationStatusSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::DeviceLocationSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationManager::DeviceLocationSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::DeviceLocationSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::DeviceLocationSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::allocationIDSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationManager::allocationIDSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::allocationIDSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::allocationIDSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationError& _s);
void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::AllocationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::AllocationError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::InvalidAllocationId& _s);
void operator<<=(::CORBA::Any& _a, const CF::AllocationManager::InvalidAllocationId* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::AllocationManager::InvalidAllocationId*& _sp);

inline void operator >>=(CF::AllocationManager::DeviceScopeType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::AllocationManager::DeviceScopeType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::AllocationManager::AUTHORIZED_DEVICES) {
    _e = (CF::AllocationManager::DeviceScopeType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::AllocationManager::DeviceScopeType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::DeviceScopeType& _s);

inline void operator >>=(CF::AllocationManager::AllocationScopeType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::AllocationManager::AllocationScopeType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::AllocationManager::ALL_ALLOCATIONS) {
    _e = (CF::AllocationManager::AllocationScopeType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::AllocationManager::AllocationScopeType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager::AllocationScopeType& _s);

void operator<<=(::CORBA::Any& _a, CF::AllocationManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::AllocationStatusIterator_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::AllocationStatusIterator_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AllocationStatusIterator_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::DeviceLocationIterator_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceLocationIterator_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceLocationIterator_ptr& _s);

inline void operator >>=(CF::ConnectionManager::EndpointKind _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::ConnectionManager::EndpointKind& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::ConnectionManager::ENDPOINT_OBJECTREF) {
    _e = (CF::ConnectionManager::EndpointKind) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::ConnectionManager::EndpointKind _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionManager::EndpointKind& _s);

void operator<<=(::CORBA::Any& _a, const CF::ConnectionManager::EndpointResolutionType& _s);
void operator<<=(::CORBA::Any& _a, CF::ConnectionManager::EndpointResolutionType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ConnectionManager::EndpointResolutionType*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionManager::EndpointResolutionType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::ConnectionManager::EndpointRequest& _s);
extern void operator<<=(::CORBA::Any& _a, CF::ConnectionManager::EndpointRequest* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionManager::EndpointRequest*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ConnectionManager::EndpointRequest*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::ConnectionManager::EndpointStatusType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::ConnectionManager::EndpointStatusType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionManager::EndpointStatusType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ConnectionManager::EndpointStatusType*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::ConnectionManager::ConnectionStatusType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::ConnectionManager::ConnectionStatusType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionManager::ConnectionStatusType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ConnectionManager::ConnectionStatusType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ConnectionManager::ConnectionStatusSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::ConnectionManager::ConnectionStatusSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionManager::ConnectionStatusSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ConnectionManager::ConnectionStatusSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::ConnectionManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ConnectionManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::ConnectionStatusIterator_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ConnectionStatusIterator_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ConnectionStatusIterator_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError& _s);
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError& _s);
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationInsufficientCapacityError& _s);
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationInsufficientCapacityError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationInsufficientCapacityError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration& _s);
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration*& _sp);

void operator<<=(::CORBA::Any& _a, CF::ApplicationFactory_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ApplicationFactory_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ApplicationFactory_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationAlreadyInstalled& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationAlreadyInstalled* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationAlreadyInstalled*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager::ApplicationSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::ApplicationSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationFactorySequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager::ApplicationFactorySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::ApplicationFactorySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationFactorySequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager::DeviceManagerSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::DeviceManagerSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::DeviceManagerSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DomainManagerSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager::DomainManagerSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::DomainManagerSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::DomainManagerSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::RegisterError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::RegisterError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::RegisterError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::UnregisterError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::UnregisterError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::UnregisterError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::NotConnected& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::NotConnected* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::NotConnected*& _sp);

void operator<<=(::CORBA::Any& _a, CF::DomainManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::PortSupplier::UnknownPort& _s);
void operator<<=(::CORBA::Any& _a, const CF::PortSupplier::UnknownPort* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PortSupplier::UnknownPort*& _sp);

void operator<<=(::CORBA::Any& _a, CF::PortSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::PortSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PortSupplier_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::PortSet::PortInfoType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::PortSet::PortInfoType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PortSet::PortInfoType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PortSet::PortInfoType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::PortSet::PortInfoSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::PortSet::PortInfoSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PortSet::PortInfoSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PortSet::PortInfoSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::PortSet_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::PortSet_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PortSet_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::Resource::StartError& _s);
void operator<<=(::CORBA::Any& _a, const CF::Resource::StartError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Resource::StartError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Resource::StopError& _s);
void operator<<=(::CORBA::Any& _a, const CF::Resource::StopError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Resource::StopError*& _sp);

void operator<<=(::CORBA::Any& _a, CF::Resource_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Resource_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Resource_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidState& _s);
void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidState* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Device::InvalidState*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidCapacity& _s);
void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidCapacity* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Device::InvalidCapacity*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Device::InsufficientCapacity& _s);
void operator<<=(::CORBA::Any& _a, const CF::Device::InsufficientCapacity* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Device::InsufficientCapacity*& _sp);

inline void operator >>=(CF::Device::AdminType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::Device::AdminType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::Device::UNLOCKED) {
    _e = (CF::Device::AdminType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::Device::AdminType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::AdminType& _s);

inline void operator >>=(CF::Device::OperationalType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::Device::OperationalType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::Device::DISABLED) {
    _e = (CF::Device::OperationalType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::Device::OperationalType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::OperationalType& _s);

inline void operator >>=(CF::Device::UsageType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::Device::UsageType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::Device::BUSY) {
    _e = (CF::Device::UsageType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::Device::UsageType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::UsageType& _s);

void operator<<=(::CORBA::Any& _a, CF::Device_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Device_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device_ptr& _s);

void operator<<=(::CORBA::Any& _a, CF::ApplicationRegistrar_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ApplicationRegistrar_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ApplicationRegistrar_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentProcessIdType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::Application::ComponentProcessIdType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentProcessIdType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentProcessIdType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentProcessIdSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentProcessIdSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentProcessIdSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentProcessIdSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentElementType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::Application::ComponentElementType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentElementType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentElementType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentElementSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentElementSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentElementSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentElementSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Application::InvalidMetric& _s);
void operator<<=(::CORBA::Any& _a, const CF::Application::InvalidMetric* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::InvalidMetric*& _sp);

void operator<<=(::CORBA::Any& _a, CF::Application_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Application_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application_ptr& _s);

inline void operator >>=(CF::LoadableDevice::LoadType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::LoadableDevice::LoadType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::LoadableDevice::EXECUTABLE) {
    _e = (CF::LoadableDevice::LoadType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::LoadableDevice::LoadType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LoadableDevice::LoadType& _s);

void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind& _s);
void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::LoadFail& _s);
void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::LoadFail* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LoadableDevice::LoadFail*& _sp);

void operator<<=(::CORBA::Any& _a, CF::LoadableDevice_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LoadableDevice_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LoadableDevice_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail*& _sp);

void operator<<=(::CORBA::Any& _a, CF::ExecutableDevice_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ExecutableDevice_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ExecutableDevice_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::DeviceManager::ServiceType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::DeviceManager::ServiceType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager::ServiceType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceManager::ServiceType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DeviceManager::ServiceSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceManager::ServiceSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager::ServiceSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceManager::ServiceSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::DeviceManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::complexDouble& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexDouble* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexDouble*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexDouble*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexDoubleSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexDoubleSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexDoubleSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexDoubleSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexFloat& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexFloat* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexFloat*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexFloat*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexFloatSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexFloatSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexFloatSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexFloatSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexBoolean& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexBoolean* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexBoolean*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexBoolean*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexBooleanSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexBooleanSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexBooleanSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexBooleanSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexULong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexULong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexULongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexULongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULongSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexShort& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexShort* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexShort*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexShort*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexShortSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexShortSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexShortSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexShortSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexOctet& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexOctet* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexOctet*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexOctet*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexOctetSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexOctetSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexOctetSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexOctetSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexChar& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexChar* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexChar*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexChar*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexCharSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexCharSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexCharSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexCharSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexUShort& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexUShort* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexUShort*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexUShort*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexUShortSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexUShortSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexUShortSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexUShortSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexLong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexLong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexLongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexLongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLongSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexLongLong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexLongLong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLongLong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLongLong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexLongLongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexLongLongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLongLongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLongLongSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexULongLong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexULongLong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULongLong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULongLong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexULongLongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexULongLongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULongLongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULongLongSeq*& _sp);



inline void
CF::AggregateDevice::_marshalObjRef(::CF::AggregateDevice_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::FileSystem::_marshalObjRef(::CF::FileSystem_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::File::_marshalObjRef(::CF::File_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ResourceFactory::_marshalObjRef(::CF::ResourceFactory_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::FileManager::_marshalObjRef(::CF::FileManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LifeCycle::_marshalObjRef(::CF::LifeCycle_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::TestableObject::_marshalObjRef(::CF::TestableObject_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::PropertyChangeListener::_marshalObjRef(::CF::PropertyChangeListener_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::PropertySet::_marshalObjRef(::CF::PropertySet_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::PropertyEmitter::_marshalObjRef(::CF::PropertyEmitter_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::AllocationManager::_marshalObjRef(::CF::AllocationManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::AllocationStatusIterator::_marshalObjRef(::CF::AllocationStatusIterator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::DeviceLocationIterator::_marshalObjRef(::CF::DeviceLocationIterator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ConnectionManager::_marshalObjRef(::CF::ConnectionManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ConnectionStatusIterator::_marshalObjRef(::CF::ConnectionStatusIterator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ApplicationFactory::_marshalObjRef(::CF::ApplicationFactory_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::DomainManager::_marshalObjRef(::CF::DomainManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::PortSupplier::_marshalObjRef(::CF::PortSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::PortSet::_marshalObjRef(::CF::PortSet_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Resource::_marshalObjRef(::CF::Resource_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Device::_marshalObjRef(::CF::Device_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ApplicationRegistrar::_marshalObjRef(::CF::ApplicationRegistrar_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Application::_marshalObjRef(::CF::Application_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LoadableDevice::_marshalObjRef(::CF::LoadableDevice_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ExecutableDevice::_marshalObjRef(::CF::ExecutableDevice_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::DeviceManager::_marshalObjRef(::CF::DeviceManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_cf
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_cf
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_cf
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_cf
#endif

#endif  // __cf_hh__

